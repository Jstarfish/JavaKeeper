{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{613:function(e,_,v){\"use strict\";v.r(_);var t=v(6),r=Object(t.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[v(\"h2\",{attrs:{id:\"b树\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#b树\"}},[e._v(\"#\")]),e._v(\" B树\")]),e._v(\" \"),v(\"p\",[e._v(\"B树也是一种用于查找的平衡树，但是它不是二叉树。\")]),e._v(\" \"),v(\"p\",[e._v(\"B-tree 树即 B 树**，B即Balanced，平衡的意思。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如可能会以为B-树是一种树，而B树又是另一种树。而事实上是，B-tree就是指的B树**。特此说明。\")]),e._v(\" \"),v(\"p\",[e._v(\"**B树的定义：**B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。\")]),e._v(\" \"),v(\"p\",[e._v(\"B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。\")]),e._v(\" \"),v(\"p\",[e._v(\"在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。\")]),e._v(\" \"),v(\"p\",[e._v(\"B树作为一种多路搜索树（并不是二叉的）：\")]),e._v(\" \"),v(\"p\",[e._v(\"B树的性质\")]),e._v(\" \"),v(\"p\",[e._v(\"M为树的阶数，B-树或为空树，否则满足下列条件：\")]),e._v(\" \"),v(\"ol\",[v(\"li\",[e._v(\"定义任意非叶子结点最多只有M个儿子；且M>2；\")]),e._v(\" \"),v(\"li\",[e._v(\"根结点的儿子数为[2, M]；\")]),e._v(\" \"),v(\"li\",[e._v(\"除根结点以外的非叶子结点的儿子数为[M/2, M]；\")]),e._v(\" \"),v(\"li\",[e._v(\"每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）\")]),e._v(\" \"),v(\"li\",[e._v(\"非叶子结点的关键字个数=指向儿子的指针个数-1；\")]),e._v(\" \"),v(\"li\",[e._v(\"非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；\")]),e._v(\" \"),v(\"li\",[e._v(\"非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；\")]),e._v(\" \"),v(\"li\",[e._v(\"所有叶子结点位于同一层；\")])]),e._v(\" \"),v(\"p\",[e._v(\"​    如下图为一个M=3的B树示例：\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://camo.githubusercontent.com/dfde3dddb226018bc185288ac84dc380f77be859/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630363132313135353530313737\",alt:\"img\"}})]),e._v(\" \"),v(\"p\",[e._v(\"B树创建的示意图：\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://files.cnblogs.com/yangecnu/btreebuild.gif\",alt:\"img\"}})]),e._v(\" \"),v(\"p\",[e._v(\"B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。\")]),e._v(\" \"),v(\"p\",[e._v(\"B-Tree、B+Tree、红黑树、B*Tree数据结构  https://blog.csdn.net/zhangliangzi/article/details/51367639\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"平衡多路查找树-b-tree\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#平衡多路查找树-b-tree\"}},[e._v(\"#\")]),e._v(\" 平衡多路查找树（B-Tree）\")]),e._v(\" \"),v(\"p\",[e._v(\"B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。\")]),e._v(\" \"),v(\"p\",[e._v(\"系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。\")]),e._v(\" \"),v(\"p\",[e._v(\"InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在\"),v(\"a\",{attrs:{href:\"http://lib.csdn.net/base/mysql\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"MySQL\"),v(\"OutboundLink\")],1),e._v(\"中可通过如下命令查看页的大小：\")]),e._v(\" \"),v(\"div\",{staticClass:\"language- extra-class\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[e._v(\"mysql> show variables like 'innodb_page_size';\\n\")])])]),v(\"ul\",[v(\"li\",[v(\"p\",[e._v(\"1\")])]),e._v(\" \"),v(\"li\",[v(\"p\",[e._v(\"1\")])])]),e._v(\" \"),v(\"p\",[e._v(\"而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。\")]),e._v(\" \"),v(\"p\",[e._v(\"B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。\")]),e._v(\" \"),v(\"p\",[e._v(\"一棵m阶的B-Tree有如下特性：\")]),e._v(\" \"),v(\"ol\",[v(\"li\",[e._v(\"每个节点最多有m个孩子。\")]),e._v(\" \"),v(\"li\",[e._v(\"除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子（其中ceil(x)是一个取上限的函数）。\")]),e._v(\" \"),v(\"li\",[e._v(\"若根节点不是叶子节点，则至少有2个孩子\")]),e._v(\" \"),v(\"li\",[e._v(\"所有叶子节点都在同一层，且不包含其它关键字信息\")]),e._v(\" \"),v(\"li\",[e._v(\"每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）\")]),e._v(\" \"),v(\"li\",[e._v(\"关键字的个数n满足：ceil(m/2)-1 <= n <= m-1\")]),e._v(\" \"),v(\"li\",[e._v(\"ki(i=1,…n)为关键字，且关键字升序排序。\")]),e._v(\" \"),v(\"li\",[e._v(\"Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)\")])]),e._v(\" \"),v(\"p\",[e._v(\"B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：\\n\"),v(\"img\",{attrs:{src:\"https://img-blog.csdn.net/20160202204827368\",alt:\"索引\"}})]),e._v(\" \"),v(\"p\",[e._v(\"每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。\")]),e._v(\" \"),v(\"p\",[e._v(\"模拟查找关键字29的过程：\")]),e._v(\" \"),v(\"ol\",[v(\"li\",[e._v(\"根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】\")]),e._v(\" \"),v(\"li\",[e._v(\"比较关键字29在区间（17,35），找到磁盘块1的指针P2。\")]),e._v(\" \"),v(\"li\",[e._v(\"根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】\")]),e._v(\" \"),v(\"li\",[e._v(\"比较关键字29在区间（26,30），找到磁盘块3的指针P2。\")]),e._v(\" \"),v(\"li\",[e._v(\"根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】\")]),e._v(\" \"),v(\"li\",[e._v(\"在磁盘块8中的关键字列表中找到关键字29。\")])]),e._v(\" \"),v(\"p\",[e._v(\"分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"b-树\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#b-树\"}},[e._v(\"#\")]),e._v(\" B+树\")]),e._v(\" \"),v(\"p\",[e._v(\"B+树是B树的变体，也是一种多路搜索树：\")]),e._v(\" \"),v(\"p\",[e._v(\"1) 其定义基本与B-树相同，除了：\")]),e._v(\" \"),v(\"p\",[e._v(\"2) 非叶子结点的子树指针与关键字个数相同；\")]),e._v(\" \"),v(\"p\",[e._v(\"3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；\")]),e._v(\" \"),v(\"p\",[e._v(\"4) 为所有叶子结点增加一个链指针；\")]),e._v(\" \"),v(\"p\",[e._v(\"5) 所有关键字都在叶子结点出现；\")]),e._v(\" \"),v(\"p\",[e._v(\"下图为M=3的B+树的示意图：\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/5.JPG\",alt:\"img\"}})]),e._v(\" \"),v(\"p\",[e._v(\"B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；\")]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"B+的性质：\")])]),e._v(\" \"),v(\"p\",[e._v(\"1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；\")]),e._v(\" \"),v(\"p\",[e._v(\"2.不可能在非叶子结点命中；\")]),e._v(\" \"),v(\"p\",[e._v(\"3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；\")]),e._v(\" \"),v(\"p\",[e._v(\"4.更适合文件索引系统。\")]),e._v(\" \"),v(\"p\",[e._v(\"下面为一个B+树创建的示意图：\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://files.cnblogs.com/yangecnu/Bplustreebuild.gif\",alt:\"img\"}})]),e._v(\" \"),v(\"p\",[e._v(\"B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。\")]),e._v(\" \"),v(\"p\",[e._v(\"从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。\")]),e._v(\" \"),v(\"p\",[e._v(\"B+Tree相对于B-Tree有几点不同：\")]),e._v(\" \"),v(\"ol\",[v(\"li\",[e._v(\"非叶子节点只存储键值信息。\")]),e._v(\" \"),v(\"li\",[e._v(\"所有叶子节点之间都有一个链指针。\")]),e._v(\" \"),v(\"li\",[e._v(\"数据记录都存放在叶子节点中。\")])]),e._v(\" \"),v(\"p\",[e._v(\"将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：\\n\"),v(\"img\",{attrs:{src:\"https://img-blog.csdn.net/20160202205105560\",alt:\"索引\"}})]),e._v(\" \"),v(\"p\",[e._v(\"通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。\")]),e._v(\" \"),v(\"p\",[e._v(\"可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：\")]),e._v(\" \"),v(\"p\",[e._v(\"InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。\")]),e._v(\" \"),v(\"p\",[e._v(\"实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。\"),v(\"a\",{attrs:{href:\"http://lib.csdn.net/base/mysql\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"mysql\"),v(\"OutboundLink\")],1),e._v(\"的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。\")]),e._v(\" \"),v(\"p\",[e._v(\"数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"b-树-2\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#b-树-2\"}},[e._v(\"#\")]),e._v(\" B*树\")]),e._v(\" \"),v(\"p\",[e._v(\"B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。\")]),e._v(\" \"),v(\"p\",[e._v(\"B*树如下图所示：\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/6.JPG\",alt:\"img\"}})]),e._v(\" \"),v(\"p\",[e._v(\"B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；\")]),e._v(\" \"),v(\"p\",[e._v(\"B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；\")]),e._v(\" \"),v(\"p\",[e._v(\"B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；\")]),e._v(\" \"),v(\"p\",[e._v(\"所以，B*树分配新结点的概率比B+树要低，空间使用率更高。\")])])}),[],!1,null,null,null);_.default=r.exports}}]);","extractedComments":[]}