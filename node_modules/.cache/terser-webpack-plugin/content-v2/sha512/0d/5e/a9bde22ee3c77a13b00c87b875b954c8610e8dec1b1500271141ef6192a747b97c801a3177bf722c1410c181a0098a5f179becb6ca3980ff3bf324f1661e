{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{701:function(a,t,_){\"use strict\";_.r(t);var r=_(6),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[_(\"p\",[_(\"img\",{attrs:{src:\"https://img.starfish.ink/mq/kafka-version-banner.png\",alt:\"\"}})]),a._v(\" \"),_(\"blockquote\",[_(\"p\",[a._v(\"用 Kafka 的时候，其实大家都会有默认的共识，客户端和服务端版本号要尽量统一，因为不同版本之间的差异和功能其实差距还是挺大的，记得刚工作那会，我对 kafka 的命名就很迷惑，0.11.0.0  后来就升级到 1.0.1？这篇算是一个交代吧，祝好\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"kafka-版本命名\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#kafka-版本命名\"}},[a._v(\"#\")]),a._v(\" Kafka 版本命名\")]),a._v(\" \"),_(\"p\",[a._v(\"截止到目前，Apache Kafka 已经到了 3.1 版本，我们看下之前的版本\")]),a._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://img.starfish.ink/mq/kafka-version-name.png\",alt:\"\"}})]),a._v(\" \"),_(\"p\",[a._v(\"比如我们在官网上下载 Kafka 时，会看到这样的版本：\")]),a._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://img.starfish.ink/mq/kafka-version.png\",alt:\"\"}})]),a._v(\" \"),_(\"p\",[a._v(\"Kafka 的版本命名，这么长一串，其实呢，前面的版本号是编译 Kafka 源代码的 Scala 编译器版本，真正的版本号其实是后边的 \"),_(\"code\",[a._v(\"3.1.0\")]),a._v(\"，\")]),a._v(\" \"),_(\"blockquote\",[_(\"p\",[a._v(\"Kafka 服务器端的代码完全由 Scala 语言编写，Scala 同时支持面向对象编程和函数式编程，用 Scala 写成的源代码编译之后也是普通的“.class”文件，因此我们说 Scala 是 JVM 系的语言，它的很多设计思想都是为人称道的。\")])]),a._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://img.starfish.ink/mq/kafka-tags.png\",alt:\"\"}})]),a._v(\" \"),_(\"p\",[a._v(\"1.x 版本后，kafka 启用三位数的命名规则，从 tag 记录可以看到，之前的版本都是 \"),_(\"code\",[a._v(\"0.10.2.2\")]),a._v(\" 、 \"),_(\"code\",[a._v(\"0.11.0.2\")]),a._v(\" 这种，新的版本命名采用了\")]),a._v(\" \"),_(\"p\",[a._v(\"”\"),_(\"strong\",[a._v(\"大版本-小版本-patch版本\")]),a._v(\"“ 这样比较主流的命名方式\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"前面的 3 表示大版本号，即 Major Version；\")]),a._v(\" \"),_(\"li\",[a._v(\"中间的 1 表示小版本号或次版本号，即 Minor Version；\")]),a._v(\" \"),_(\"li\",[a._v(\"最后的01 表示修订版本号，也就是 Patch 号。\")])]),a._v(\" \"),_(\"p\",[a._v(\"Kafka 社区在发布 1.0.0 版本后特意写过一篇文章，宣布 Kafka 版本命名规则正式从 4 位演进到 3 位，比如 0.11.0.0 版本就是 4 位版本号。（其实我们可以把之前的四位 0.10 或者 0.11 这种看成是大版本号，这样就好理解了）\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"kafka-版本演进\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#kafka-版本演进\"}},[a._v(\"#\")]),a._v(\" Kafka 版本演进\")]),a._v(\" \"),_(\"p\",[a._v(\"Kafka 目前总共演进了 8 个大版本，分别是 0.7.x、0.8.x、0.9.x、0.10.x、0.11.x、1.0.x 和 2.0.x 以及现在的 3.0.x，其中的小版本和 Patch 版本很多。哪些版本引入了哪些重大的功能改进？\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"_0-7-x版本\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_0-7-x版本\"}},[a._v(\"#\")]),a._v(\" 0.7.x版本\")]),a._v(\" \"),_(\"p\",[a._v(\"我们先从 0.7 版本说起，实际上也没什么可说的，这是最早开源时的“上古”版本了，以至于我也从来都没有接触过。这个版本只提供了最基础的消息队列功能，甚至连副本机制都没有，我实在想不出有什么理由你要使用这个版本，因此一旦有人向你推荐这个版本，果断走开就好了。\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"_0-8-x版本\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_0-8-x版本\"}},[a._v(\"#\")]),a._v(\" 0.8.x版本\")]),a._v(\" \"),_(\"p\",[a._v(\"两个重要特性，一个是 Kafka 0.8.0 增加了\"),_(\"strong\",[a._v(\"副本机制\")]),a._v(\"，另一个是 Kafka 0.8.2.0 引入了新版本 Producer API。\")]),a._v(\" \"),_(\"p\",[a._v(\"Kafka 从 0.7 时代演进到 0.8 之后正式引入了\"),_(\"strong\",[a._v(\"副本机制\")]),a._v(\"，至此 Kafka 成为了一个真正意义上完备的分布式高可靠消息队列解决方案。有了副本备份机制，Kafka 就能够比较好地做到消息无丢失。那时候生产和消费消息使用的还是老版本的客户端 API，所谓的老版本是指当你用它们的 API 开发生产者和消费者应用时，你需要指定 ZooKeeper 的地址而非 Broker 的地址。\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"_0-9-x版本\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_0-9-x版本\"}},[a._v(\"#\")]),a._v(\" 0.9.x版本\")]),a._v(\" \"),_(\"p\",[a._v(\"Kafka 0.9 是一个重大的版本迭代，增加了非常多的新特性，主要体现在三个方面：\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[_(\"strong\",[a._v(\"安全认证 / 权限\")]),a._v(\"：在0.9.0之前，Kafka 安全方面的考虑几乎为 0。Kafka 0.9.0 在安全认证、授权管理、数据加密等方面都得到了支持，包括支持Kerberos等\")]),a._v(\" \"),_(\"li\",[_(\"strong\",[a._v(\"新版本Consumer API\")]),a._v(\"：Kafka 0.9.0 重写并提供了新版消费端 API，使用方式也是从连接 Zookeeper 切到了连接 Broker，但是此时新版 Consumer API 也不太稳定、存在不少 Bug，生产使用可能会比较痛苦；而 0.9.0 版本的 Producer API 已经比较稳定了，生产使用问题不大\")]),a._v(\" \"),_(\"li\",[_(\"strong\",[a._v(\"Kafka Connect\")]),a._v(\"：Kafka 0.9.0 引入了新的组件 Kafka Connect ，用于实现 Kafka 与其他外部系统之间的数据抽取\")])]),a._v(\" \"),_(\"h3\",{attrs:{id:\"_0-10-x版本\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_0-10-x版本\"}},[a._v(\"#\")]),a._v(\" 0.10.x版本\")]),a._v(\" \"),_(\"p\",[a._v(\"Kafka 0.10 是一个重要的大版本，引入了 Kafka Streams，使得 Kafka 不再仅是一个消息引擎，而是往一个分布式流处理平台方向发展。0.10 大版本包含两个小版本：0.10.1 和 0.10.2，它们的主要功能变更都是在 Kafka Streams 组件上。\")]),a._v(\" \"),_(\"p\",[a._v(\"值得一提的是，自 0.10.2.2 版本起，新版本 Consumer API 已经比较稳定了，而且 Producer API 的性能也得到了提升，因此对于使用 0.10.x 大版本的用户，建议使用或升级到 Kafka 0.10.2.2 版本。\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"_0-11-x版本\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_0-11-x版本\"}},[a._v(\"#\")]),a._v(\" 0.11.x版本\")]),a._v(\" \"),_(\"p\",[a._v(\"Kafka 0.11 是一个里程碑式的大版本，主要有两个大的变更，一是 Kafka 从这个版本开始支持 \"),_(\"strong\",[a._v(\"Exactly-Once 语义\")]),a._v(\" 即精准一次语义，主要是实现了 Producer 端的消息幂等性，以及事务特性，这对于 Kafka 流式处理具有非常大的意义。\")]),a._v(\" \"),_(\"p\",[a._v(\"另一个重大变更是\"),_(\"strong\",[a._v(\"Kafka消息格式的重构\")]),a._v(\"，Kafka 0.11 主要为了实现 Producer 幂等性与事务特性，重构了投递消息的数据结构。这一点非常值得关注，因为 Kafka 0.11之后的消息格式发生了变化，所以我们要特别注意 Kafka 不同版本间消息格式不兼容的问题。\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"_1-x版本\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-x版本\"}},[a._v(\"#\")]),a._v(\" 1.x版本\")]),a._v(\" \"),_(\"p\",[a._v(\"Kafka 1.x 更多的是Kafka Streams方面的改进，以及Kafka Connect的改进与功能完善等。但仍有两个重要特性，一是 Kafka 1.0.0 实现了\"),_(\"strong\",[a._v(\"磁盘的故障转移\")]),a._v(\"，当 Broker 的某一块磁盘损坏时数据会自动转移到其他正常的磁盘上，Broker 还会正常工作，这在之前版本中则会直接导致 Broker 宕机，因此 Kafka 的可用性与可靠性得到了提升；\")]),a._v(\" \"),_(\"p\",[a._v(\"二是 Kafka 1.1.0 开始支持\"),_(\"strong\",[a._v(\"副本跨路径迁移\")]),a._v(\"，分区副本可以在同一 Broker 不同磁盘目录间进行移动，这对于磁盘的负载均衡非常有意义。\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"_2-x版本\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-x版本\"}},[a._v(\"#\")]),a._v(\" 2.x版本\")]),a._v(\" \"),_(\"p\",[a._v(\"Kafka 2.x 更多的也是 Kafka Streams、Connect 方面的性能提升与功能完善，以及安全方面的增强等。一个使用特性，Kafka 2.1.0 开始支持 ZStandard 的压缩方式，提升了消息的压缩比，显著减少了磁盘空间与网络io消耗。\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"_3-x-版本\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-x-版本\"}},[a._v(\"#\")]),a._v(\" 3.x 版本\")]),a._v(\" \"),_(\"p\",[a._v(\"Apache Kafka 3.0 算是一个重要的版本更新，引入了各种新功能、突破性的 API 更改以及对 KRaft 的改进：Apache Kafka 的内置共识机制将取代 Apache ZooKeeper™ ，弃用对 Java 8 和 Scala 2.12 的支持，并且将在 v4.0 中完全删除。除此之外，维护者还决定弃用消息格式 v0 和 v1，将消息格式 v2 作为默认消息格式\")]),a._v(\" \"),_(\"p\",[a._v(\"这个版本目前用的应该不是很多~\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"kafka版本建议\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#kafka版本建议\"}},[a._v(\"#\")]),a._v(\" Kafka版本建议\")]),a._v(\" \"),_(\"ol\",[_(\"li\",[a._v(\"遵循一个基本原则，Kafka 客户端版本和服务端版本应该保持一致，否则可能会遇到一些问题，比如版本不同导致消息格式不兼容问题。\")]),a._v(\" \"),_(\"li\",[a._v(\"根据是否用到了 Kafka 的一些新特性来选择，假如要用到 Kafka 生产端的消息幂等性，那么建议选择 Kafka 0.11 或之后的版本。\")]),a._v(\" \"),_(\"li\",[a._v(\"选择一个自己熟悉且稳定的版本，如果说没有比较熟悉的版本，建议选择一个较新且稳定、使用比较广泛的版本。\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"reference\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reference\"}},[a._v(\"#\")]),a._v(\" Reference\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"https://kafka.apache.org/downloads\")]),a._v(\" \"),_(\"li\",[a._v(\"https://kafka.apache.org/documentation.html#upgrade_110_notable\")]),a._v(\" \"),_(\"li\",[a._v(\"https://developpaper.com/version-number-of-kafka-extremely-important/\")]),a._v(\" \"),_(\"li\",[a._v(\"https://zhuanlan.zhihu.com/p/245941592\")]),a._v(\" \"),_(\"li\",[a._v(\"https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&mid=2247493794&idx=1&sn=13c1c5a6b7acb95fe0a52b191d336f9a&chksm=fbea516dcc9dd87ba1ad6ce86d7b5af3e24c3e25fa526abdbbfb109d343fac30c765bdac6d90&scene=21#wechat_redirect\")])])])}),[],!1,null,null,null);t.default=v.exports}}]);","extractedComments":[]}