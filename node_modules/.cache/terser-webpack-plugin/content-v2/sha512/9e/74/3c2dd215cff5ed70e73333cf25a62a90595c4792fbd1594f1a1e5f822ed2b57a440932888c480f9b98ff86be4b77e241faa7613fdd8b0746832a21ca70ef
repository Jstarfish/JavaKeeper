{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{522:function(v,_,t){v.exports=t.p+\"assets/img/mysql-xa-transactions.2b795bbb.png\"},620:function(v,_,t){\"use strict\";t.r(_);var e=t(6),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[e(\"p\",[e(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/banner-mysql-transaction.png\",alt:\"\"}})]),v._v(\" \"),e(\"blockquote\",[e(\"p\",[v._v(\"Hello，我是海星。\")]),v._v(\" \"),e(\"p\",[v._v(\"MySQL 事务，最熟悉经典的例子，就是你给我转账的例子了，要经过查询余额，减你的钱，加我的钱，这一系列操作必须保证是一体的，这些数据库操作的集合就构成了一个事务。\")]),v._v(\" \"),e(\"p\",[v._v(\"MySQL 事务也是在存储引擎层面实现的，大家用 InnoDB 取代 MyISAM 引擎很重要的一个原因就是 InnoDB 支持事务。\")])]),v._v(\" \"),e(\"h2\",{attrs:{id:\"一、事务基本要素-acid\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、事务基本要素-acid\"}},[v._v(\"#\")]),v._v(\" 一、事务基本要素 — ACID\")]),v._v(\" \"),e(\"p\",[v._v(\"事务是由一组 SQL 语句组成的逻辑处理单元，具有 4 个属性，通常简称为事务的 ACID 属性。\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[e(\"strong\",[v._v(\"A (Atomicity) 原子性\")]),v._v(\"：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\")]),v._v(\" \"),e(\"li\",[e(\"strong\",[v._v(\"C (Consistency) 一致性\")]),v._v(\"：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\")]),v._v(\" \"),e(\"li\",[e(\"strong\",[v._v(\"I (Isolation)隔离性\")]),v._v(\"：一个事务所做的修改在最终提交以前，对其他事务是不可见的。这种属性有时称为『串行化』，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。\")]),v._v(\" \"),e(\"li\",[e(\"strong\",[v._v(\"D (Durability) 持久性\")]),v._v(\"：在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库中，并不会被回滚。\")])]),v._v(\" \"),e(\"h2\",{attrs:{id:\"二、mysql-中事务的使用\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、mysql-中事务的使用\"}},[v._v(\"#\")]),v._v(\" 二、MySQL 中事务的使用\")]),v._v(\" \"),e(\"p\",[v._v(\"MySQL的服务层不管理事务，而是由下层的存储引擎实现。MySQL提供了两种事务型的存储引擎：InnoDB和NDB。\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"MySQL支持本地事务的语句：\")])]),v._v(\" \"),e(\"div\",{staticClass:\"language-mysql extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"START TRANSACTION | BEGIN [WORK] \\nCOMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE] \\nROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE] \\nSET AUTOCOMMIT = {0 | 1}\\n\")])])]),e(\"ul\",[e(\"li\",[v._v(\"START TRANSACTION 或 BEGIN 语句：开始一项新的事务。\")]),v._v(\" \"),e(\"li\",[v._v(\"COMMIT 和 ROLLBACK：用来提交或者回滚事务。\")]),v._v(\" \"),e(\"li\",[v._v(\"CHAIN 和 RELEASE 子句：分别用来定义在事务提交或者回滚之后的操作，CHAIN 会立即启动一个新事物，并且和刚才的事务具有相同的隔离级别，RELEASE 则会断开和客户端的连接。\")]),v._v(\" \"),e(\"li\",[v._v(\"SET AUTOCOMMIT 可以修改当前连接的提交方式， 如果设置了 SET AUTOCOMMIT=0，则设置之后的所有事务都需要通过明确的命令进行提交或者回滚\")])]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"事务使用注意点：\")])]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"如果在锁表期间，用 start transaction 命令开始一个新事务，会造成一个隐含的 unlock tables 被执行。\")]),v._v(\" \"),e(\"li\",[v._v(\"在同一个事务中，最好不使用不同存储引擎的表，否则 ROLLBACK 时需要对非事\\n务类型的表进行特别的处理，因为 COMMIT、ROLLBACK 只能对事务类型的表进行提交和回滚。\")]),v._v(\" \"),e(\"li\",[v._v(\"和 Oracle 的事务管理相同，所有的 DDL 语句是不能回滚的，并且部分的 DDL 语句会造成隐式的提交。\")]),v._v(\" \"),e(\"li\",[v._v(\"在事务中可以通过定义 SAVEPOINT（例如：mysql> savepoint test; 定义 savepoint，名称为 test），指定回滚事务的一个部分，但是不能指定提交事务的一个部分。对于复杂的应用，可以定义多个不同的 SAVEPOINT，满足不同的条件时，回滚\\n不同的 SAVEPOINT。需要注意的是，如果定义了相同名字的 SAVEPOINT，则后面定义的SAVEPOINT 会覆盖之前的定义。对于不再需要使用的 SAVEPOINT，可以通过 RELEASE SAVEPOINT 命令删除 SAVEPOINT， 删除后的 SAVEPOINT， 不能再执行 ROLLBACK TO SAVEPOINT命令。\")])]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"自动提交（autocommit）：\")]),v._v(\"\\nMysql默认采用自动提交模式，可以通过设置autocommit变量来启用或禁用自动提交模式\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[e(\"strong\",[v._v(\"隐式锁定\")])]),v._v(\" \"),e(\"p\",[v._v(\"InnoDB在事务执行过程中，使用两阶段锁协议：\")]),v._v(\" \"),e(\"p\",[v._v(\"随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；\")]),v._v(\" \"),e(\"p\",[v._v(\"锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在\"),e(\"strong\",[v._v(\"同一时刻\")]),v._v(\"被释放。\")])]),v._v(\" \"),e(\"li\",[e(\"p\",[e(\"strong\",[v._v(\"显式锁定\")])]),v._v(\" \"),e(\"p\",[v._v(\"InnoDB也支持通过特定的语句进行显示锁定（存储引擎层）：\")])])]),v._v(\" \"),e(\"div\",{staticClass:\"language-mysql extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"select ... lock in share mode //共享锁 \\nselect ... for update //排他锁 \\n\")])])]),e(\"p\",[v._v(\"​\\tMySQL Server层的显示锁定：\")]),v._v(\" \"),e(\"div\",{staticClass:\"language-mysql extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"lock table和unlock table\\n\")])])]),e(\"h2\",{attrs:{id:\"三、事务隔离级别\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、事务隔离级别\"}},[v._v(\"#\")]),v._v(\" 三、事务隔离级别\")]),v._v(\" \"),e(\"p\",[v._v(\"当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。\")]),v._v(\" \"),e(\"blockquote\",[e(\"p\",[e(\"strong\",[v._v(\"并发事务处理带来的问题\")])]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"更新丢失（Lost Update)： 事务 A 和事务 B 选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题\")]),v._v(\" \"),e(\"li\",[v._v(\"脏读(Dirty Reads)：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据\")]),v._v(\" \"),e(\"li\",[v._v(\"不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。\")]),v._v(\" \"),e(\"li\",[v._v(\"幻读（Phantom Reads)：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\")])])]),v._v(\" \"),e(\"blockquote\",[e(\"p\",[e(\"strong\",[v._v(\"幻读和不可重复读的区别：\")])]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）\")]),v._v(\" \"),e(\"li\",[v._v(\"幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）\")])])]),v._v(\" \"),e(\"blockquote\",[e(\"p\",[e(\"strong\",[v._v(\"并发事务处理带来的问题的解决办法：\")])]),v._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[v._v(\"“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。\")])]),v._v(\" \"),e(\"li\",[e(\"p\",[v._v(\"“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。\")]),v._v(\" \"),e(\"li\",[v._v(\"另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 \"),e(\"strong\",[v._v(\"MVCC\")]),v._v(\" 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。\")])])])])]),v._v(\" \"),e(\"p\",[v._v(\"在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。\")]),v._v(\" \"),e(\"p\",[v._v(\"数据库事务的隔离级别有 4 种，由低到高分别为\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"读未提交（read uncommitted）\")]),v._v(\" \"),e(\"li\",[v._v(\"读提交（read committed）\")]),v._v(\" \"),e(\"li\",[v._v(\"可重复读（repeatable read）\")]),v._v(\" \"),e(\"li\",[v._v(\"串行化（serializable ）\")])]),v._v(\" \"),e(\"p\",[v._v(\"查看当前数据库的事务隔离级别：\")]),v._v(\" \"),e(\"div\",{staticClass:\"language-mysql extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"mysql> show variables like 'transaction_isolation';\\n+-----------------------+-----------------+\\n| Variable_name         | Value           |\\n+-----------------------+-----------------+\\n| transaction_isolation | REPEATABLE-READ |\\n+-----------------------+-----------------+\\n\")])])]),e(\"blockquote\",[e(\"p\",[v._v(\"通俗理解就是\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。\")]),v._v(\" \"),e(\"li\",[v._v(\"读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。\")]),v._v(\" \"),e(\"li\",[v._v(\"可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。\")]),v._v(\" \"),e(\"li\",[v._v(\"串行：我的事务尚未提交，别人就别想改数据。\")])])]),v._v(\" \"),e(\"h4\",{attrs:{id:\"read-uncommitted\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#read-uncommitted\"}},[v._v(\"#\")]),v._v(\" Read uncommitted\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"读未提交，就是一个事务可以读取另一个未提交事务的数据\")]),v._v(\"。\")]),v._v(\" \"),e(\"p\",[v._v(\"事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。\")]),v._v(\" \"),e(\"p\",[v._v(\"分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。\")]),v._v(\" \"),e(\"p\",[v._v(\"那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。\")]),v._v(\" \"),e(\"h4\",{attrs:{id:\"read-committed\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#read-committed\"}},[v._v(\"#\")]),v._v(\" Read committed\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据\")]),v._v(\"。\")]),v._v(\" \"),e(\"p\",[v._v(\"事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…\")]),v._v(\" \"),e(\"p\",[v._v(\"分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。\")]),v._v(\" \"),e(\"p\",[v._v(\"那怎么解决可能的不可重复读问题？Repeatable read ！\")]),v._v(\" \"),e(\"h4\",{attrs:{id:\"repeatable-read\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#repeatable-read\"}},[v._v(\"#\")]),v._v(\" Repeatable read\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"可重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。 MySQL 的默认事务隔离级别\")])]),v._v(\" \"),e(\"p\",[v._v(\"事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。\")]),v._v(\" \"),e(\"p\",[v._v(\"分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即 UPDATE 操作。但是可能还会有幻读问题。因为幻读问题对应的是插入 INSERT 操作，而不是 UPDATE 操作。\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"什么时候会出现幻读？\")])]),v._v(\" \"),e(\"p\",[v._v(\"事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增 INSERT 了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。\")]),v._v(\" \"),e(\"p\",[v._v(\"那怎么解决幻读问题？Serializable！\")]),v._v(\" \"),e(\"h4\",{attrs:{id:\"serializable-序列化\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#serializable-序列化\"}},[v._v(\"#\")]),v._v(\" Serializable 序列化\")]),v._v(\" \"),e(\"p\",[v._v(\"串行化是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。\")]),v._v(\" \"),e(\"p\",[v._v(\"简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。\")]),v._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[v._v(\"事务隔离级别\")]),v._v(\" \"),e(\"th\",[v._v(\"读数据一致性\")]),v._v(\" \"),e(\"th\",[v._v(\"脏读\")]),v._v(\" \"),e(\"th\",[v._v(\"不可重复读\")]),v._v(\" \"),e(\"th\",[v._v(\"幻读\")])])]),v._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[v._v(\"读未提交（read-uncommitted）\")]),v._v(\" \"),e(\"td\",[v._v(\"最低级被，只能保证不读取物理上损坏的数据\")]),v._v(\" \"),e(\"td\",[v._v(\"是\")]),v._v(\" \"),e(\"td\",[v._v(\"是\")]),v._v(\" \"),e(\"td\",[v._v(\"是\")])]),v._v(\" \"),e(\"tr\",[e(\"td\",[v._v(\"读已提交（read-committed）\")]),v._v(\" \"),e(\"td\",[v._v(\"语句级\")]),v._v(\" \"),e(\"td\",[v._v(\"否\")]),v._v(\" \"),e(\"td\",[v._v(\"是\")]),v._v(\" \"),e(\"td\",[v._v(\"是\")])]),v._v(\" \"),e(\"tr\",[e(\"td\",[v._v(\"可重复读（repeatable-read）\")]),v._v(\" \"),e(\"td\",[v._v(\"事务级\")]),v._v(\" \"),e(\"td\",[v._v(\"否\")]),v._v(\" \"),e(\"td\",[v._v(\"否\")]),v._v(\" \"),e(\"td\",[v._v(\"是\")])]),v._v(\" \"),e(\"tr\",[e(\"td\",[v._v(\"串行化（serializable）\")]),v._v(\" \"),e(\"td\",[v._v(\"最高级别，事务级\")]),v._v(\" \"),e(\"td\",[v._v(\"否\")]),v._v(\" \"),e(\"td\",[v._v(\"否\")]),v._v(\" \"),e(\"td\",[v._v(\"否\")])])])]),v._v(\" \"),e(\"p\",[v._v(\"需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"三、mvcc-多版本并发控制\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、mvcc-多版本并发控制\"}},[v._v(\"#\")]),v._v(\" 三、MVCC 多版本并发控制\")]),v._v(\" \"),e(\"p\",[v._v(\"MySQL 的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。\")]),v._v(\" \"),e(\"p\",[v._v(\"可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。\")]),v._v(\" \"),e(\"p\",[v._v(\"MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png\",alt:\"\"}})]),v._v(\" \"),e(\"p\",[v._v(\"典型的 MVCC 实现方式，分为\"),e(\"strong\",[v._v(\"乐观（optimistic）并发控制和悲观（pressimistic）并发控制\")]),v._v(\"。\")]),v._v(\" \"),e(\"p\",[v._v(\"下边通过 InnoDB 的简化版行为来说明 MVCC 是如何工作的。\")]),v._v(\" \"),e(\"p\",[v._v(\"InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作：\")])]),v._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[e(\"strong\",[v._v(\"SELECT\")])]),v._v(\" \"),e(\"p\",[v._v(\"InnoDB 会根据以下两个条件检查每行记录：\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"nnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的\")]),v._v(\" \"),e(\"li\",[v._v(\"行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除\")])])])]),v._v(\" \"),e(\"p\",[v._v(\"​\\t\\t只有符合上述两个条件的才会被查询出来\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[e(\"strong\",[v._v(\"INSERT\")])]),v._v(\" \"),e(\"p\",[v._v(\"InnoDB 为新插入的每一行保存当前系统版本号作为行版本号\")])]),v._v(\" \"),e(\"li\",[e(\"p\",[e(\"strong\",[v._v(\"DELETE\")])]),v._v(\" \"),e(\"p\",[v._v(\"InnoDB 为删除的每一行保存当前系统版本号作为行删除标识\")])]),v._v(\" \"),e(\"li\",[e(\"p\",[e(\"strong\",[v._v(\"UPDATE\")])]),v._v(\" \"),e(\"p\",[v._v(\"InnoDB 为插入的一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识\")])])]),v._v(\" \"),e(\"p\",[v._v(\"保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。\")]),v._v(\" \"),e(\"p\",[v._v(\"MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"四、事务的实现\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#四、事务的实现\"}},[v._v(\"#\")]),v._v(\" 四、事务的实现\")]),v._v(\" \"),e(\"blockquote\",[e(\"p\",[v._v(\"事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。\")])]),v._v(\" \"),e(\"h3\",{attrs:{id:\"事务日志\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事务日志\"}},[v._v(\"#\")]),v._v(\" 事务日志\")]),v._v(\" \"),e(\"p\",[v._v(\"事务日志可以帮助提高事务效率：\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。\")]),v._v(\" \"),e(\"li\",[v._v(\"事务日志采用的是\"),e(\"strong\",[v._v(\"追加\")]),v._v(\"的方式，因此写日志的操作是磁盘上一小块区域内的顺序 I/O，而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。\")]),v._v(\" \"),e(\"li\",[v._v(\"事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。\")]),v._v(\" \"),e(\"li\",[v._v(\"如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。\")])]),v._v(\" \"),e(\"p\",[v._v(\"目前来说，大多数存储引擎都是这样实现的，我们通常称之为\"),e(\"strong\",[v._v(\"预写式日志\")]),v._v(\"（Write-Ahead Logging），修改数据需要写两次磁盘。\")]),v._v(\" \"),e(\"p\",[v._v(\"事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。\")]),v._v(\" \"),e(\"p\",[v._v(\"事务的实现就是如何实现 ACID 特性。\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[e(\"strong\",[v._v(\"RR隔离级别下间隙锁才有效，RC隔离级别下没有间隙锁；\")])]),v._v(\" \"),e(\"li\",[e(\"strong\",[v._v(\"RR隔离级别下为了解决“幻读”问题：“快照读”依靠MVCC控制，“当前读”通过间隙锁解决；\")])]),v._v(\" \"),e(\"li\",[e(\"strong\",[v._v(\"间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间；\")])]),v._v(\" \"),e(\"li\",[e(\"strong\",[v._v(\"间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度。\")])])]),v._v(\" \"),e(\"h3\",{attrs:{id:\"重做日志\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#重做日志\"}},[v._v(\"#\")]),v._v(\" 重做日志\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"redo log（重做日志\")]),v._v(\"） 实现持久化\")]),v._v(\" \"),e(\"p\",[v._v(\"在 InnoDB 的存储引擎中，事务日志通过重做(redo)日志和 InnoDB 存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是 DBA 们口中常说的“日志先行”(Write-Ahead Logging)。\")]),v._v(\" \"),e(\"p\",[v._v(\"当事务提交之后，在 Buffer Pool 中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据 redo log 中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。\")]),v._v(\" \"),e(\"p\",[v._v(\"在系统启动的时候，就已经为 redo log 分配了一块连续的存储空间，以顺序追加的方式记录 Redo Log，通过顺序 I/O 来改善性能。所有的事务共享 redo log 的存储空间，它们的 redo log 按语句的执行顺序，依次交替的记录在一起。\")]),v._v(\" \"),e(\"blockquote\",[e(\"p\",[v._v(\"InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png\",alt:\"\"}})]),v._v(\" \"),e(\"p\",[v._v(\"write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。\")]),v._v(\" \"),e(\"p\",[v._v(\"write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。\")]),v._v(\" \"),e(\"p\",[v._v(\"有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为\"),e(\"strong\",[v._v(\"crash-safe\")]),v._v(\"。\")])]),v._v(\" \"),e(\"h3\",{attrs:{id:\"回滚日志\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#回滚日志\"}},[v._v(\"#\")]),v._v(\" 回滚日志\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"undo log（回滚日志）\")]),v._v(\"  实现原子性\")]),v._v(\" \"),e(\"p\",[v._v(\"undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录 redo log，还会记录一定量的 undo log。undo log 记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据 undo log 进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。\")]),v._v(\" \"),e(\"p\",[v._v(\"二种日志均可以视为一种恢复操作，redo_log 是恢复提交事务修改的页操作，而 undo_log 是回滚行记录到特定版本。二者记录的内容也不同，redo_log 是\"),e(\"strong\",[v._v(\"物理日志\")]),v._v(\"，记录页的物理修改操作，而 undo_log 是\"),e(\"strong\",[v._v(\"逻辑日志\")]),v._v(\"，根据每行记录进行记录。\")]),v._v(\" \"),e(\"blockquote\",[e(\"p\",[v._v(\"回滚日志可以\"),e(\"strong\",[v._v(\"理解\")]),v._v(\"为，我们在事务中使用的每一条 \"),e(\"code\",[v._v(\"INSERT\")]),v._v(\" 都对应了一条 \"),e(\"code\",[v._v(\"DELETE\")]),v._v(\"，每一条 \"),e(\"code\",[v._v(\"UPDATE\")]),v._v(\" 也都对应一条相反的 \"),e(\"code\",[v._v(\"UPDATE\")]),v._v(\" 语句。\")]),v._v(\" \"),e(\"p\",[v._v(\"假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png\",alt:\"\"}})]),v._v(\" \"),e(\"p\",[v._v(\"当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。\")]),v._v(\" \"),e(\"p\",[v._v(\"同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。\")]),v._v(\" \"),e(\"p\",[v._v(\"在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。\")]),v._v(\" \"),e(\"p\",[v._v(\"这时，你会说这看上去不太现实啊。如果一个库有 100G，那么我启动一个事务，MySQL 就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。\")]),v._v(\" \"),e(\"p\",[v._v(\"实际上，我们并不需要拷贝出这 100G 的数据。我们先来看看这个快照是怎么实现的。\")]),v._v(\" \"),e(\"p\",[v._v(\"InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。\")]),v._v(\" \"),e(\"p\",[v._v(\"而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。\")]),v._v(\" \"),e(\"p\",[v._v(\"也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。\")]),v._v(\" \"),e(\"p\",[v._v(\"如图 2 所示，就是一个记录被多个事务连续更新后的状态。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png\",alt:\"\"}})]),v._v(\" \"),e(\"p\",[v._v(\"图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25\")]),v._v(\" \"),e(\"p\",[v._v(\"你可能会问，前面的文章不是说，语句更新会生成 undo log（回滚日志）吗？那么，\"),e(\"strong\",[v._v(\"undo log 在哪呢？\")])]),v._v(\" \"),e(\"p\",[v._v(\"实际上，图 2 中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。\")]),v._v(\" \"),e(\"p\",[v._v(\"明白了多版本和 row trx_id 的概念后，我们再来想一下，InnoDB 是怎么定义那个“100G”的快照的。\")]),v._v(\" \"),e(\"p\",[v._v(\"按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。\")]),v._v(\" \"),e(\"p\",[v._v(\"因此，一个事务只需要在启动的时候声明说，“\"),e(\"strong\",[v._v(\"以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本\")]),v._v(\"”。\")]),v._v(\" \"),e(\"p\",[v._v(\"在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。\")]),v._v(\" \"),e(\"p\",[v._v(\"数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。\")]),v._v(\" \"),e(\"p\",[v._v(\"这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。\")]),v._v(\" \"),e(\"p\",[v._v(\"而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。\")]),v._v(\" \"),e(\"p\",[v._v(\"这个视图数组把所有的 row trx_id 分成了几种不同的情况。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png\",alt:\"\"}})])]),v._v(\" \"),e(\"p\",[v._v(\"在数据库系统中，事务的原子性和持久性是由事务日志（transaction log）保证的，在实现时也就是上面提到的两种日志，前者用于对事务的影响进行撤销，后者在错误处理时对已经提交的事务进行重做，它们能保证两点：\")]),v._v(\" \"),e(\"ol\",[e(\"li\",[v._v(\"发生错误或者需要回滚的事务能够成功回滚（原子性）；\")]),v._v(\" \"),e(\"li\",[v._v(\"在事务提交后，数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据（持久性）；\")])]),v._v(\" \"),e(\"h3\",{attrs:{id:\"mysql对分布式事务的支持\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql对分布式事务的支持\"}},[v._v(\"#\")]),v._v(\" MySQL对分布式事务的支持\")]),v._v(\" \"),e(\"p\",[e(\"a\",{attrs:{href:\"https://dev.mysql.com/doc/refman/5.7/en/xa.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v._v(\"官方分布式事务文档\"),e(\"OutboundLink\")],1)]),v._v(\" \"),e(\"p\",[v._v(\"分布式事务的实现方式有很多，既可以采用innoDB提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下innoDB对分布式事务的支持。\")]),v._v(\" \"),e(\"p\",[v._v(\"MySQL 从 5.0.3 开始支持分布式事务，\"),e(\"strong\",[v._v(\"当前分布式事务只支持 InnoDB 存储引擎\")]),v._v(\"。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:t(522),alt:\"img\"}})]),v._v(\" \"),e(\"p\",[v._v(\"如图，mysql的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"应用程序：定义了事务的边界，指定需要做哪些事务；\")]),v._v(\" \"),e(\"li\",[v._v(\"资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；\")]),v._v(\" \"),e(\"li\",[v._v(\"事务管理器：协调参与了全局事务中的各个事务。\")])]),v._v(\" \"),e(\"p\",[v._v(\"分布式事务采用两段式提交（two-phase commit）的方式：\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"第一阶段所有的事务节点开始准备，告诉事务管理器ready。\")]),v._v(\" \"),e(\"li\",[v._v(\"第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。\")])]),v._v(\" \"),e(\"p\",[v._v(\"分布式事务（XA 事务）的 SQL 语法主要包括：\")]),v._v(\" \"),e(\"div\",{staticClass:\"language-mysql extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"XA {START|BEGIN} xid [JOIN|RESUME]\\n\")])])]),e(\"p\",[v._v(\"虽然 MySQL 支持分布式事务，但是在测试过程中，还是发现存在一些问题：\\n如果分支事务在达到 prepare 状态时，数据库异常重新启动，服务器重新启动以后，可以继续对分支事务进行提交或者回滚得操作，但是提交的事务没有写 binlog，存在一定的隐患，可能导致使用 binlog 恢复丢失部分数据。如果存在复制的数据库，则有可能导致主从数据库的数据不一致。\")]),v._v(\" \"),e(\"p\",[v._v(\"如果分支事务在执行到 prepare 状态时，数据库异常，且不能再正常启动，需要使用备份和 binlog 来恢复数据，那么那些在 prepare 状态的分支事务因为并没有记录到 binlog，所以不能通过 binlog 进行恢复，在数据库恢复后，将丢失这部分的数据。\")]),v._v(\" \"),e(\"p\",[v._v(\"如果分支事务的客户端连接异常中止，那么数据库会自动回滚未完成的分支事务，如果此时分支事务已经执行到 prepare 状态， 那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。\\n总之， MySQL 的分布式事务还存在比较严重的缺陷， 在数据库或者应用异常的情况下，可能会导致分布式事务的不完整。如果应用对于数据的完整性要求不是很高，则可以考虑使用。如果应用对事务的完整性有比较高的要求，那么对于当前的版本，则不推荐使用分布式事务。\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"总结\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[v._v(\"#\")]),v._v(\" 总结\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"references\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#references\"}},[v._v(\"#\")]),v._v(\" References\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[e(\"a\",{attrs:{href:\"https://draveness.me/mysql-transaction/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v._v(\"『浅入深出』MySQL 中事务的实现\"),e(\"OutboundLink\")],1)]),v._v(\" \"),e(\"li\",[e(\"a\",{attrs:{href:\"https://zhuanlan.zhihu.com/p/29166694\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v._v(\"数据库事务与MySQL事务总结\"),e(\"OutboundLink\")],1)])])])}),[],!1,null,null,null);_.default=a.exports}}]);","extractedComments":[]}