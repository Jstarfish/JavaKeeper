{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[210],{804:function(t,s,r){\"use strict\";r.r(s);var a=r(6),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"assert\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#assert\"}},[t._v(\"#\")]),t._v(\" Assert\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"概述\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#概述\"}},[t._v(\"#\")]),t._v(\" 概述\")]),t._v(\" \"),r(\"p\",[t._v(\"业务代码中我们是不会使用断言的，但是看各种源码或单元测试的时候，肯定会遇到 Assert，你有了解过吗？这玩意到底是干嘛的？\")]),t._v(\" \"),r(\"blockquote\",[r(\"p\",[t._v(\"编写代码时，我们总是会做出一些假设，断言就是用于在代码中捕捉这些假设，可以将断言看作是\"),r(\"strong\",[t._v(\"异常处理\")]),t._v(\"的一种高级形式。断言表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言，而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新启用断言。\")])]),t._v(\" \"),r(\"p\",[t._v(\"Assert 其实就是用来调试程序的\")]),t._v(\" \"),r(\"p\",[t._v(\"java 断言 assert 是 jdk1.4 引入的。\")]),t._v(\" \"),r(\"p\",[t._v(\"jvm断言默认是关闭的。\")]),t._v(\" \"),r(\"p\",[t._v(\"断言可以局部开启的，如：父类禁止断言，而子类开启断言，所以一般说“\"),r(\"strong\",[t._v(\"断言不具有继承性\")]),t._v(\"”。\")]),t._v(\" \"),r(\"p\",[r(\"strong\",[t._v(\"断言只适用复杂的调式过程。\")])]),t._v(\" \"),r(\"p\",[r(\"strong\",[t._v(\"断言一般用于程序执行结构的判断，千万不要让断言处理业务流程。\")])]),t._v(\" \"),r(\"h2\",{attrs:{id:\"语法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#语法\"}},[t._v(\"#\")]),t._v(\" 语法\")])])}),[],!1,null,null,null);s.default=e.exports}}]);","extractedComments":[]}