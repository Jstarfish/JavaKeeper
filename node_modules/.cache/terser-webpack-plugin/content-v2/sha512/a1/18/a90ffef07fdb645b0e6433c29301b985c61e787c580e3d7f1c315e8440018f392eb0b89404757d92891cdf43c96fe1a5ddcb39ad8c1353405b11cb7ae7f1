{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{611:function(t,s,a){\"use strict\";a.r(s);var e=a(6),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"blockquote\",[a(\"p\",[t._v(\"一提到 Redis，我们的脑子里马上就会出现一个词：“快。”\")]),t._v(\" \"),a(\"p\",[t._v(\"数据库这么多，为啥 Redis 能有这么突出的表现呢？一方面，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。另一方面，这要归功于它的数据结构。\")]),t._v(\" \"),a(\"p\",[t._v(\"这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。\")])]),t._v(\" \"),a(\"p\",[t._v(\"我们都知道 Redis 是个 KV 数据库，那 KV 结构的数据在 Redis 中是如何存储的呢？\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"一、kv-如何存储\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、kv-如何存储\"}},[t._v(\"#\")]),t._v(\" 一、KV 如何存储？\")]),t._v(\" \"),a(\"p\",[t._v(\"为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。类似我们的 HashMap\")]),t._v(\" \"),a(\"p\",[t._v(\"看到这里，你可能会问了：“如果值是集合类型的话，作为数组元素的哈希桶怎么来保存呢？”\")]),t._v(\" \"),a(\"p\",[t._v(\"其实，\"),a(\"strong\",[t._v(\"哈希桶中的元素保存的并不是值本身，而是指向具体值的指针\")]),t._v(\"。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。\")]),t._v(\" \"),a(\"p\",[t._v(\"在下图中，可以看到，哈希桶中的 entry 元素中保存了 \"),a(\"code\",[t._v(\"*key\")]),t._v(\" 和  \"),a(\"code\",[t._v(\"*value\")]),t._v(\" 指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过 \"),a(\"code\",[t._v(\"*value\")]),t._v(\" 指针被查找到。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://img.starfish.ink/redis/redis-kv.png\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"因为这个哈希表保存了所有的键值对，所以，也把它称为\"),a(\"strong\",[t._v(\"全局哈希表\")]),t._v(\"。哈希表的最大好处很明显，就是让我们可以用 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。\")],1),t._v(\" \"),a(\"div\",{staticClass:\"language-c extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"redisObject\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" type\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"4\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"      \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 类型\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" encoding\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"4\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"  \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 编码\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" lru\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\"LRU_BITS\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 对象最后一次被访问的时间\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" refcount\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\\t\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//引用计数\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\\t\\t\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//指向实际值的指针\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),a(\"p\",[t._v(\"你看，这个查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说，不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。但是，如果你只是了解了哈希表的 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" 复杂度和快速查找特性，那么，当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。\")],1),t._v(\" \"),a(\"h3\",{attrs:{id:\"为什么哈希表操作变慢了\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么哈希表操作变慢了\"}},[t._v(\"#\")]),t._v(\" 为什么哈希表操作变慢了？\")]),t._v(\" \"),a(\"p\",[t._v(\"当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，也就是指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。毕竟，哈希桶的个数通常要少于 key 的数量，这也就是说，难免会有一些 key 的哈希值对应到了同一个哈希桶中。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 解决哈希冲突的方式，就是\"),a(\"mark\",[t._v(\"链式哈希\")]),t._v(\"。和 JDK7 中的 HahsMap 类似，链式哈希也很容易理解，\"),a(\"strong\",[t._v(\"就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://img.starfish.ink/redis/1*gsGJWchCH4V3BukF9xkHpA.jpeg\",alt:\"img\"}})]),t._v(\" \"),a(\"p\",[t._v(\"但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。\")]),t._v(\" \"),a(\"p\",[t._v(\"所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://img.starfish.ink/redis/1*2alok5x1yuMJ3Z0V2RK--w.jpeg\",alt:\"img\"}})]),t._v(\" \"),a(\"p\",[t._v(\"其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-c extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dict\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    dictType \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"type\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n    dictEntry \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ht_table\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" ht_used\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" rehashidx\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* rehashing not in progress if rehashidx == -1 */\")]),t._v(\"\\n\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* Keep small vars at end for optimal (minimal) struct padding */\")]),t._v(\"\\n    int16_t pauserehash\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* If >0 rehashing is paused (<0 indicates coding error) */\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"signed\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"char\")]),t._v(\" ht_size_exp\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* exponent of size. (size = 1<<exp) */\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),a(\"p\",[t._v(\"一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；\")]),t._v(\" \"),a(\"li\",[t._v(\"把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；\")]),t._v(\" \"),a(\"li\",[t._v(\"释放哈希表 1 的空间。\")])]),t._v(\" \"),a(\"p\",[t._v(\"到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了\"),a(\"mark\",[t._v(\"渐进式 rehash\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。\")]),t._v(\" \"),a(\"p\",[t._v(\"渐进式 rehash 这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。\")]),t._v(\" \"),a(\"p\",[t._v(\"好了，到这里，你应该就能理解，Redis 的键和值是怎么通过哈希表组织的了。对于 String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" 操作复杂度也就是它的复杂度了。但是，对于集合类型来说，即使找到哈希桶了，还要在集合中再进一步操作。\")],1),t._v(\" \"),a(\"p\",[t._v(\"所以集合的操作效率又与集合的底层数据结构有关，接下来我们再说 Redis 的底层数据结构~\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"一、redis-的五种基本数据类型和其数据结构\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、redis-的五种基本数据类型和其数据结构\"}},[t._v(\"#\")]),t._v(\" 一、Redis 的五种基本数据类型和其数据结构\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://img.starfish.ink/redis/redis-data-type.drawio.png\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"由于 Redis 是基于标准 C 写的，只有最基础的数据类型，因此 Redis 为了满足对外使用的 5 种基本数据类型，开发了属于自己\"),a(\"strong\",[t._v(\"独有的一套基础数据结构\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"Redis\")]),t._v(\" 有 5 种基础数据类型，它们分别是：\"),a(\"strong\",[t._v(\"string(字符串)\")]),t._v(\"、\"),a(\"strong\",[t._v(\"list(列表)\")]),t._v(\"、\"),a(\"strong\",[t._v(\"hash(字典)\")]),t._v(\"、\"),a(\"strong\",[t._v(\"set(集合)\")]),t._v(\" 和 \"),a(\"strong\",[t._v(\"zset(有序集合)\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 底层的数据结构包括：\"),a(\"strong\",[t._v(\"简单动态数组SDS、链表、字典、跳跃链表、整数集合、快速列表、压缩列表、对象。\")])]),t._v(\" \"),a(\"p\",[t._v(\"Redis 为了平衡空间和时间效率，针对 value 的具体类型在底层会采用不同的数据结构来实现，其中哈希表和压缩列表是复用比较多的数据结构，如下图展示了对外数据类型和底层数据结构之间的映射关系：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://img.starfish.ink/redis/redis-data-types.png\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"下面我们具体看下各种数据类型的底层实现和操作。\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"安装好 Redis，我们可以使用 \"),a(\"code\",[t._v(\"redis-cli\")]),t._v(\" 来对 Redis 进行命令行的操作，当然 Redis 官方也提供了在线的调试器，你也可以在里面敲入命令进行操作：http://try.redis.io/#run\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_1、string-字符串\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、string-字符串\"}},[t._v(\"#\")]),t._v(\" 1、String（字符串）\")]),t._v(\" \"),a(\"p\",[t._v(\"String 类型是二进制安全的。意思是 Redis 的 String 可以包含任何数据。比如 jpg 图片或者序列化的对象 。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 的字符串是动态字符串，是可以修改的字符串，\"),a(\"strong\",[t._v(\"内部结构实现上类似于 Java 的 ArrayList\")]),t._v(\"，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。\")]),t._v(\" \"),a(\"p\",[t._v(\"根据传统， C 语言使用长度为 \"),a(\"code\",[t._v(\"N+1\")]),t._v(\" 的字符数组来表示长度为 \"),a(\"code\",[t._v(\"N\")]),t._v(\" 的字符串， 并且字符数组的最后一个元素总是空字符 \"),a(\"code\",[t._v(\"'\\\\0'\")]),t._v(\" 。\")]),t._v(\" \"),a(\"p\",[t._v(\"比如说， 下图就展示了一个值为 \"),a(\"code\",[t._v('\"Redis\"')]),t._v(\" 的 C 字符串：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://img.starfish.ink/redis/c-string.png\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求\")]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"http://redisbook.com/preview/sds/different_between_sds_and_c_string.html\",title:\"SDS 与 C 字符串的区别\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"下面说明 SDS 比 C 字符串更适用于 Redis 的原因\"),a(\"OutboundLink\")],1),t._v(\"：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[a(\"strong\",[t._v(\"常数复杂度获取字符串长度\")])]),t._v(\" \"),a(\"p\",[t._v(\"因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串，对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"5.495ex\",height:\"2.262ex\",viewBox:\"0 -750 2429 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"4E\",d:\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(2040, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])])],1),t._v(\" \"),a(\"p\",[t._v(\"和 C 字符串不同， 因为 SDS 在 \"),a(\"code\",[t._v(\"len\")]),t._v(\" 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])])],1),t._v(\" \"),a(\"p\",[t._v(\"举个例子， 对于下图所示的 SDS 来说， 程序只要访问 SDS 的 \"),a(\"code\",[t._v(\"len\")]),t._v(\" 属性， 就可以立即知道 SDS 的长度为 \"),a(\"code\",[t._v(\"5\")]),t._v(\" 字节：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://img.starfish.ink/redis/redis-sds.png\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"5.495ex\",height:\"2.262ex\",viewBox:\"0 -750 2429 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"4E\",d:\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(2040, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" 降低到了 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈\")],1)]),t._v(\" \"),a(\"li\",[a(\"p\",[a(\"strong\",[t._v(\"缓冲区溢出/内存泄漏\")])]),t._v(\" \"),a(\"p\",[t._v(\"跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，操作不当就很容易造成上述问题；\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[a(\"strong\",[t._v(\"减少修改字符串带来的内存分配次数\")])]),t._v(\" \"),a(\"p\",[t._v(\"因为 C 字符串并不记录自身的长度， 所以对于一个包含了 \"),a(\"code\",[t._v(\"N\")]),t._v(\" 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 \"),a(\"code\",[t._v(\"N+1\")]),t._v(\" 个字符长的数组（额外的一个字符空间用于保存空字符）。\")]),t._v(\" \"),a(\"p\",[t._v(\"因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。\")])]),t._v(\" \"),a(\"p\",[t._v(\"为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， \"),a(\"code\",[t._v(\"buf\")]),t._v(\" 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 \"),a(\"code\",[t._v(\"free\")]),t._v(\" 属性记录。\")]),t._v(\" \"),a(\"p\",[t._v(\"通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[a(\"strong\",[t._v(\"二进制安全\")])]),t._v(\" \"),a(\"p\",[t._v(\"因为 C 语言中的字符串必须符合某种编码（比如 ASCII），并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"二进制安全\")]),t._v(\"意味着 SDS 字符串可以包含任何数据，包括 null 字节。这通过显式存储字符串的长度而不是依赖 null 终止符来实现。\")])])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"字符串对象的编码可以使 int、raw 或者 embstr，\")]),t._v(\" \"),a(\"p\",[t._v(\"当存储的值为整数，且值的大小可以用 long 类型表示时，使用 int 编码。\")]),t._v(\" \"),a(\"p\",[t._v(\"如果字符串对象保存的事一个字符串值，并且这个字符串的长度 <= 44 字节，采用 embstr 编码，否则使用 raw。\")]),t._v(\" \"),a(\"p\",[t._v(\"可以通过 \"),a(\"code\",[t._v(\"TYPE KEY_NAME\")]),t._v(\" 查看 key 所存储的值的类型验证下。\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_2、list-列表\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、list-列表\"}},[t._v(\"#\")]),t._v(\" 2、List（列表）\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)\")])]),t._v(\" \"),a(\"p\",[t._v(\"当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"右边进左边出：队列\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language-shell extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpush books python java golang \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" llen books\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"python\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"java\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"golang\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"nil\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])])]),a(\"p\",[a(\"strong\",[t._v(\"右边进右边出：栈\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language-shell extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpush books python java golang\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),t._v(\"\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"golang\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"java\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"python\"')]),t._v(\"\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"nil\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])])]),a(\"h4\",{attrs:{id:\"列表的实现\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#列表的实现\"}},[t._v(\"#\")]),t._v(\" \"),a(\"a\",{attrs:{href:\"http://redisbook.com/preview/adlist/implementation.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"列表的实现\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"p\",[t._v(\"列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是压缩列表（ziplist），另一种是双向循环链表。\")]),t._v(\" \"),a(\"p\",[t._v(\"当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"列表中保存的单个数据（有可能是字符串类型的）小于 64 字节；\")]),t._v(\" \"),a(\"li\",[t._v(\"列表中数据个数少于 512 个。\")])]),t._v(\" \"),a(\"p\",[t._v(\"从 Redis 3.2 版本开始，列表的底层实现由压缩列表组成的快速列表（quicklist）所取代。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"快速列表由多个 ziplist 节点组成，每个节点使用指针连接，形成一个链表。\")]),t._v(\" \"),a(\"li\",[t._v(\"这种方式结合了压缩列表的内存效率和小元素的快速访问，以及双向链表的灵活性。\")])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存，是相较于数组的存储思路而言的。\")]),t._v(\" \"),a(\"p\",[t._v(\"它并不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存，是相较于数组的存储思路而言的。我们知道，数组要求每个元素的大小相同，如果我们要存储不同长度的字符串，那我们就需要用最大长度的字符串大小作为元素的大小（假设是 20 个字节）。那当我们存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据的存储。而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。当列表中存储的数据量比较大的时候，也就是不能同时满足刚刚讲的两个条件的时候，列表就要通过双向循环链表来实现了。\")])]),t._v(\" \"),a(\"p\",[t._v(\"我们可以从 \"),a(\"a\",{attrs:{href:\"https://github.com/redis/redis/blob/unstable/src/adlist.h\",title:\"redis源码\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"源码\"),a(\"OutboundLink\")],1),t._v(\" 的 \"),a(\"code\",[t._v(\"adlist.h/listNode\")]),t._v(\" 来看到对其的定义：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-c extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* Node, List, and Iterator are the only data structures used currently. */\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listNode\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listNode\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"prev\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 前置节点\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listNode\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 后置节点\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"value\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"           \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点的值\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" listNode\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listIter\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    listNode \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" direction\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" listIter\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"list\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    listNode \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"head\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 表头节点\")]),t._v(\"\\n    listNode \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"tail\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 表尾节点\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"dup\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点值复制函数\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"free\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点值释放函数\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"match\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"key\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点值对比函数\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" len\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 链表所包含的节点数量\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" list\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),a(\"h3\",{attrs:{id:\"_3、hash-字典\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、hash-字典\"}},[t._v(\"#\")]),t._v(\" 3、Hash（字典）\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis hash 是一个键值对集合。KV 模式不变，但 V 又是一个键值对。\")]),t._v(\" \"),a(\"p\",[t._v(\"字典类型也有两种实现方式。一种是我们刚刚讲到的压缩列表，另一种是散列表。\")]),t._v(\" \"),a(\"p\",[t._v(\"同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"字典中保存的键和值的大小都要小于 64 字节；\")]),t._v(\" \"),a(\"li\",[t._v(\"字典中键值对的个数要小于 512 个。\")])]),t._v(\" \"),a(\"p\",[t._v(\"当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型。Redis 使用 \"),a(\"code\",[t._v(\"MurmurHash2\")]),t._v(\" 这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容。当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右（具体值需要计算才能得到，如果感兴趣，你可以去\"),a(\"a\",{attrs:{href:\"https://github.com/redis/redis/blob/unstable/src/dict.c\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"阅读源码\"),a(\"OutboundLink\")],1),t._v(\"）。\")]),t._v(\" \"),a(\"p\",[t._v(\"扩容就回涉及到键值对的迁移。具体来说，迁移操作会在以下两种情况下进行：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[a(\"strong\",[t._v(\"Lazy Rehashing（懒惰重哈希）：\")]),t._v(\" Redis采用了懒惰重哈希的策略，即在进行哈希表扩容时，并不会立即将所有键值对都重新散列到新的存储桶中。而是在有需要的时候，例如进行读取操作时，才会将相应的键值对从旧存储桶迁移到新存储桶中。这种方式避免了一次性大规模的迁移操作，减少了扩容期间的阻塞时间。\")]),t._v(\" \"),a(\"li\",[a(\"strong\",[t._v(\"Redis事件循环（Event Loop）：\")]),t._v(\" Redis会在事件循环中定期执行一些任务，包括一些与哈希表相关的操作。在事件循环中，Redis会检查是否有需要进行迁移的键值对，并将它们从旧存储桶迁移到新存储桶中。这样可以保证在系统负载较轻的时候进行迁移，减少对服务性能的影响。\")])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"字典的实现\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字典的实现\"}},[t._v(\"#\")]),t._v(\" \"),a(\"a\",{attrs:{href:\"http://redisbook.com/preview/dict/datastruct.html\",title:\"字典的实现\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"字典的实现\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"p\",[t._v(\"Redis 字典源码由 \"),a(\"code\",[t._v(\"dict.h/dictht\")]),t._v(\" 结构定义：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-c extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictEntry\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"key\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"union\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"val\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        uint64_t u64\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        int64_t s64\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"double\")]),t._v(\" d\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" v\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictEntry\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dictEntry\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* This is our hash table structure. Every dictionary has two of this as we\\n * implement incremental rehashing, for the old to the new table. */\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictht\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    dictEntry \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"table\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表数组\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" size\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表大小\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" sizemask\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表大小掩码，用于计算索引值,总是等于 size - 1\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" used\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 该哈希表已有节点的数量\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dictht\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dict\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    dictType \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"type\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 类型特定函数\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"privdata\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 私有数据 \")]),t._v(\"\\n    dictht ht\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表\")]),t._v(\"\\n\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" rehashidx\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* rehashing not in progress if rehashidx == -1 */\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" iterators\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* number of iterators currently running */\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dict\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),a(\"h3\",{attrs:{id:\"_4、set-集合\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、set-集合\"}},[t._v(\"#\")]),t._v(\" 4、Set（集合）\")]),t._v(\" \"),a(\"p\",[t._v(\"集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于有序数组，另一种是基于散列表。当要存储的数据，同时满足下面这样两个条件的时候，Redis 就采用有序数组，来实现集合这种数据类型。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"存储的数据都是整数；\")]),t._v(\" \"),a(\"li\",[t._v(\"存储的数据元素个数不超过 512 个。\")])]),t._v(\" \"),a(\"p\",[t._v(\"当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 的 Set 是 String 类型的无序集合。它是通过 HashTable 实现的， 相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 \"),a(\"code\",[t._v(\"NULL\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-c extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 定义整数集合结构\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"intset\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    uint32_t encoding\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"  \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 编码方式\")]),t._v(\"\\n    uint32_t length\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 集合长度\")]),t._v(\"\\n    int8_t contents\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"  \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 元素数组\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" intset\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 定义哈希表节点结构\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictEntry\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"key\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"              \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 键\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"union\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"val\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"          \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 值\")]),t._v(\"\\n        uint64_t u64\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        int64_t s64\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"double\")]),t._v(\" d\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" v\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictEntry\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 指向下一个节点的指针\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dictEntry\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 定义哈希表结构\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictht\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    dictEntry \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"table\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"      \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 存储桶数组\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" size\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"     \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 存储桶数量\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" sizemask\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 存储桶数量掩码\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" used\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"     \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 已使用存储桶数量\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dictht\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 定义集合结构\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    uint32_t encoding\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 编码方式\")]),t._v(\"\\n    dictht \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ht\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"        \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表\")]),t._v(\"\\n    intset \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"is\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"        \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 整数集合\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" set\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),a(\"h3\",{attrs:{id:\"_5、zset-sorted-set-有序集合\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5、zset-sorted-set-有序集合\"}},[t._v(\"#\")]),t._v(\" 5、Zset(sorted set：有序集合)\")]),t._v(\" \"),a(\"p\",[t._v(\"zset 和 set 一样也是 String 类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 正是通过分数来为集合中的成员进行从小到大的排序。zset 的成员是唯一的，但分数(score)却可以重复。\")]),t._v(\" \"),a(\"p\",[t._v(\"它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「\"),a(\"strong\",[t._v(\"跳跃列表\")]),t._v(\"」的数据结构。\")]),t._v(\" \"),a(\"p\",[t._v(\"zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。\")]),t._v(\" \"),a(\"p\",[t._v(\"实际上，跟 Redis 的其他数据类型一样，有序集合也并不仅仅只有跳表这一种实现方式。当数据量比较小的时候，Redis 会用压缩列表来实现有序集合。具体点说就是，使用压缩列表来实现有序集合的前提，有这样两个：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"所有数据的大小都要小于 64 字节；\")]),t._v(\" \"),a(\"li\",[t._v(\"元素个数要小于 128 个。\")])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[a(\"strong\",[t._v(\"为什么 Redis 要用跳表来实现有序集合，而不是红黑树？\")])]),t._v(\" \"),a(\"p\",[t._v(\"Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。不过散列表我们后面才会讲到，所以我们现在暂且忽略这部分。如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"插入一个数据；\")]),t._v(\" \"),a(\"li\",[t._v(\"删除一个数据；\")]),t._v(\" \"),a(\"li\",[t._v(\"查找一个数据；\")]),t._v(\" \"),a(\"li\",[t._v(\"按照区间查找数据（比如查找值在[100, 356]之间的数据）；\")]),t._v(\" \"),a(\"li\",[t._v(\"迭代输出有序序列。\")])]),t._v(\" \"),a(\"p\",[t._v(\"其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"7.695ex\",height:\"2.262ex\",viewBox:\"0 -750 3401 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"6C\",d:\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1450, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"6F\",d:\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1935, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"67\",d:\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(2412, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"6E\",d:\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(3012, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。\")],1)]),t._v(\" \"),a(\"h2\",{attrs:{id:\"二、其他数据类型\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、其他数据类型\"}},[t._v(\"#\")]),t._v(\" 二、其他数据类型\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"bitmap\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bitmap\"}},[t._v(\"#\")]),t._v(\" Bitmap\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 的 Bitmap 数据结构是一种基于 String 类型的位数组，它允许用户将字符串当作位向量来使用，并对这些位执行位操作。Bitmap 并不是 Redis 中的一个独立数据类型，而是通过在 String 类型上定义的一组位操作命令来实现的。由于 Redis 的 String 类型是二进制安全的，最大长度可以达到 512 MB，因此可以表示最多 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"0\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"2.844ex\",height:\"1.887ex\",viewBox:\"0 -833.9 1257.1 833.9\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"msup\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mn\"}},[a(\"path\",{attrs:{\"data-c\":\"32\",d:\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"TeXAtom\",transform:\"translate(500, 363) scale(0.707)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mn\"}},[a(\"path\",{attrs:{\"data-c\":\"33\",d:\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"}}),a(\"path\",{attrs:{\"data-c\":\"32\",d:\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\",transform:\"translate(500, 0)\"}})])])])])])])]),t._v(\"​ 个不同的位。\")],1),t._v(\" \"),a(\"p\",[t._v(\"Bitmap 在 Redis 中的使用场景包括但不限于：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[a(\"strong\",[t._v(\"集合表示\")]),t._v(\"：当集合的成员对应于整数 0 到 N 时，Bitmap 可以高效地表示这种集合。\")]),t._v(\" \"),a(\"li\",[a(\"strong\",[t._v(\"对象权限\")]),t._v(\"：每个位代表一个特定的权限，类似于文件系统存储权限的方式。\")]),t._v(\" \"),a(\"li\",[a(\"strong\",[t._v(\"签到系统\")]),t._v(\"：记录用户在特定时间段内的签到状态。\")]),t._v(\" \"),a(\"li\",[a(\"strong\",[t._v(\"用户在线状态\")]),t._v(\"：跟踪大量用户的在线或离线状态。\")])]),t._v(\" \"),a(\"p\",[t._v(\"Bitmap 操作的基本命令包括：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[t._v(\"SETBIT key offset value\")]),t._v(\"：设置或清除 key 中 offset 位置的位值（只能是 0 或 1）。\")]),t._v(\" \"),a(\"li\",[a(\"code\",[t._v(\"GETBIT key offset\")]),t._v(\"：获取 key 中 offset 位置的位值，如果 key 不存在，则返回 0。\")])]),t._v(\" \"),a(\"p\",[t._v(\"Bitmap 还支持更复杂的位操作，如：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[t._v(\"BITOP operation destkey key [key ...]\")]),t._v(\"：对一个或多个 key 的 Bitmap 进行位操作（AND、OR、NOT、XOR）并将结果保存到 destkey。\")]),t._v(\" \"),a(\"li\",[a(\"code\",[t._v(\"BITCOUNT key [start] [end]\")]),t._v(\"：计算 key 中位数为 1 的数量，可选地在指定的 start 和 end 范围内进行计数。\")])]),t._v(\" \"),a(\"p\",[t._v(\"Bitmap 在存储空间方面非常高效，例如，表示一亿个用户的登录状态，每个用户用一个位来表示，总共只需要 12 MB 的内存空间。\")]),t._v(\" \"),a(\"p\",[t._v(\"在实际应用中，Bitmap 可以用于实现诸如亿级数据统计、用户行为跟踪等大规模数据集的高效管理。\")]),t._v(\" \"),a(\"p\",[t._v(\"总的来说，Redis 的 Bitmap 是一种非常节省空间且功能强大的数据结构，适用于需要对大量二进制数据进行操作的场景。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-sh extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-sh\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"127.0\")]),t._v(\".0.1:637\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a(\"span\",{pre:!0,attrs:{class:\"token file-descriptor important\"}},[t._v(\"9\")]),t._v(\">\")]),t._v(\" setbit s \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"127.0\")]),t._v(\".0.1:637\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a(\"span\",{pre:!0,attrs:{class:\"token file-descriptor important\"}},[t._v(\"9\")]),t._v(\">\")]),t._v(\" setbit s \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"127.0\")]),t._v(\".0.1:637\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a(\"span\",{pre:!0,attrs:{class:\"token file-descriptor important\"}},[t._v(\"9\")]),t._v(\">\")]),t._v(\" setbit s \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"4\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"127.0\")]),t._v(\".0.1:637\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a(\"span\",{pre:!0,attrs:{class:\"token file-descriptor important\"}},[t._v(\"9\")]),t._v(\">\")]),t._v(\" setbit s \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"9\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"127.0\")]),t._v(\".0.1:637\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a(\"span\",{pre:!0,attrs:{class:\"token file-descriptor important\"}},[t._v(\"9\")]),t._v(\">\")]),t._v(\" setbit s \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"10\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"127.0\")]),t._v(\".0.1:637\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a(\"span\",{pre:!0,attrs:{class:\"token file-descriptor important\"}},[t._v(\"9\")]),t._v(\">\")]),t._v(\" setbit s \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"13\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"127.0\")]),t._v(\".0.1:637\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a(\"span\",{pre:!0,attrs:{class:\"token file-descriptor important\"}},[t._v(\"9\")]),t._v(\">\")]),t._v(\" setbit s \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"15\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"127.0\")]),t._v(\".0.1:637\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a(\"span\",{pre:!0,attrs:{class:\"token file-descriptor important\"}},[t._v(\"9\")]),t._v(\">\")]),t._v(\" get s\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"he\"')]),t._v(\"\\n\")])])]),a(\"p\",[t._v(\"上面这个例子可以理解为「零存整取」，同样我们还也可以「零存零取」，「整存零取」。「零存」就是使用 setbit 对位值进行逐个设置，「整存」就是使用字符串一次性填充所有位数组，覆盖掉旧值。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"hyperloglog\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hyperloglog\"}},[t._v(\"#\")]),t._v(\" HyperLogLog\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 在 2.8.9 版本添加了 HyperLogLog 结构。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis HyperLogLog 是一种用于基数统计的数据结构，它提供了一个近似的、不精确的解决方案来估算集合中唯一元素的数量，即集合的基数。HyperLogLog 特别适用于需要处理大量数据并且对精度要求不是特别高的场景，因为它使用非常少的内存（通常每个 HyperLogLog 实例只需要 12.4KB 左右，无论集合中有多少元素）。\")]),t._v(\" \"),a(\"p\",[t._v(\"HyperLogLog 的主要特点包括：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[a(\"strong\",[t._v(\"近似统计\")]),t._v(\"：HyperLogLog 不保证精确计算基数，但它提供了一个非常接近真实值的近似值。\")]),t._v(\" \"),a(\"li\",[a(\"strong\",[t._v(\"内存效率\")]),t._v(\"：HyperLogLog 能够使用固定大小的内存来估算基数，这使得它在处理大规模数据集时非常有用。\")]),t._v(\" \"),a(\"li\",[a(\"strong\",[t._v(\"可合并性\")]),t._v(\"：多个 HyperLogLog 实例可以合并，以估算多个集合的并集基数。\")])]),t._v(\" \"),a(\"p\",[t._v(\"HyperLogLog 的主要命令包括：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[t._v(\"PFADD key element [element ...]\")]),t._v(\"：向 HyperLogLog 数据结构添加元素。如果 key 不存在，它将被创建。\")]),t._v(\" \"),a(\"li\",[a(\"code\",[t._v(\"PFCOUNT key\")]),t._v(\"：返回给定 HyperLogLog 的近似基数。\")]),t._v(\" \"),a(\"li\",[a(\"code\",[t._v(\"PFMERGE destkey sourcekey [sourcekey ...]\")]),t._v(\"：将多个 HyperLogLog 结构合并到一个单独的 HyperLogLog 结构中。\")])]),t._v(\" \"),a(\"p\",[t._v(\"HyperLogLog 的工作原理基于一个数学算法，它使用一个固定大小的位数组和一些哈希函数。当添加一个新元素时，它被哈希函数映射到一个位数组的索引，并根据哈希值的前几位来设置位数组中的位。基数估算是通过分析位数组中 0 的位置来完成的。\")]),t._v(\" \"),a(\"p\",[t._v(\"由于 HyperLogLog 提供的是近似值，它有一个标准误差率，通常在 0.81% 左右。这意味着如果实际基数是 1000，HyperLogLog 估算的基数可能在 992 到 1008 之间。\")]),t._v(\" \"),a(\"p\",[t._v(\"HyperLogLog 是处理大数据集基数统计的理想选择，尤其是当数据集太大而无法在内存中完全加载时。它在数据挖掘、日志分析、用户行为分析等领域有着广泛的应用。\")]),t._v(\" \"),a(\"p\",[t._v(\"场景：可以用来统计站点的UV...\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[a(\"a\",{attrs:{href:\"http://content.research.neustar.biz/blog/hll.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"HyperLogLog图解\"),a(\"OutboundLink\")],1)])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"三、redis常见数据类型和命令查阅\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、redis常见数据类型和命令查阅\"}},[t._v(\"#\")]),t._v(\" 三、Redis常见数据类型和命令查阅：\")]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"http://www.redis.cn/commands.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"Redis命令中心\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"http://redisdoc.com/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"Redis 命令参考\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"h4\",{attrs:{id:\"key-键-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#key-键-常用命令\"}},[t._v(\"#\")]),t._v(\" Key（键）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"DEL\")])]),t._v(\" \"),a(\"td\",[t._v(\"DEL key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"删除给定的一个或多个 key。 不存在的 key 会被忽略\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"DUMP\")]),t._v(\" \"),a(\"td\",[t._v(\"DUMP key\")]),t._v(\" \"),a(\"td\",[t._v(\"序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"EXISTS\")]),t._v(\" \"),a(\"td\",[t._v(\"EXISTS key\")]),t._v(\" \"),a(\"td\",[t._v(\"检查给定 key 是否存在\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"EXPIRE\")])]),t._v(\" \"),a(\"td\",[t._v(\"EXPIRE key seconds\")]),t._v(\" \"),a(\"td\",[t._v(\"为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"PERSIST\")])]),t._v(\" \"),a(\"td\",[t._v(\"PERSIST key\")]),t._v(\" \"),a(\"td\",[t._v(\"移除 key 的过期时间，key 将持久保持。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"EXPIREAT\")])]),t._v(\" \"),a(\"td\",[t._v(\"EXPIREAT key timestamp\")]),t._v(\" \"),a(\"td\",[t._v(\"EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)\")]),t._v(\" \"),a(\"td\",[t._v(\"EXPIREAT cache 1355292000     # 这个 key 将在 2012.12.12 过期\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"KEYS\")])]),t._v(\" \"),a(\"td\",[t._v(\"KEYS pattern\")]),t._v(\" \"),a(\"td\",[t._v(\"查找所有符合给定模式 pattern 的 key\")]),t._v(\" \"),a(\"td\",[t._v(\"KEYS *  # 匹配数据库内所有 key\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"MOVE\")]),t._v(\" \"),a(\"td\",[t._v(\"MOVE key db\")]),t._v(\" \"),a(\"td\",[t._v(\"将当前数据库的 key 移动到给定的数据库 db 当中如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。 因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)\")]),t._v(\" \"),a(\"td\",[t._v(\"MOVE song 1                          # 将 song 移动到数据库 1\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"TTL\")])]),t._v(\" \"),a(\"td\",[t._v(\"TTL key\")]),t._v(\" \"),a(\"td\",[t._v(\"以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)当 key 不存在时，返回 -2 。当 key 存在但没有设置剩余生存时间时，返回 -1 。否则，以秒为单位，返回 key 的剩余生存时间\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"PTTL\")]),t._v(\" \"),a(\"td\",[t._v(\"PTTL key\")]),t._v(\" \"),a(\"td\",[t._v(\"以毫秒为单位返回 key 的剩余的过期时间。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"TYPE\")])]),t._v(\" \"),a(\"td\",[t._v(\"TYPE key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回 key 所储存的值的类型\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"RENAME\")]),t._v(\" \"),a(\"td\",[t._v(\"RENAME key newkey\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 改名为 newkey 。当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。当 newkey 已经存在时， RENAME 命令将覆盖旧值\")]),t._v(\" \"),a(\"td\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"string-字符串-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#string-字符串-常用命令\"}},[t._v(\"#\")]),t._v(\" String （字符串）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SET\")])]),t._v(\" \"),a(\"td\",[t._v(\"SET key value [EX seconds] [PX milliseconds] [NX|XX]\")]),t._v(\" \"),a(\"td\",[t._v(\"将字符串值 value 关联到 key 。如果 key 已经持有其他值， SET 就覆写旧值，无视类型\")]),t._v(\" \"),a(\"td\",[t._v('SET key \"value\"')])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"MSET\")])]),t._v(\" \"),a(\"td\",[t._v(\"MSET key value [key value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"同时设置一个或多个 key-value 对。如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作\")]),t._v(\" \"),a(\"td\",[t._v('MSET date \"2012.3.30\" time \"11:00 a.m.\" weather \"sunny\"')])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SETNX\")])]),t._v(\" \"),a(\"td\",[t._v(\"SETNX key value\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作 SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"MSETNX\")]),t._v(\" \"),a(\"td\",[t._v(\"MSETNX key value [key value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SETRANGE\")]),t._v(\" \"),a(\"td\",[t._v(\"SETRANGE key offset value\")]),t._v(\" \"),a(\"td\",[t._v(\"用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。不存在的 key 当作空白字符串处理\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SETBIT\")]),t._v(\" \"),a(\"td\",[t._v(\"SETBIT key offset value\")]),t._v(\" \"),a(\"td\",[t._v(\"对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)\")]),t._v(\" \"),a(\"td\",[t._v(\"GETBIT bit 100   # bit 默认被初始化为 0\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SETEX\")]),t._v(\" \"),a(\"td\",[t._v(\"SETEX key seconds value\")]),t._v(\" \"),a(\"td\",[t._v(\"将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在， SETEX 命令将覆写旧值。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"PSETEX\")]),t._v(\" \"),a(\"td\",[t._v(\"PSETEX key milliseconds value\")]),t._v(\" \"),a(\"td\",[t._v(\"这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"STRLEN\")]),t._v(\" \"),a(\"td\",[t._v(\"STRLEN key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"GET\")])]),t._v(\" \"),a(\"td\",[t._v(\"GET key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"MGET\")])]),t._v(\" \"),a(\"td\",[t._v(\"MGET key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回所有(一个或多个)给定 key 的值。如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"GETRANGE\")]),t._v(\" \"),a(\"td\",[t._v(\"GETRANGE key start end\")]),t._v(\" \"),a(\"td\",[t._v(\"返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。\")]),t._v(\" \"),a(\"td\",[t._v(\"GETRANGE greeting 0 4\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"GETSET\")]),t._v(\" \"),a(\"td\",[t._v(\"GETSET key value\")]),t._v(\" \"),a(\"td\",[t._v(\"将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"GETBIT\")]),t._v(\" \"),a(\"td\",[t._v(\"GETBIT key offset\")]),t._v(\" \"),a(\"td\",[t._v(\"对 key 所储存的字符串值，获取指定偏移量上的位(bit)。当 offset 比字符串值的长度大，或者 key 不存在时，返回 0\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"APPEND\")])]),t._v(\" \"),a(\"td\",[t._v(\"APPEND key value\")]),t._v(\" \"),a(\"td\",[t._v(\"如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"DECR\")])]),t._v(\" \"),a(\"td\",[t._v(\"DECR key\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 中储存的数字值减一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作\")]),t._v(\" \"),a(\"td\",[t._v(\"redis> SET failure_times 10OK redis> DECR failure_times(integer) 9\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"DECRBY\")])]),t._v(\" \"),a(\"td\",[t._v(\"DECRBY key decrement\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 所储存的值减去减量 decrement\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"INCR\")])]),t._v(\" \"),a(\"td\",[t._v(\"INCR key\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"INCRBY\")])]),t._v(\" \"),a(\"td\",[t._v(\"INCRBY key increment\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 所储存的值加上增量 increment\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"INCRBYFLOAT\")]),t._v(\" \"),a(\"td\",[t._v(\"INCRBYFLOAT key increment\")]),t._v(\" \"),a(\"td\",[t._v(\"为 key 中所储存的值加上浮点数增量 increment\")]),t._v(\" \"),a(\"td\",[t._v(\"INCRBYFLOAT mykey 0.1\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"BITCOUNT\")]),t._v(\" \"),a(\"td\",[t._v(\"BITCOUNT key [start] [end]\")]),t._v(\" \"),a(\"td\",[t._v(\"计算给定字符串中，被设置为 1 的比特位的数量\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"BITOP\")]),t._v(\" \"),a(\"td\",[t._v(\"BITOP operation destkey key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。\")]),t._v(\" \"),a(\"td\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"list-列表-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#list-列表-常用命令\"}},[t._v(\"#\")]),t._v(\" List（列表）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LPUSH\")])]),t._v(\" \"),a(\"td\",[t._v(\"LPUSH key value [value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"将一个或多个值 value 插入到列表 key 的表头如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头\")]),t._v(\" \"),a(\"td\",[t._v(\"正着进反着出\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"LPUSHX\")]),t._v(\" \"),a(\"td\",[t._v(\"LPUSHX key value\")]),t._v(\" \"),a(\"td\",[t._v(\"将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。和 LPUSH 命令相反，当 key 不存在时， LPUSHX 命令什么也不做\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"RPUSH\")])]),t._v(\" \"),a(\"td\",[t._v(\"RPUSH key value [value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"将一个或多个值 value 插入到列表 key 的表尾(最右边)\")]),t._v(\" \"),a(\"td\",[t._v(\"怎么进怎么出\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"RPUSHX\")]),t._v(\" \"),a(\"td\",[t._v(\"RPUSHX key value\")]),t._v(\" \"),a(\"td\",[t._v(\"将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。和 RPUSH 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LPOP\")])]),t._v(\" \"),a(\"td\",[t._v(\"LPOP key\")]),t._v(\" \"),a(\"td\",[t._v(\"移除并返回列表 key 的头元素。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"BLPOP\")])]),t._v(\" \"),a(\"td\",[t._v(\"BLPOP key [key ...] timeout\")]),t._v(\" \"),a(\"td\",[t._v(\"移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"RPOP\")])]),t._v(\" \"),a(\"td\",[t._v(\"RPOP key\")]),t._v(\" \"),a(\"td\",[t._v(\"移除并返回列表 key 的尾元素。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"BRPOP\")])]),t._v(\" \"),a(\"td\",[t._v(\"BRPOP key [key ...] timeout\")]),t._v(\" \"),a(\"td\",[t._v(\"移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"BRPOPLPUSH\")]),t._v(\" \"),a(\"td\",[t._v(\"BRPOPLPUSH source destination timeout\")]),t._v(\" \"),a(\"td\",[t._v(\"从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"RPOPLPUSH\")]),t._v(\" \"),a(\"td\",[t._v(\"RPOPLPUSH source destinationb\")]),t._v(\" \"),a(\"td\",[t._v(\"命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素\")]),t._v(\" \"),a(\"td\",[t._v(\"RPOPLPUSH list01 list02\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LSET\")])]),t._v(\" \"),a(\"td\",[t._v(\"LSET key index value\")]),t._v(\" \"),a(\"td\",[t._v(\"将列表 key 下标为 index 的元素的值设置为 value\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LLEN\")])]),t._v(\" \"),a(\"td\",[t._v(\"LLEN key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回列表 key 的长度。如果 key 不存在，则 key 被解释为一个空列表，返回 0 .如果 key 不是列表类型，返回一个错误\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LINDEX\")])]),t._v(\" \"),a(\"td\",[t._v(\"LINDEX key index\")]),t._v(\" \"),a(\"td\",[t._v(\"返回列表 key 中，下标为 index 的元素。下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。相当于 Java 链表的\"),a(\"code\",[t._v(\"get(int index)\")]),t._v(\"方法，它需要对链表进行遍历，性能随着参数\"),a(\"code\",[t._v(\"index\")]),t._v(\"增大而变差。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LRANGE\")])]),t._v(\" \"),a(\"td\",[t._v(\"LRANGE key start stop\")]),t._v(\" \"),a(\"td\",[t._v(\"返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"LREM\")]),t._v(\" \"),a(\"td\",[t._v(\"LREM key count value\")]),t._v(\" \"),a(\"td\",[t._v(\"根据参数 count 的值，移除列表中与参数 value 相等的元素\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"LTRIM\")]),t._v(\" \"),a(\"td\",[t._v(\"LTRIM key start stop\")]),t._v(\" \"),a(\"td\",[t._v(\"对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"LINSERT\")]),t._v(\" \"),a(\"td\",[t._v(\"LINSERT key BEFORE|AFTER pivot value\")]),t._v(\" \"),a(\"td\",[t._v(\"将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。当 pivot 不存在于列表 key 时，不执行任何操作。当 key 不存在时， key 被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。\")]),t._v(\" \"),a(\"td\",[t._v(\"LINSERT list01 before c++ c#(在c++之前加上C#)\")])])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"hash-哈希表-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hash-哈希表-常用命令\"}},[t._v(\"#\")]),t._v(\" \"),a(\"strong\",[t._v(\"Hash\")]),t._v(\"（哈希表）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HSET\")])]),t._v(\" \"),a(\"td\",[t._v(\"HSET key field value\")]),t._v(\" \"),a(\"td\",[t._v(\"将哈希表 key 中的域 field 的值设为 value 。如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。如果域 field 已经存在于哈希表中，旧值将被覆盖。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HMSET\")])]),t._v(\" \"),a(\"td\",[t._v(\"HMSET key field value [field value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"同时将多个 field-value (域-值)对设置到哈希表 key 中。此命令会覆盖哈希表中已存在的域。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HSETNX\")])]),t._v(\" \"),a(\"td\",[t._v(\"HSETNX key field value\")]),t._v(\" \"),a(\"td\",[t._v(\"将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。若域 field 已经存在，该操作无效\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HGET\")])]),t._v(\" \"),a(\"td\",[t._v(\"HGET key field\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中给定域 field 的值\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HMGET\")])]),t._v(\" \"),a(\"td\",[t._v(\"HMGET key field [field ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中，一个或多个给定域的值。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HGETALL\")])]),t._v(\" \"),a(\"td\",[t._v(\"HGETALL key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HDEL\")]),t._v(\" \"),a(\"td\",[t._v(\"HDEL key field [field ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HEXISTS\")]),t._v(\" \"),a(\"td\",[t._v(\"HEXISTS key field\")]),t._v(\" \"),a(\"td\",[t._v(\"查看哈希表 key 中，给定域 field 是否存在\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HLEN\")]),t._v(\" \"),a(\"td\",[t._v(\"HLEN key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中域的数量\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HKEYS\")])]),t._v(\" \"),a(\"td\",[t._v(\"HKEYS key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中的所有域\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HVALS\")])]),t._v(\" \"),a(\"td\",[t._v(\"HVALS key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中所有域的值\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HSTRLEN\")]),t._v(\" \"),a(\"td\",[t._v(\"HSTRLEN key field\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中，与给定域 field 相关联的值的字符串长度（string length）。如果给定的键或者域不存在，那么命令返回 0\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HINCRBY\")]),t._v(\" \"),a(\"td\",[t._v(\"HINCRBY key field increment\")]),t._v(\" \"),a(\"td\",[t._v(\"为哈希表 key 中的域 field 的值加上增量 increment\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HINCRBYFLOAT\")]),t._v(\" \"),a(\"td\",[t._v(\"HINCRBYFLOAT key field increment\")]),t._v(\" \"),a(\"td\",[t._v(\"为哈希表 key 中的域 field 加上浮点数增量 increment\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HSCAN\")]),t._v(\" \"),a(\"td\",[t._v(\"HSCAN key cursor [MATCH pattern] [COUNT count]\")]),t._v(\" \"),a(\"td\",[t._v(\"迭代哈希表中的键值对。\")]),t._v(\" \"),a(\"td\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"set-集合-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#set-集合-常用命令\"}},[t._v(\"#\")]),t._v(\" Set（集合）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SADD\")])]),t._v(\" \"),a(\"td\",[t._v(\"SADD key member [member ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SCARD\")])]),t._v(\" \"),a(\"td\",[t._v(\"SCARD key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回集合 key 的基数(集合中元素的数量)。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SDIFF\")])]),t._v(\" \"),a(\"td\",[t._v(\"SDIFF key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 key 被视为空集。\")]),t._v(\" \"),a(\"td\",[t._v(\"差集\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SDIFFSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"SDIFFSTORE destination key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SINTER\")])]),t._v(\" \"),a(\"td\",[t._v(\"SINTER key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)\")]),t._v(\" \"),a(\"td\",[t._v(\"交集\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SINTERSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"SINTERSTORE destination key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SUNION\")])]),t._v(\" \"),a(\"td\",[t._v(\"SUNION key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集\")]),t._v(\" \"),a(\"td\",[t._v(\"并集\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SUNIONSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"SUNIONSTORE destination key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 已经存在，则将其覆盖。destination 可以是 key 本身\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SMEMBERS\")])]),t._v(\" \"),a(\"td\",[t._v(\"SMEMBERS key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回集合 key 中的所有成员。不存在的 key 被视为空集合\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SRANDMEMBER\")]),t._v(\" \"),a(\"td\",[t._v(\"SRANDMEMBER key [count]\")]),t._v(\" \"),a(\"td\",[t._v(\"如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SISMEMBER\")])]),t._v(\" \"),a(\"td\",[t._v(\"SISMEMBER key member\")]),t._v(\" \"),a(\"td\",[t._v(\"判断 member 元素是否集合 key 的成员\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SMOVE\")]),t._v(\" \"),a(\"td\",[t._v(\"SMOVE source destination member\")]),t._v(\" \"),a(\"td\",[t._v(\"将 member 元素从 source 集合移动到 destination 集合。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SPOP\")]),t._v(\" \"),a(\"td\",[t._v(\"SPOP key\")]),t._v(\" \"),a(\"td\",[t._v(\"移除并返回集合中的一个随机元素。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER 命令。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SREM\")])]),t._v(\" \"),a(\"td\",[t._v(\"SREM key member [member ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。当 key 不是集合类型，返回一个错误\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SSCAN\")]),t._v(\" \"),a(\"td\",[t._v(\"SSCAN key cursor [MATCH pattern] [COUNT count]\")]),t._v(\" \"),a(\"td\",[t._v(\"迭代集合中的元素\")]),t._v(\" \"),a(\"td\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"sortedset-有序集合-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sortedset-有序集合-常用命令\"}},[t._v(\"#\")]),t._v(\" SortedSet（有序集合）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZADD\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZADD key score1 member1 [score2 member2]\")]),t._v(\" \"),a(\"td\",[t._v(\"向有序集合添加一个或多个成员，或者更新已存在成员的分数\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZCARD\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZCARD key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 的基数。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZCOUNT\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZCOUNT key min max\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。关于参数 min 和 max 的详细使用方法，请参考 ZRANGEBYSCORE 命令。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZRANGE\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZRANGE key start stop [WITHSCORES]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递增(从小到大)来排序\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZREVRANGE\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZREVRANGE key start stop [WITHSCORES]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列。具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREVRANGEBYSCORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREVRANK\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREVRANK key member\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。排名以 0 为底，也就是说， score 值最大的成员排名为 0 。使用 ZRANK 命令可以获得成员按 score 值递增(从小到大)排列的排名。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZSCORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZSCORE key member\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中，成员 member 的 score 值。如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZRANGEBYSCORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZRANK\")]),t._v(\" \"),a(\"td\",[t._v(\"ZRANK key member\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZINCRBY\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZINCRBY key increment member\")]),t._v(\" \"),a(\"td\",[t._v(\"为有序集 key 的成员 member 的 score 值加上增量 increment\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREM\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREM key member [member ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREMRANGEBYRANK\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREMRANGEBYRANK key start stop\")]),t._v(\" \"),a(\"td\",[t._v(\"移除有序集 key 中，指定排名(rank)区间内的所有成员\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREMRANGEBYSCORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREMRANGEBYSCORE key min max\")]),t._v(\" \"),a(\"td\",[t._v(\"移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZUNIONSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\")]),t._v(\" \"),a(\"td\",[t._v(\"计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZINTERSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\")]),t._v(\" \"),a(\"td\",[t._v(\"计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZSCAN\")]),t._v(\" \"),a(\"td\",[t._v(\"ZSCAN key cursor [MATCH pattern] [COUNT count]\")]),t._v(\" \"),a(\"td\",[t._v(\"迭代有序集合中的元素（包括元素成员和元素分值）\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZRANGEBYLEX\")]),t._v(\" \"),a(\"td\",[t._v(\"ZRANGEBYLEX key min max [LIMIT offset count]\")]),t._v(\" \"),a(\"td\",[t._v(\"当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中，值介于 min 和 max 之间的成员。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZLEXCOUNT\")]),t._v(\" \"),a(\"td\",[t._v(\"ZLEXCOUNT key min max\")]),t._v(\" \"),a(\"td\",[t._v(\"对于一个所有成员的分值都相同的有序集合键 key 来说，这个命令会返回该集合中，成员介于 min 和 max 范围内的元素数量。这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX 命令的 min 参数和 max 参数的意义一样\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREMRANGEBYLEX\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREMRANGEBYLEX key min max\")]),t._v(\" \"),a(\"td\",[t._v(\"对于一个所有成员的分值都相同的有序集合键 key 来说，这个命令会移除该集合中，成员介于 min 和 max 范围内的所有元素。这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX 命令的 min 参数和 max 参数的意义一样\")]),t._v(\" \"),a(\"td\")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);","extractedComments":[]}