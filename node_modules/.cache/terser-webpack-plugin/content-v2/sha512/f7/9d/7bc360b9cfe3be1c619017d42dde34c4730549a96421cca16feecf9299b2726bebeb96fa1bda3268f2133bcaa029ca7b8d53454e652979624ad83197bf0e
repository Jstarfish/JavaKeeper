{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[206],{749:function(v,_,t){\"use strict\";t.r(_);var r=t(6),a=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[t(\"h3\",{attrs:{id:\"什么是-rpc\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是-rpc\"}},[v._v(\"#\")]),v._v(\" 什么是 RPC ？\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"RPC (Remote Procedure Call)即\"),t(\"strong\",[v._v(\"远程过程调用\")]),v._v(\"，是分布式系统常见的一种通信方法。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。\")]),v._v(\" \"),t(\"li\",[v._v(\"除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。\")]),v._v(\" \"),t(\"li\",[v._v(\"其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。\")])]),v._v(\" \"),t(\"p\",[t(\"strong\",[v._v(\"简单的说\")])]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。\")]),v._v(\" \"),t(\"li\",[v._v(\"RPC会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）。\")]),v._v(\" \"),t(\"li\",[v._v(\"客户端发起请求，服务器返回响应（类似于Http的工作方式）RPC在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。\")])]),v._v(\" \"),t(\"h3\",{attrs:{id:\"为什么我们要用rpc\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么我们要用rpc\"}},[v._v(\"#\")]),v._v(\" 为什么我们要用RPC?\")]),v._v(\" \"),t(\"p\",[v._v(\"RPC 的主要目标是让构建分布式应用更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用\")]),v._v(\" \"),t(\"h3\",{attrs:{id:\"rpc需要解决的三个问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rpc需要解决的三个问题\"}},[v._v(\"#\")]),v._v(\" RPC需要解决的三个问题\")]),v._v(\" \"),t(\"p\",[v._v(\"RPC要达到的目标：远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[v._v(\"Call ID映射\")]),v._v(\"。我们怎么告诉远程机器我们要\"),t(\"strong\",[v._v(\"调用哪个函数呢\")]),v._v(\"？在本地调用中，函数体是直接通过函数指针来指定的，我们调用具体函数，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，是无法调用函数指针的，因为两个进程的地址空间是完全不一样。所以，在RPC中，\"),t(\"strong\",[v._v(\"所有的函数都必须有自己的一个ID\")]),v._v(\"。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--\\x3e Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。\")]),v._v(\" \"),t(\"li\",[t(\"strong\",[v._v(\"序列化和反序列化\")]),v._v(\"。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，\"),t(\"strong\",[v._v(\"不能通过内存来传递参数\")]),v._v(\"。甚至有时候客户端和服务端使用的都\"),t(\"strong\",[v._v(\"不是同一种语言\")]),v._v(\"（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。\")]),v._v(\" \"),t(\"li\",[t(\"strong\",[v._v(\"网络传输\")]),v._v(\"。远程调用往往是基于网络的，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。\")])]),v._v(\" \"),t(\"h3\",{attrs:{id:\"实现高可用rpc框架需要考虑到的问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现高可用rpc框架需要考虑到的问题\"}},[v._v(\"#\")]),v._v(\" 实现高可用RPC框架需要考虑到的问题\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"既然系统采用分布式架构，那一个服务势必会有多个实例，要解决\"),t(\"strong\",[v._v(\"如何获取实例的问题\")]),v._v(\"。所以需要一个服务注册中心，比如在Dubbo中，就可以使用Zookeeper作为注册中心，在调用时，从Zookeeper获取服务的实例列表，再从中选择一个进行调用；\")]),v._v(\" \"),t(\"li\",[v._v(\"如何选择实例呢？就要考虑负载均衡，例如dubbo提供了4种负载均衡策略；\")]),v._v(\" \"),t(\"li\",[v._v(\"如果每次都去注册中心查询列表，效率很低，那么就要加缓存；\")]),v._v(\" \"),t(\"li\",[v._v(\"客户端总不能每次调用完都等着服务端返回数据，所以就要支持异步调用；\")]),v._v(\" \"),t(\"li\",[v._v(\"服务端的接口修改了，老的接口还有人在用，这就需要版本控制；\")]),v._v(\" \"),t(\"li\",[v._v(\"服务端总不能每次接到请求都马上启动一个线程去处理，于是就需要线程池；\")])]),v._v(\" \"),t(\"h3\",{attrs:{id:\"一次完整的-rpc-流程\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一次完整的-rpc-流程\"}},[v._v(\"#\")]),v._v(\" 一次完整的 RPC 流程\")]),v._v(\" \"),t(\"p\",[t(\"strong\",[v._v(\"因为 RPC 是远程调用，首先会涉及网络通信，\")]),v._v(\" 又因为 RPC 用于业务系统之间的数据交互，要保证数据传输的可靠性，所以它一般默认采用 TCP 来实现网络数据传输。\")]),v._v(\" \"),t(\"p\",[v._v(\"网络传输的数据必须是二进制数据，可是在 RPC 框架中，调用方请求的出入参数都是对象，对象不能直接在网络中传输，所以需要提前把对象转成可传输的二进制数据，转换算法还要可逆，\"),t(\"strong\",[v._v(\"这个过程就叫“序列化”和“反序列化”。\")])]),v._v(\" \"),t(\"p\",[v._v(\"另外，在网络传输中，RPC 不会把请求参数的所有二进制数据一起发送到服务提供方机器上，而是拆分成好几个数据包（或者把好几个数据包封装成一个数据包），所以服务提供方可能一次获取多个或半个数据包，这也就是网络传输中的粘包和半包问题。\"),t(\"strong\",[v._v(\"为了解决这个问题，需要提前约定传输数据的格式，即“RPC 协议”。\")]),v._v(\" 大多数的协议会分成数据头和消息体：\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；\")]),v._v(\" \"),t(\"li\",[v._v(\"消息体主要是请求的业务参数信息和扩展属性等。\")])]),v._v(\" \"),t(\"p\",[v._v(\"在确定好“ RPC 协议”后，一次完整的 RPC 调用会经过这样几个步骤：\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"调用方持续把请求参数对象序列化成二进制数据，经过 TCP 传输到服务提供方；\")]),v._v(\" \"),t(\"li\",[v._v(\"服务提供方从 TCP 通道里面接收到二进制数据；\")]),v._v(\" \"),t(\"li\",[v._v(\"根据 RPC 协议，服务提供方将二进制数据分割出不同的请求数据，经过反序列化将二进制数据逆向还原出请求对象，找到对应的实现类，完成真正的方法调用；\")]),v._v(\" \"),t(\"li\",[v._v(\"然后服务提供方再把执行结果序列化后，回写到对应的 TCP 通道里面；\")]),v._v(\" \"),t(\"li\",[v._v(\"调用方获取到应答的数据包后，再反序列化成应答对象。\")])]),v._v(\" \"),t(\"p\",[v._v(\"这样调用方就完成了一次 RPC 调用。\")]),v._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/Ciqc1GABbyeAWysgAAGQtM8Kx4Q574.png\",alt:\"Lark20210115-183000.png\"}})]),v._v(\" \"),t(\"h4\",{attrs:{id:\"如何提升网络通信性能\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何提升网络通信性能\"}},[v._v(\"#\")]),v._v(\" 如何提升网络通信性能\")]),v._v(\" \"),t(\"p\",[v._v(\"如何提升 RPC 的网络通信性能，这句话翻译一下就是：一个 RPC 框架如何选择高性能的网络编程 I/O 模型？这样一来，和 I/O 模型相关的知识点就是你需要掌握的了。\")]),v._v(\" \"),t(\"p\",[v._v(\"对于 RPC 网络通信问题，你首先要掌握网络编程中的五个 I/O 模型：\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[v._v(\"同步阻塞 I/O（BIO）\")])]),v._v(\" \"),t(\"li\",[t(\"p\",[v._v(\"同步非阻塞 I/O\")])]),v._v(\" \"),t(\"li\",[t(\"p\",[v._v(\"I/O 多路复用（NIO）\")])]),v._v(\" \"),t(\"li\",[t(\"p\",[v._v(\"信号驱动\")])]),v._v(\" \"),t(\"li\",[t(\"p\",[v._v(\"以及异步 I/O（AIO）\")])])]),v._v(\" \"),t(\"p\",[v._v(\"但在实际开发工作，最为常用的是 BIO 和 NIO（这两个 I/O 模型也是面试中面试官最常考察候选人的）。\")]),v._v(\" \"),t(\"p\",[v._v(\"NIO 比 BIO 提高了服务端工作线程的利用率，并增加了一个调度者，来实现 Socket 连接与 Socket 数据读写之间的分离。\")]),v._v(\" \"),t(\"p\",[v._v(\"在目前主流的 RPC 框架中，广泛使用的也是 I/O 多路复用模型，Linux 系统中的 select、poll、epoll等系统调用都是 I/O 多路复用的机制。\")]),v._v(\" \"),t(\"p\",[v._v(\"在面试中，对于高级研发工程师的考察，还会有两个技术扩展考核点。\")]),v._v(\" \"),t(\"p\",[v._v(\"Reactor 模型（即反应堆模式），以及 Reactor 的 3 种线程模型，分别是单线程 Reactor 线程模型、多线程 Reactor 线程模型，以及主从 Reactor 线程模型。\")]),v._v(\" \"),t(\"p\",[v._v(\"Java 中的高性能网络编程框架 Netty。\")]),v._v(\" \"),t(\"p\",[v._v(\"可以这么说，在高性能网络编程中，大多数都是基于 Reactor 模式，其中最为典型的是 Java 的 Netty 框架，而 Reactor 模式是基于 I/O 多路复用的，所以，对于 Reactor 和 Netty 的考察也是避免不了的。\")])])}),[],!1,null,null,null);_.default=a.exports}}]);","extractedComments":[]}