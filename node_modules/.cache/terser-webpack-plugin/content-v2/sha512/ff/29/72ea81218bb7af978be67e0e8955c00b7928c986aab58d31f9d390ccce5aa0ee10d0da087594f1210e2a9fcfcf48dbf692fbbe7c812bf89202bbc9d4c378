{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{728:function(_,v,t){\"use strict\";t.r(v);var s=t(6),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":_.$parent.slotKey}},[t(\"p\",[t(\"img\",{attrs:{src:\"https://img.starfish.ink/common/faq-banner.png\",alt:\"\"}})]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"写在之前：不建议背书式的去记忆面试题，对技术的提升帮助很小，对正经面试也没什么帮助，准备面试的过程还是要把各个知识点真懂了，然后再连成线。\")]),_._v(\" \"),t(\"p\",[_._v(\"个人建议把面试题看作是费曼学习法中的回顾、简化的环节，准备面试的时候，跟着题目先自己讲给自己听，看看自己会满意吗，不满意就继续学习这个点，如此反复，心仪的offer肯定会有的。\")]),_._v(\" \"),t(\"p\",[_._v(\"当然，大家有遇到过什么样『有趣』『有含量』的题目，欢迎提出来，一起学习~\")])]),_._v(\" \"),t(\"h2\",{attrs:{id:\"一、mysql-架构\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、mysql-架构\"}},[_._v(\"#\")]),_._v(\" 一、MySQL 架构\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，\"),t(\"strong\",[_._v(\"插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离\")]),_._v(\"。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/architecture.png\",alt:\"\"}})]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"连接层\")]),_._v(\"：最上层是一些客户端和连接服务。\"),t(\"strong\",[_._v(\"主要完成一些类似于连接处理、授权认证、及相关的安全方案\")]),_._v(\"。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"服务层\")]),_._v(\"：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"引擎层\")]),_._v(\"：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"存储层\")]),_._v(\"：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-的查询流程具体是怎么样的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-的查询流程具体是怎么样的\"}},[_._v(\"#\")]),_._v(\" MySQL 的查询流程具体是怎么样的？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"[!TIP]\")]),_._v(\" \"),t(\"p\",[_._v(\"一条 SQL 语句在 MySQL 中如何执行的？\")]),_._v(\" \"),t(\"p\",[_._v(\"画出 MySQL 架构图？ 「这种变态问题都能问的出来~」\")])]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"客户端请求\")]),_._v(\"：客户端通过连接器发送查询到 MySQL 服务器（验证用户身份，给予权限）\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"查询接收\")]),_._v(\"：连接器接收请求，管理连接\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"解析器\")]),_._v(\"：对 SQL 进行词法分析和语法分析，转换为解析树\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"优化器\")]),_._v(\"：优化器生成执行计划，选择最优索引和连接顺序\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"查询执行器\")]),_._v(\"：执行器执行查询，通过存储引擎接口获取数据\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"存储引擎\")]),_._v(\"：存储引擎检索数据，返回给执行器\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"返回结果\")]),_._v(\"：结果通过连接器返回给客户端\")])]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/MySQL-select-flow.png\",alt:\"\"}})]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"二、存储引擎\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、存储引擎\"}},[_._v(\"#\")]),_._v(\" 二、存储引擎\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"存储引擎是 MySQL 的组件，用于处理不同表类型的 SQL 操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。\")]),_._v(\" \"),t(\"p\",[_._v(\"使用哪一种引擎可以灵活选择，\"),t(\"strong\",[t(\"mark\",[_._v(\"一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求\")])]),_._v(\"，使用合适的存储引擎，将会提高整个数据库的性能 。\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 服务器使用\"),t(\"strong\",[_._v(\"可插拔\")]),_._v(\"的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"查看存储引擎\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"-- 查看支持的存储引擎\\nSHOW ENGINES\\n\\n-- 查看默认存储引擎\\nSHOW VARIABLES LIKE 'storage_engine'\\n\\n--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！\\nshow create table tablename\\n\\n--准确查看某个数据库中的某一表所使用的存储引擎\\nshow table status like 'tablename'\\nshow table status from database where name=\\\"tablename\\\"\\n\")])])]),t(\"p\",[t(\"strong\",[_._v(\"设置存储引擎\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"-- 建表时指定存储引擎。默认的就是INNODB，不需要设置\\nCREATE TABLE t1 (i INT) ENGINE = INNODB;\\nCREATE TABLE t2 (i INT) ENGINE = CSV;\\nCREATE TABLE t3 (i INT) ENGINE = MEMORY;\\n\\n-- 修改存储引擎\\nALTER TABLE t ENGINE = InnoDB;\\n\\n-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎\\nSET default_storage_engine=NDBCLUSTER;\\n\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说说-mysql-都有哪些存储引擎-都有哪些区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说说-mysql-都有哪些存储引擎-都有哪些区别\"}},[_._v(\"#\")]),_._v(\" 说说 MySQL 都有哪些存储引擎？都有哪些区别？\")]),_._v(\" \"),t(\"p\",[_._v(\"常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 现在是 MySQL5.5 版本后默认的存储引擎，支持\"),t(\"strong\",[_._v(\"事务、行级锁定和外键\")]),_._v(\"。我们一般和 MyISM 进行对比即可\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"事务支持\")]),_._v(\"：InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"外键约束\")]),_._v(\"：InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"存储结构\")]),_._v(\"：InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"表空间管理\")]),_._v(\"：InnoDB 使用表空间（tablespace）来管理数据存储，支持自动扩展，支持表和索引分开存储，提高存储效率。MyISAM 每个表有三个文件：\"),t(\"code\",[_._v(\".frm\")]),_._v(\"（表定义文件）、\"),t(\"code\",[_._v(\".MYD\")]),_._v(\"（数据文件）和 \"),t(\"code\",[_._v(\".MYI\")]),_._v(\"（索引文件）\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"锁定机制\")]),_._v(\"：InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"崩溃恢复\")]),_._v(\"：InnoDB 具有崩溃恢复的能力，使用重做日志（redo log）和回滚日志（undo log）来恢复数据；MyISAM 没有崩溃恢复机制，可能需要手动恢复\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"性能\")]),_._v(\"： InnoDB 在写密集型操作中表现更好，特别是在需要事务和外键约束的场景下。MyISAM 在读密集型操作中表现更好，尤其是在没有写操作的情况下。\")])]),_._v(\" \"),t(\"blockquote\",[t(\"h4\",{attrs:{id:\"文件存储结构对比\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#文件存储结构对比\"}},[_._v(\"#\")]),_._v(\" 文件存储结构对比\")]),_._v(\" \"),t(\"p\",[_._v(\"在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 \"),t(\"code\",[_._v(\".frm\")]),_._v(\" 文件，\"),t(\"code\",[_._v(\".frm\")]),_._v(\" 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有\"),t(\"code\",[_._v(\".frm\")]),_._v(\"文件，命名方式为 数据表名.frm，如user.frm。\")]),_._v(\" \"),t(\"p\",[_._v(\"查看 MySQL 数据保存在哪里：\"),t(\"code\",[_._v(\"show variables like 'data%'\")])]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM 物理文件结构为：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"code\",[_._v(\".frm\")]),_._v(\"文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\".MYD\")]),_._v(\" (\"),t(\"code\",[_._v(\"MYData\")]),_._v(\") 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\".MYI\")]),_._v(\" (\"),t(\"code\",[_._v(\"MYIndex\")]),_._v(\")文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息\")])]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 物理文件结构为：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"code\",[_._v(\".frm\")]),_._v(\" 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\".ibd\")]),_._v(\" 文件或 \"),t(\"code\",[_._v(\".ibdata\")]),_._v(\" 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用\"),t(\"strong\",[_._v(\"共享表空间\")]),_._v(\"存放存储数据，还是用\"),t(\"strong\",[_._v(\"独享表空间\")]),_._v(\"存放存储数据。\")]),_._v(\" \"),t(\"p\",[_._v(\"独享表空间存储方式使用\"),t(\"code\",[_._v(\".ibd\")]),_._v(\"文件，并且每个表一个\"),t(\"code\",[_._v(\".ibd\")]),_._v(\"文件\\n共享表空间存储方式使用\"),t(\"code\",[_._v(\".ibdata\")]),_._v(\"文件，所有表共同使用一个\"),t(\"code\",[_._v(\".ibdata\")]),_._v(\"文件（或多个，可自己配置）\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"哪个存储引擎执行-select-count-更快-为什么\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#哪个存储引擎执行-select-count-更快-为什么\"}},[_._v(\"#\")]),_._v(\" 哪个存储引擎执行 select count(*) 更快，为什么?\")]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"MyISAM 存储每个表的行数在表的元数据中，因此执行 \"),t(\"code\",[_._v(\"SELECT COUNT(*)\")]),_._v(\" 时，它可以直接读取这个值，而不需要扫描整个表\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"nnoDB 不存储行数信息在表的元数据中。每次执行 \"),t(\"code\",[_._v(\"SELECT COUNT(*)\")]),_._v(\" 查询时，InnoDB 都需要扫描整个表来计算行数。这对于大表来说可能会非常慢。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 不将表的行数存储在元数据中，主要原因是其设计目标与 MyISAM 不同。InnoDB 设计为支持高并发的事务处理和数据一致性，因此其存储和计数机制需要权衡性能和一致性。以下是一些具体原因：\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"1. 行级锁定和并发控制\")])]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 支持行级锁定，这意味着在高并发环境中，不同事务可以同时对不同的行进行操作，而不会相互阻塞。为了确保这种并发控制和数据一致性，InnoDB 需要动态计算行数，以反映当前事务视图下的数据状态。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"事务隔离级别\")]),_._v(\"：InnoDB 支持多种事务隔离级别（如 READ COMMITTED、REPEATABLE READ、SERIALIZABLE），这些隔离级别决定了事务如何看到数据。预先存储的行数无法满足这些隔离级别的要求，因为行数在不同事务下可能有所不同。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"锁机制\")]),_._v(\"：由于行级锁定，InnoDB 在处理大量并发事务时，需要动态调整行数信息，而不是依赖预先存储的静态行数。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"2. 一致性和持久性\")])]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 设计为支持 ACID 属性（原子性、一致性、隔离性、持久性），这要求所有的数据操作都必须保证一致性和可靠性。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"崩溃恢复\")]),_._v(\"：InnoDB 使用重做日志（redo log）和回滚日志（undo log）来实现崩溃恢复。如果行数保存在元数据中，崩溃恢复后行数可能与实际数据不一致，从而破坏数据的一致性。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"并发更新\")]),_._v(\"：在高并发环境中，多个事务可能同时修改表中的数据。如果行数保存在元数据中，每次更新都需要锁定并更新元数据，这将导致严重的性能瓶颈。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"3. 性能优化\")])]),_._v(\" \"),t(\"p\",[_._v(\"动态计算行数虽然在某些查询中（如 \"),t(\"code\",[_._v(\"SELECT COUNT(*)\")]),_._v(\"）较慢，但它避免了在高并发写操作下频繁更新元数据的性能开销。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"写操作性能\")]),_._v(\"：为了保证高效的写操作，InnoDB 设计避免了每次写操作都需要更新元数据的设计，这样可以更好地处理高并发写入。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"实际应用\")]),_._v(\"：在实际应用中，行数的精确统计并不是经常需要的操作。大多数情况下，应用程序可以通过索引和其他机制来实现高效的数据访问，而不依赖于 \"),t(\"code\",[_._v(\"SELECT COUNT(*)\")]),_._v(\" 的性能。\")])]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"三、数据类型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、数据类型\"}},[_._v(\"#\")]),_._v(\" 三、数据类型\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"主要包括以下五大类：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT\")]),_._v(\" \"),t(\"li\",[_._v(\"浮点数类型：FLOAT、DOUBLE、DECIMAL\")]),_._v(\" \"),t(\"li\",[_._v(\"字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB\")]),_._v(\" \"),t(\"li\",[_._v(\"日期类型：Date、DateTime、TimeStamp、Time、Year\")]),_._v(\" \"),t(\"li\",[_._v(\"其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"char-和-varchar-的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#char-和-varchar-的区别\"}},[_._v(\"#\")]),_._v(\" CHAR 和 VARCHAR 的区别？\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"CHAR\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"VARCHAR\")]),_._v(\" 都是用于存储字符串的字段类型，但它们在存储方式、性能和使用场景上存在一些关键区别\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"存储方式\")]),_._v(\"：char 是固定长度，varchar长度可变：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"存储时，char 不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而 varchar 会根据实际存储的数据分配最终的存储空间，加上 1 或 2 个额外字节用于存储字符串的长度信息\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"性能不同\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"code\",[_._v(\"CHAR\")]),_._v(\" 因为其固定长度的特性，在某些情况下可能会提供更好的性能，尤其是当处理大量具有相同长度的数据时。\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\"VARCHAR\")]),_._v(\" 由于需要存储长度信息，并且可能需要额外的空间来存储不同长度的字符串，因此在性能上可能略逊于 \"),t(\"code\",[_._v(\"CHAR\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"使用场景：char 适用于固定长度字符串：如存储状态码、国家代码、MD5 哈希值等。varchar 适用于可变长度字符串：如用户名、电子邮件地址、描述等。\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-里记录货币用什么字段类型比较好\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-里记录货币用什么字段类型比较好\"}},[_._v(\"#\")]),_._v(\" MySQL 里记录货币用什么字段类型比较好？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"阿里规范：【强制】任何货币金额，均以最小货币单位且整型类型来进行存储。\")])]),_._v(\" \"),t(\"p\",[_._v(\"在 MySQL 中记录货币数据时，通常推荐使用 \"),t(\"code\",[_._v(\"DECIMAL\")]),_._v(\" 类型。\"),t(\"code\",[_._v(\"DECIMAL\")]),_._v(\" 类型提供高精度的存储和计算，非常适合用于存储货币值。以下是使用 \"),t(\"code\",[_._v(\"DECIMAL\")]),_._v(\" 类型的原因以及其他可能选择的字段类型和其适用场景：\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"使用 \"),t(\"code\",[_._v(\"DECIMAL\")]),_._v(\" 类型的原因\")])]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"高精度\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[t(\"code\",[_._v(\"DECIMAL\")]),_._v(\" 类型可以精确存储货币值，没有浮点运算误差。例如，定义为 \"),t(\"code\",[_._v(\"DECIMAL(10, 2)\")]),_._v(\" 表示最多 10 位数字，其中 2 位小数，适合存储最多到亿位的金额，精确到小数点后两位。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"存储效率\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"由于货币值通常需要精确到小数点后两位，\"),t(\"code\",[_._v(\"DECIMAL\")]),_._v(\" 能够确保存储的每一个值都是精确的，避免了浮点数可能带来的舍入误差。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"计算正确性\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"在涉及到财务计算时，使用浮点数类型（如 \"),t(\"code\",[_._v(\"FLOAT\")]),_._v(\" 或 \"),t(\"code\",[_._v(\"DOUBLE\")]),_._v(\"）可能会因为舍入误差导致计算不准确。\"),t(\"code\",[_._v(\"DECIMAL\")]),_._v(\" 类型避免了这些问题，确保计算结果的准确性。\")])])])]),_._v(\" \"),t(\"p\",[_._v(\"当然还\"),t(\"strong\",[_._v(\"有些业务\")]),_._v(\"，用 \"),t(\"code\",[_._v(\"INT\")]),_._v(\" 或者 \"),t(\"code\",[_._v(\"BIGINT\")]),_._v(\" 类型存储货币的最小单位也可以（如美分、分），适合对性能有更高要求的场景（整数运算比浮点运算更快），但需要处理转换逻辑。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"这个问题其实很不重要，因为大部分公司不让让使用这两种类型。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"禁止使用TEXT、BLOB类型\")]),_._v(\"：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"blob和text有什么区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#blob和text有什么区别\"}},[_._v(\"#\")]),_._v(\" BLOB和TEXT有什么区别？\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"BLOB\")]),_._v(\"（Binary Large Object）和 \"),t(\"code\",[_._v(\"TEXT\")]),_._v(\" 是 MySQL 中用于存储大型二进制数据和大型文本数据的两种不同的数据类型。它们之间的主要区别包括：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"存储内容\")]),_._v(\"：\"),t(\"code\",[_._v(\"BLOB\")]),_._v(\" 用于存储二进制数据，如图片、音频、视频等。\"),t(\"code\",[_._v(\"TEXT\")]),_._v(\" 用于存储大型文本数据，如文章、评论等。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"最大长度\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[t(\"code\",[_._v(\"BLOB\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"TEXT\")]),_._v(\" 类型的最大长度可以达到 65,535 字节，即 64KB（在 MySQL 5.0.3 之前的版本中，最大长度为 255 字节）。\")]),_._v(\" \"),t(\"li\",[_._v(\"从 MySQL 5.0.3 版本开始，\"),t(\"code\",[_._v(\"BLOB\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"TEXT\")]),_._v(\" 类型的列可以存储更大的数据，最大可达到 4GB（使用 \"),t(\"code\",[_._v(\"LONGBLOB\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"LONGTEXT\")]),_._v(\"）。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"字符编码\")]),_._v(\"：\"),t(\"code\",[_._v(\"BLOB\")]),_._v(\" 存储的是二进制数据，与字符编码无关。\"),t(\"code\",[_._v(\"TEXT\")]),_._v(\" 存储的是字符数据，受字符编码的影响，如 \"),t(\"code\",[_._v(\"utf8\")]),_._v(\"、\"),t(\"code\",[_._v(\"latin1\")]),_._v(\" 等。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"存储效率\")]),_._v(\"：\"),t(\"code\",[_._v(\"BLOB\")]),_._v(\" 由于存储的是二进制数据，不涉及字符编码转换，通常存储效率更高。\"),t(\"code\",[_._v(\"TEXT\")]),_._v(\" 类型在存储时会进行字符编码转换，可能会占用更多的存储空间。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"排序和比较\")]),_._v(\"：\"),t(\"code\",[_._v(\"BLOB\")]),_._v(\" 类型的列不能进行排序和比较，因为它们是二进制数据。\"),t(\"code\",[_._v(\"TEXT\")]),_._v(\" 类型的列可以进行排序和比较，因为它们是字符数据。\")])]),_._v(\" \"),t(\"p\",[_._v(\"在选择 \"),t(\"code\",[_._v(\"BLOB\")]),_._v(\" 还是 \"),t(\"code\",[_._v(\"TEXT\")]),_._v(\" 时，需要根据数据的特性和应用场景来决定。如果需要存储非文本的二进制数据，应选择 \"),t(\"code\",[_._v(\"BLOB\")]),_._v(\"；如果需要存储大量的文本数据，则应选择 \"),t(\"code\",[_._v(\"TEXT\")]),_._v(\"。\")]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"四、索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#四、索引\"}},[_._v(\"#\")]),_._v(\" 四、索引\")]),_._v(\" \"),t(\"blockquote\",[t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"MYSQL官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构，所以说\"),t(\"strong\",[_._v(\"索引的本质是：数据结构\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，\"),t(\"font\",{attrs:{color:\"#FF0000\"}},[t(\"strong\",[_._v(\"数据库还维护者一个满足特定查找算法的数据结构\")])]),_._v(\"，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例。\")],1),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/search-index-demo.png\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址\")]),_._v(\" \"),t(\"p\",[_._v(\"为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"索引本身也很大，不可能全部存储在内存中，\"),t(\"strong\",[_._v(\"一般以索引文件的形式存储在磁盘上\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"平常说的索引，没有特别指明的话，就是 B+ 树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用 B+ 树索引，统称索引。此外还有哈希索引等。\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说说你对-mysql-索引的理解\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说说你对-mysql-索引的理解\"}},[_._v(\"#\")]),_._v(\" 说说你对 MySQL 索引的理解？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"这种就属于比较宽泛的问题，可以有结构条例的多说一些。差不多的问法：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"索引是越多越好吗？为什么？\")]),_._v(\" \"),t(\"li\",[_._v(\"索引有哪些优缺点？\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"[!TIP]\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"话术点\")]),_._v(\"：B+ 树、优缺点、索引分类、最左匹配原则\")])]),_._v(\" \"),t(\"p\",[_._v(\"索引是数据库优化的重要工具，从数据结构上来说，在 MySQL 里面索引主要是 B+ 树索引。它的查询性能更好，适合范围查询，也适合放在内存里。 MySQL 的索引又可以从不同的角度进一步划分。比如说根据叶子节点是否包含 数据分成聚簇索引和非聚簇索引，还有包含某个查询的所有列的覆盖索引等 等。数据库使用索引遵循最左匹配原则。但是最终数据库会不会用索引，也是 一个比较难说的事情，跟查询有关，也跟数据量有关。在实践中，是否使用索 引以及使用什么索引，都要以 EXPLAIN 为准。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[t(\"strong\",[_._v(\"优势\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"提高数据检索效率，降低数据库IO成本\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"降低数据排序的成本，降低CPU的消耗\")])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"劣势\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存\")]),_._v(\" \"),t(\"li\",[_._v(\"虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。\\n因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，\\n都会调整因为更新所带来的键值变化后的索引信息\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"h5\",{attrs:{id:\"mysql索引分类\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql索引分类\"}},[_._v(\"#\")]),_._v(\" MySQL索引分类\")]),_._v(\" \"),t(\"h6\",{attrs:{id:\"数据结构角度\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据结构角度\"}},[_._v(\"#\")]),_._v(\" 数据结构角度\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"B+树索引\")]),_._v(\" \"),t(\"li\",[_._v(\"Hash索引\")]),_._v(\" \"),t(\"li\",[_._v(\"R-Tree索引\")])]),_._v(\" \"),t(\"h6\",{attrs:{id:\"从物理存储角度\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#从物理存储角度\"}},[_._v(\"#\")]),_._v(\" 从物理存储角度\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"聚集索引（clustered index）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"非聚集索引（non-clustered index），也叫辅助索引（secondary index）\")]),_._v(\" \"),t(\"p\",[_._v(\"聚集索引和非聚集索引都是B+树结构\")])])]),_._v(\" \"),t(\"h6\",{attrs:{id:\"从逻辑角度\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#从逻辑角度\"}},[_._v(\"#\")]),_._v(\" 从逻辑角度\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"主键索引：主键索引是一种特殊的唯一索引，不允许有空值\")]),_._v(\" \"),t(\"li\",[_._v(\"普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引\")]),_._v(\" \"),t(\"li\",[_._v(\"多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合\")]),_._v(\" \"),t(\"li\",[_._v(\"唯一索引或者非唯一索引\")]),_._v(\" \"),t(\"li\",[_._v(\"空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。\\nMYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说一下-mysql-innodb-的索引原理是什么\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说一下-mysql-innodb-的索引原理是什么\"}},[_._v(\"#\")]),_._v(\" 说一下 MySQL InnoDB 的索引原理是什么?\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"这就涉及到了好多知识点，我们可以列举几项关键点，说说**\"),t(\"mark\",[_._v(\"索引结构\")]),t(\"strong\",[_._v(\"、\")]),t(\"mark\",[_._v(\"聚簇索引\")]),_._v(\"**\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面\")]),_._v(\"。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"B+Tree索引\")])]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 的主要索引结构是 B+ 树索引。B+ 树是一种平衡树，每个节点可以有多个子节点。与 B 树不同，B+ 树的所有数据都存储在叶子节点中，叶子节点之间通过指针相连，这使得范围查询和排序操作非常高效。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"聚簇索引 和 非聚簇索引\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"InnoDB 中的主键索引就是聚簇索引。聚簇索引将数据行与索引紧密结合在一起，数据行存储在叶子节点中，因此通过主键查找数据非常高效\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"当你创建一个表并指定主键时，InnoDB 会自动使用主键创建一个聚簇索引。\")]),_._v(\" \"),t(\"li\",[_._v(\"如果没有显式定义主键，InnoDB 会选择一个唯一的非空索引代替。\")]),_._v(\" \"),t(\"li\",[_._v(\"如果没有唯一非空索引，InnoDB 会自动生成一个隐藏的行 ID 作为聚簇索引\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"辅助索引（也称为二级索引或非聚簇索引）是用于加速对非主键列的查询。辅助索引的叶子节点存储索引列的值以及对应的主键值。\")]),_._v(\" \"),t(\"p\",[_._v(\"使用辅助索引进行查询时，InnoDB 首先通过辅助索引找到主键值，然后通过主键值在聚簇索引中查找实际数据。这种回表（回查）过程可能增加查询时间，但仍然比全表扫描快得多。\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"为什么要用-b-树\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么要用-b-树\"}},[_._v(\"#\")]),_._v(\" 为什么要用 B+树？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"B+ 树 索引相比于其他索引类型的优势？\")]),_._v(\" \"),t(\"p\",[_._v(\"为什么MySQL 索引中用 B+tree，不用 B-tree 或者其他树，为什么不用 Hash 索引\")]),_._v(\" \"),t(\"p\",[_._v(\"B-Tree 对比 B+Tree索引\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"B+Tree 相对于 B 树 索引结构的优势：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"B+ 树空间利用率更高：B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"B 树只适合随机检索，B+Tree 叶子节点采用的是双链表连接，同时支持\"),t(\"strong\",[_._v(\"随机检索和顺序检索\")])])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"B+Tree 相对于二叉树索引结构的优势：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"与B+ 树相比，平衡二叉树、红黑树在同等数据量下，高度更高，性能更差，而且它们会频 繁执行再平衡过程，来保证树形结构平衡\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"对于有 N 个叶子节点的 B+Tree，其搜索复杂度为\"),t(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[t(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"9.523ex\",height:\"2.262ex\",viewBox:\"0 -750 4209 1000\"}},[t(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[t(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[t(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[t(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1152, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"6C\",d:\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1450, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"6F\",d:\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1935, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"67\",d:\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(2412, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"64\",d:\"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(2932, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"4E\",d:\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(3820, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),_._v(\"，其中 d 表示节点允许的最大子节点个数为 d 个。在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据（这里的查询参考上面 B+Tree 的聚簇索引的查询过程）。\")],1),_._v(\" \"),t(\"p\",[_._v(\"而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 \"),t(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[t(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"8.346ex\",height:\"2.262ex\",viewBox:\"0 -750 3689 1000\"}},[t(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[t(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[t(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[t(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1152, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"6C\",d:\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1450, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"6F\",d:\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1935, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"67\",d:\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(2412, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"4E\",d:\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(3300, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),_._v(\"，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。\")],1)])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"B+Tree 相对于 Hash 表存储结构的优势\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"我们知道范围查询是 MySQL 中常见的场景，但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"B+Tree 相对于 跳表存储结构的优势\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"与B+ 树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期 的查询时间，并且跳表需要更多的内存。\")])])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。\")]),_._v(\" \"),t(\"p\",[_._v(\"B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。\")]),_._v(\" \"),t(\"p\",[_._v(\"系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB。\")]),_._v(\" \"),t(\"p\",[_._v(\"而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。\")]),_._v(\" \"),t(\"p\",[_._v(\"B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构。从 B-Tree 结构图中可以看到每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。在 B+Tree 中，\"),t(\"strong\",[_._v(\"所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上\")]),_._v(\"，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/MySQL-B%2BTree-store.png\",alt:\"\"}})]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"节点存储内容\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"B-Tree\")]),_._v(\"：每个节点可以存储多个键和多个子节点的指针。键被存储在节点内部，并且可以被多次访问。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"B+Tree\")]),_._v(\"：非叶子节点仅存储键作为索引，不存储实际的数据记录，所以\"),t(\"strong\",[_._v(\"适合放入内存中\")]),_._v(\"。所有的数据记录都存储在叶子节点中，并且叶子节点被额外的指针连接在一起，形成一个有序链表。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"查询性能\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"B-Tree\")]),_._v(\"：叶子节点可能包含数据记录，也可能不包含，取决于具体的实现。在查找特定值时，可以在找到对应节点时立即返回结果。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"B+Tree\")]),_._v(\"：所有的数据记录都存储在叶子节点中。在查找特定值时，需要访问叶子节点，但因为\"),t(\"strong\",[_._v(\"叶子节点形成了有序链表\")]),_._v(\"，所以\"),t(\"strong\",[_._v(\"范围查询和顺序访问的性能更好\")]),_._v(\"。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"空间效率\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"B-Tree\")]),_._v(\"：因为每个节点存储更多的键和指针，所以每个节点可以有更少的子节点，树的高度可能会更小。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"B+Tree\")]),_._v(\"：每个内部节点可以有更多子节点，因为它们只存储键的索引，这使得树更宽、更浅，减少了树的高度，\"),t(\"strong\",[_._v(\"提高了 I/O 效率\")]),_._v(\"。\")])])])])]),_._v(\" \"),t(\"blockquote\",[t(\"h4\",{attrs:{id:\"b-tree-性质\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#b-tree-性质\"}},[_._v(\"#\")]),_._v(\" B+Tree 性质\")]),_._v(\" \"),t(\"p\",[_._v(\"在数据库中，B+ 树索引结构的高度 \"),t(\"em\",[_._v(\"h\")]),_._v(\" 直接影响到进行一次索引查找所需的 I/O 次数。这是因为每次 I/O 操作通常只能读取一个磁盘块（或页）的数据。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"B+ 树高度 h\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"B+树的高度是由树中节点的最大数量决定的，可以通过以下公式近似计算： \"),t(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[t(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"12.927ex\",height:\"2.262ex\",viewBox:\"0 -750 5713.6 1000\"}},[t(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[t(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[t(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[t(\"path\",{attrs:{\"data-c\":\"68\",d:\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(853.8, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"2248\",d:\"M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1909.6, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"6C\",d:\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(2207.6, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"6F\",d:\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(2692.6, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"67\",d:\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(3169.6, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"6D\",d:\"M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(4047.6, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(4436.6, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"4E\",d:\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"}})]),t(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(5324.6, 0)\"}},[t(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])])],1)]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"其中 \"),t(\"em\",[_._v(\"N\")]),_._v(\" 是树中存储的总记录数，\"),t(\"em\",[_._v(\"m\")]),_._v(\" 是每个磁盘块（页）可以存储的数据项数量。\")])])])])]),_._v(\" \"),t(\"p\",[_._v(\"当数据量 N 一定的情况下，m 越大，h 越小；而 m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的（默认 16 KB），如果数据项占的空间越小，数据项的数量越多，树的高度越低。\")]),_._v(\" \"),t(\"p\",[_._v(\"这就是为什么每个数据项，即索引字段要尽量的小，比如 int 占 4 字节，要比 bigint 8 字节少一半。这也是为什么 B+ 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"[!NOTE]\")]),_._v(\" \"),t(\"p\",[_._v(\"在实际应用中，B+树的高度和 I/O 次数会受到许多因素的影响，包括页的大小、数据的分布、索引的选择性等\")])]),_._v(\" \"),t(\"p\",[_._v(\"当 B+ 树的数据项是复合的数据结构，比如(name,age,sex) 的时候，B+ 树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F) 这样的数据来检索的时候，B+树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当 (20,F) 这样的没有 name 的数据来的时候，B+ 树就不知道下一步该查哪个节点，因为建立搜索树的时候name 就是第一个\"),t(\"strong\",[_._v(\"比较因子\")]),_._v(\"，必须要先根据 name 来搜索才能知道下一步去哪里查询。比如当 (张三,F) 这样的数据来检索时，B+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，就是我们说的\"),t(\"strong\",[_._v(\"索引的最左匹配特性\")]),_._v(\"。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"聚集索引与非聚集索引的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#聚集索引与非聚集索引的区别\"}},[_._v(\"#\")]),_._v(\" 聚集索引与非聚集索引的区别？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址?\")])]),_._v(\" \"),t(\"p\",[_._v(\"聚集索引（Clustered Index）和非聚集索引（Non-clustered Index）是数据库管理系统中常见的两种索引类型，是一种\"),t(\"strong\",[_._v(\"数据存储方式\")]),_._v(\"的区分，特别是在 MySQL 中。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"聚簇索引，也叫“\"),t(\"strong\",[_._v(\"聚集索引\")]),_._v(\"”，表示索引结构和数据一起存放的索引。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"非聚集索引是\"),t(\"strong\",[_._v(\"索引结构和数据分开存放的索引\")]),_._v(\"。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"因为 InnoDB  默认存储引擎的原因，我们说这个一般指的是 InnoDB 中的聚集索引和非聚集索引\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"InnoDB 引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录\")]),_._v(\"（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，\"),t(\"strong\",[_._v(\"InnoDB 的数据文件本身就是主键索引文件\")]),_._v('，这样的索引被称为\"“'),t(\"strong\",[_._v(\"聚簇索引\")]),_._v(\"”，一个表只能有一个聚簇索引。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"InnoDB 聚集索引\")]),_._v(\"：InnoDB 存储引擎使用聚集索引来存储主键列，并且所有非主键列都包含在聚集索引中，这意味着聚集索引实际上包含了整行数据。一个表只能有一个聚簇索引\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"InnoDB 非聚集索引\")]),_._v(\"：InnoDB 的非聚集索引（也称为辅助索引）首先存储非主键索引列的值，然后通过主键列的值来查找对应的行。这种方式称为“索引的索引”，因为非聚集索引首先查找主键。\")])]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/MySQL-secondary-index.png\",alt:\"\"}})]),_._v(\" \"),t(\"h3\",{attrs:{id:\"非聚簇索引一定会回表查询吗\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#非聚簇索引一定会回表查询吗\"}},[_._v(\"#\")]),_._v(\" 非聚簇索引一定会回表查询吗?\")]),_._v(\" \"),t(\"p\",[_._v(\"不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。\")]),_._v(\" \"),t(\"p\",[_._v(\"举个简单的例子：假设我们在员工表的年龄上建立了索引，那么当进行的查询时,在索引的叶子节点上,已经包含了 age 信息，不会再次进行回表查询。\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-sql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"select\")]),_._v(\" age \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"from\")]),_._v(\" employee \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"where\")]),_._v(\" age \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[_._v(\"<\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[_._v(\"20\")]),_._v(\"\\n\")])])]),t(\"h3\",{attrs:{id:\"innodb引擎中的索引策略-了解过吗\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#innodb引擎中的索引策略-了解过吗\"}},[_._v(\"#\")]),_._v(\" InnoDB引擎中的索引策略，了解过吗？\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 索引策略主要包括以下几个方面:\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"聚簇索引\")]),_._v(\" \"),t(\"li\",[_._v(\"辅助索引，也就是非聚簇索引\")]),_._v(\" \"),t(\"li\",[_._v(\"覆盖索引：查询可以直接通过索引获取所需数据，而无需回表查询\")]),_._v(\" \"),t(\"li\",[_._v(\"前缀索引：用于对较长的字符串列进行索引，只索引字符串的前 N 个字符\")]),_._v(\" \"),t(\"li\",[_._v(\"全文索引：用于对大文本字段进行全文检索\")])]),_._v(\" \"),t(\"p\",[_._v(\"每种索引类型都有其独特的用途和优势，通过合理使用这些索引，可以显著提高数据库的查询性能。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"使用索引查询一定能提高查询的性能吗-为什么\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用索引查询一定能提高查询的性能吗-为什么\"}},[_._v(\"#\")]),_._v(\" 使用索引查询一定能提高查询的性能吗？为什么?\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"其实这个问题也对应的是哪些情况需要建立索引，哪些不需要\")]),_._v(\" \"),t(\"p\",[_._v(\"使用索引需要注意的几个地方？\")])]),_._v(\" \"),t(\"p\",[_._v(\"使用索引查询并不一定总能提高查询性能\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"为什么使用索引通常能提高查询性能：\")])]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"减少需要扫描的数据量来加快数据检索速度\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"频繁作为查询条件的字段\")]),_._v(\" \"),t(\"li\",[_._v(\"查询中与其他表关联的字段，外键关系建立索引\")]),_._v(\" \"),t(\"li\",[_._v(\"在查询涉及的所有列都在索引中时，可以避免回表查询，提高查询效率\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"索引可以显著加快 \"),t(\"code\",[_._v(\"ORDER BY\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"GROUP BY\")]),_._v(\" 操作\")])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"为什么在某些情况下索引查询反而可能降低性能\")]),_._v(\"：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"小表或低选择性列\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"小表\")]),_._v(\"：对于行数很少的表，索引带来的性能提升有限，因为全表扫描的开销也很小。索引反而增加了额外的维护开销。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"低选择性列\")]),_._v('：如果索引列的选择性很低（例如，性别列只有两个值 \"M\" 和 \"F\"），使用索引可能会导致大量的行扫描，无法显著减少数据量，索引的效果不明显。')])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"经常增删改的表\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"频繁的写操作\")]),_._v(\"：索引不仅在读取数据时加速查询，还在插入、更新和删除操作时带来额外的开销。每次写操作都需要更新索引，索引越多，写操作的开销就越大。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"在高并发环境下，索引也可能导致锁竞争，影响查询性能\")])])]),_._v(\" \"),t(\"p\",[_._v(\"是否使用索引以及如何设计索引需要根据具体的查询模式、数据量、更新频率、硬件资源等多种因素综合考虑\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"innodb-表为什么要建议用自增列做主键\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#innodb-表为什么要建议用自增列做主键\"}},[_._v(\"#\")]),_._v(\" InnoDB 表为什么要建议用自增列做主键\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"聚簇索引的效率\")])]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 表使用聚集索引来存储数据，聚簇索引的叶子节点存储数据行的物理位置，这意味着数据行在磁盘上的物理顺序与索引的顺序一致\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"顺序插入\")]),_._v(\"：自增列使得每次插入新记录时，新的记录都被追加到表的末尾，插入操作非常高效，不需要在表的中间位置插入数据，从而避免了频繁的页拆分和数据移动。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"减少碎片\")]),_._v(\"：顺序插入数据可以减少表碎片，维持数据的物理连续性，进而提高查询性能。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"唯一性和简单性\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"唯一性\")]),_._v(\"：自增列保证每个记录都有一个唯一的标识符，避免了重复记录。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"简单性\")]),_._v(\"：自增列无需复杂的生成逻辑，MySQL 会自动处理自增值，简化了应用程序的开发和维护。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"更好的缓存命中率\")])]),_._v(\" \"),t(\"p\",[_._v(\"顺序插入的新记录使得最近插入的数据很可能在相邻的存储位置，这提高了缓存的命中率。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"缓存友好\")]),_._v(\"：数据库缓存更容易缓存相邻的存储块，从而提高查询的性能，特别是在高并发的读写环境下。\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"如何写-sql-能够有效的使用到复合索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何写-sql-能够有效的使用到复合索引\"}},[_._v(\"#\")]),_._v(\" 如何写 SQL 能够有效的使用到复合索引\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"MySQL高效索引\")])]),_._v(\" \"),t(\"p\",[_._v(\"要有效地使用复合索引（也称为多列索引或组合索引），编写 SQL 查询时需要考虑以下几点：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"覆盖索引\")]),_._v(\"（Covering Index），或者叫索引覆盖， 也就是平时所说的不需要回表操作\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"如果查询的列完全包含在复合索引中，那么可以使用覆盖索引，这样可以避免回表查询，提高性能。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"最左前缀法则\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"复合索引的效率取决于查询条件是否遵循最左前缀法则，即从索引的最左边列开始匹配。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"例如，如果你有一个 (\"),t(\"code\",[_._v(\"c1\")]),_._v(\", \"),t(\"code\",[_._v(\"c2\")]),_._v(\", \"),t(\"code\",[_._v(\"c3\")]),_._v(\") 的复合索引，那么以下查询可以高效地使用索引：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-sql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"SELECT\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[_._v(\"*\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"FROM\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"table\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"WHERE\")]),_._v(\" c1 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[_._v(\"=\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[_._v(\"'value1'\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\";\")]),_._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"SELECT\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[_._v(\"*\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"FROM\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"table\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"WHERE\")]),_._v(\" c1 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[_._v(\"=\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[_._v(\"'value1'\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[_._v(\"AND\")]),_._v(\" c2 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[_._v(\"=\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[_._v(\"'value2'\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\";\")]),_._v(\"\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"如果查询条件不包含 \"),t(\"code\",[_._v(\"c1\")]),_._v(\"，则该复合索引不会被使用。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"索引列的顺序\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"在复合索引中，列的顺序很重要。应该将选择性最高的列（即不同值占总行数比例最高的列）放在前面。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"使用索引列作为条件\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"确保 WHERE 子句中的条件列与复合索引中的列相匹配，并且顺序正确。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"避免使用函数和表达式\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"如果在 WHERE 子句中对索引列应用了函数或计算，可能会使索引失效。\")]),_._v(\" \"),t(\"li\",[_._v(\"例如，如果 \"),t(\"code\",[_._v(\"c1\")]),_._v(\" 是索引的一部分，应避免 \"),t(\"code\",[_._v(\"WHERE UPPER(col1) = 'VALUE'\")]),_._v(\"，而应使用 \"),t(\"code\",[_._v(\"WHERE c1 = 'value'\")]),_._v(\"。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"范围查询和排序\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"复合索引可以用于涉及范围查询的 ORDER BY 和 GROUP BY 子句。\")]),_._v(\" \"),t(\"li\",[_._v(\"例如，如果有一个 (\"),t(\"code\",[_._v(\"c1\")]),_._v(\", \"),t(\"code\",[_._v(\"c2\")]),_._v(\") 的索引，\"),t(\"code\",[_._v(\"ORDER BY c1, c2\")]),_._v(\" 可以有效地使用索引。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"限制索引的使用\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"使用 \"),t(\"code\",[_._v(\"LIKE\")]),_._v(\" 操作符进行模糊匹配时，如果模式以通配符（\"),t(\"code\",[_._v(\"%\")]),_._v(\"）开头，索引将不会被使用。\")]),_._v(\" \"),t(\"li\",[_._v(\"例如，使用 \"),t(\"code\",[_._v(\"WHERE c1 LIKE '%value'\")]),_._v(\" 将无法利用索引。\")])])])]),_._v(\" \"),t(\"p\",[_._v(\"考虑查询的实际条件，如数据量大小、表的更新频率等，以确定是否真正需要复合索引。在实际的数据库环境中测试查询性能，并根据查询执行计划（\"),t(\"code\",[_._v(\"EXPLAIN\")]),_._v(\"）来优化索引的使用\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"联合索引abc-现在有个执行语句是a-xxx-and-c-xxx-索引怎么走\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#联合索引abc-现在有个执行语句是a-xxx-and-c-xxx-索引怎么走\"}},[_._v(\"#\")]),_._v(\" 联合索引ABC，现在有个执行语句是A = XXX and C < XXX，索引怎么走?\")]),_._v(\" \"),t(\"p\",[_._v(\"给定查询语句 \"),t(\"code\",[_._v(\"A = XXX AND C < XXX\")]),_._v(\" 和联合索引 \"),t(\"code\",[_._v(\"(A, B, C)\")]),_._v(\"，我们来分析索引的使用情况：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"精确匹配 \"),t(\"code\",[_._v(\"A\")])]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"由于条件 \"),t(\"code\",[_._v(\"A = XXX\")]),_._v(\" 是精确匹配，第一个索引列 \"),t(\"code\",[_._v(\"A\")]),_._v(\" 将被使用。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"跳过 \"),t(\"code\",[_._v(\"B\")])]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"由于查询条件中没有涉及列 \"),t(\"code\",[_._v(\"B\")]),_._v(\"，联合索引的第二列 \"),t(\"code\",[_._v(\"B\")]),_._v(\" 将被跳过。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"范围查询 \"),t(\"code\",[_._v(\"C\")])]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"条件 \"),t(\"code\",[_._v(\"C < XXX\")]),_._v(\" 是范围查询。根据最左前缀法则和范围查询终止索引使用的规则，虽然条件 \"),t(\"code\",[_._v(\"C < XXX\")]),_._v(\" 出现在查询中，但因为 \"),t(\"code\",[_._v(\"B\")]),_._v(\" 没有出现在条件中，所以索引在 \"),t(\"code\",[_._v(\"C\")]),_._v(\" 列上不能继续有效使用。\")])])])]),_._v(\" \"),t(\"p\",[_._v(\"在这个查询 \"),t(\"code\",[_._v(\"A = XXX AND C < XXX\")]),_._v(\" 中，联合索引 \"),t(\"code\",[_._v(\"(A, B, C)\")]),_._v(\" 只能部分使用，即只会使用索引的第一列 \"),t(\"code\",[_._v(\"A\")]),_._v(\"，后续的 \"),t(\"code\",[_._v(\"B\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"C\")]),_._v(\" 列将不会被索引利用。具体来说，执行计划会使用索引 \"),t(\"code\",[_._v(\"(A, B, C)\")]),_._v(\" 中的 \"),t(\"code\",[_._v(\"(A)\")]),_._v(\" 进行查找，然后对找到的记录进行筛选以满足 \"),t(\"code\",[_._v(\"C < XXX\")]),_._v(\" 的条件。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"数据库不使用索引的几种可能\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据库不使用索引的几种可能\"}},[_._v(\"#\")]),_._v(\" 数据库不使用索引的几种可能？\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"小型表或数据量少\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"全表扫描速度快：对于小型表或数据量较少的表，全表扫描的速度可能与使用索引扫描的速度相当甚至更快，因为读取整个表所需的时间较短。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"索引开销大：索引的创建和维护需要额外的存储空间和资源，对小型表来说，这些开销可能超过其带来的性能提升。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"数据分布不均\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"低选择性：如果某个列的值的重复率很高，例如性别列只有“男”和“女”两种值，使用索引的选择性很低，索引扫描可能比全表扫描更慢。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"数据倾斜：数据在某些特定值上高度集中，这种情况下，使用索引可能不会带来显著的性能提升。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"查询模式不适合\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"范围查询\")]),_._v(\"：对于范围查询，例如“BETWEEN”、“>”和“<”，使用索引的效率可能不如期望中的高，因为索引可能需要扫描较多的记录。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"范围查询，不是一定不会使用索引，成本决定执行计划，优化器会首先针对可能使用到的二级索引划分几个扫描区间，然后分别调查这些区间内有多少条记录，在这些扫描区间内的二级索引记录的总和占总共的记录数量的比例达到某个值时，优化器将放弃使用二级索引执行查询，转而采用全表扫描\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"LIKE 操作\")]),_._v(\"：对于使用通配符“%”在前的LIKE查询（如“%value”），索引无法高效使用，因为数据库需要扫描整个表来找到匹配的值。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"索引未命中\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"函数操作\")]),_._v(\"：在查询条件中使用函数操作（如UPPER(column_name) = 'VALUE'）会导致索引无法被使用，因为索引存储的是原始数据。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"隐式类型转换\")]),_._v(\"：如果列的数据类型与查询条件中的数据类型不一致（如列为整数，但条件中使用字符串），数据库可能进行隐式类型转换，导致索引失效。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"数据库优化器选择\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"优化器策略\")]),_._v(\"：数据库优化器根据统计信息和查询成本选择执行计划。在某些情况下，优化器可能判断全表扫描比索引扫描更高效。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"统计信息不准确\")]),_._v(\"：如果统计信息不准确或过期，优化器可能做出不合适的决策，选择不使用索引。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"索引维护成本\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"高频更新\")]),_._v(\"：对于高频插入、更新和删除操作的表，索引的维护成本可能较高，影响整体性能。在这种情况下，可能会选择不使用索引或减少索引的数量。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"多列索引的限制\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"索引列顺序\")]),_._v(\"：多列索引只有在按索引列顺序查询时才能被高效使用，如果查询条件中不包含索引的前导列，索引将无法使用。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"查询不完全匹配\")]),_._v(\"：对于复合索引，如果查询条件不完全匹配索引定义，索引的使用效果可能不佳。\")])])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"主键索引和唯一索引的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#主键索引和唯一索引的区别\"}},[_._v(\"#\")]),_._v(\" 主键索引和唯一索引的区别？\")]),_._v(\" \"),t(\"p\",[_._v(\"主键索引是特殊的唯一索引，唯一索引查询会涉及到“回表”操作\")]),_._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[_._v(\"特性\")]),_._v(\" \"),t(\"th\",[_._v(\"主键索引（Primary Key Index）\")]),_._v(\" \"),t(\"th\",[_._v(\"唯一索引（Unique Index）\")])])]),_._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[_._v(\"唯一性\")]),_._v(\" \"),t(\"td\",[_._v(\"必须唯一\")]),_._v(\" \"),t(\"td\",[_._v(\"必须唯一（允许 NULL 值）\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"是否允许 NULL\")]),_._v(\" \"),t(\"td\",[_._v(\"不允许\")]),_._v(\" \"),t(\"td\",[_._v(\"允许多个 NULL 值「这里 NULL 的定义 ，是指 未知值。 所以多个 NULL ，都是未知的」\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"聚簇索引\")]),_._v(\" \"),t(\"td\",[_._v(\"是（在 InnoDB 中）\")]),_._v(\" \"),t(\"td\",[_._v(\"否（除非是主键）\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"每个表的数量\")]),_._v(\" \"),t(\"td\",[_._v(\"只能有一个\")]),_._v(\" \"),t(\"td\",[_._v(\"可以有多个\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"主要用途\")]),_._v(\" \"),t(\"td\",[_._v(\"唯一标识每一行\")]),_._v(\" \"),t(\"td\",[_._v(\"强制唯一性约束，非主键用途\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"创建语法\")]),_._v(\" \"),t(\"td\",[t(\"code\",[_._v(\"PRIMARY KEY\")])]),_._v(\" \"),t(\"td\",[t(\"code\",[_._v(\"UNIQUE\")])])])])]),_._v(\" \"),t(\"div\",{staticClass:\"language-sql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"CREATE\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"TABLE\")]),_._v(\" example \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\"(\")]),_._v(\"\\n    id \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"INT\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"AUTO_INCREMENT\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"PRIMARY\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"KEY\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\",\")]),_._v(\"\\n    email \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"VARCHAR\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[_._v(\"100\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\")\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"UNIQUE\")]),_._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\";\")]),_._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"INSERT\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"INTO\")]),_._v(\" example \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\"(\")]),_._v(\"email\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\")\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"VALUES\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token boolean\"}},[_._v(\"NULL\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\",\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token boolean\"}},[_._v(\"NULL\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\",\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token boolean\"}},[_._v(\"NULL\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\";\")]),_._v(\"\\n\")])])]),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"五、日志\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#五、日志\"}},[_._v(\"#\")]),_._v(\" 五、日志\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"Mysql 日志其实是各种其他知识模块的基础。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"mysql日志文件有哪些，分别介绍下作用\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-都有哪些日志-执行顺序是怎么样的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-都有哪些日志-执行顺序是怎么样的\"}},[_._v(\"#\")]),_._v(\" MySQL  都有哪些日志，执行顺序是怎么样的？\")]),_._v(\" \"),t(\"blockquote\",[t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"错误日志\")]),_._v(\"：记录出错信息，也记录一些警告信息或者正确的信息。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"通用查询日志\")]),_._v(\"：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"慢查询日志\")]),_._v(\"：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"二进制日志\")]),_._v(\"：记录对数据库执行更改的所有操作。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"中继日志\")]),_._v(\"：中继日志也是二进制日志，用来给slave 库恢复\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"事务日志\")]),_._v(\"：重做日志redo和回滚日志undo\")])])])]),_._v(\" \"),t(\"p\",[_._v(\"时序上先 undo log，redo log 先 prepare， 再写 binlog，最后再把 redo log commit\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/log-seq.png\",alt:\"\"}})]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说下-一条-mysql-更新语句的执行流程是怎样的吧\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说下-一条-mysql-更新语句的执行流程是怎样的吧\"}},[_._v(\"#\")]),_._v(\" 说下 一条 MySQL 更新语句的执行流程是怎样的吧？\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"解析和优化\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"语法解析\")]),_._v(\"：MySQL解析器会对\"),t(\"code\",[_._v(\"UPDATE\")]),_._v(\"语句进行语法解析，生成语法树，并检查语句的合法性。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"查询优化器\")]),_._v(\"：优化器会根据表的索引、统计信息等来选择最优的执行计划，以最快的方式查找需要更新的记录。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"定位记录\")]),_._v(\"（这个过程也被称作\"),t(\"strong\",[_._v(\"加锁读\")]),_._v(\"）\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"通过索引定位\")]),_._v(\"：如果更新语句涉及索引，MySQL会利用索引快速定位需要更新的记录。如果没有索引，则会进行全表扫描。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"在Buffer Pool中查找页\")]),_._v(\"：MySQL首先会在Buffer Pool中查找包含目标记录的页（数据页或索引页），如果该页已经存在于Buffer Pool中，则直接使用；否则会将其从磁盘加载到 Buffer Pool 中。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"生成Undo日志\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"生成Undo日志\")]),_._v(\"：为了支持事务的回滚，MySQL 会在更新操作前生成一条 Undo 日志，该日志记录了被更新行的\"),t(\"strong\",[_._v(\"旧值\")]),_._v(\"。Undo日志存储在回滚段（Rollback Segment）中。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"保存Undo日志\")]),_._v(\"：在发生事务回滚时，MySQL会使用Undo日志将数据恢复到更新前的状态。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"更新数据\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"更新Buffer Pool中的数据页\")]),_._v(\"：MySQL在Buffer Pool中对定位到的记录进行更新操作，修改记录的值。这是一个内存中的操作，数据页此时还没有写回到磁盘。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"标记页为脏页\")]),_._v(\"：被修改的页会被标记为“脏页”，表示其内容与磁盘上的数据不同，需要在适当的时候写回磁盘。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"生成Redo日志\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"生成Redo日志\")]),_._v(\"：Redo日志记录了数据页的物理变化，用于在数据库崩溃时恢复数据一致性。Redo日志包括这次更新操作的具体细节，如页号、偏移量和新值。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"写入Redo日志缓存\")]),_._v(\"：生成的Redo日志首先被写入Redo日志缓存（Log Buffer），而不是直接写入磁盘。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务\")])])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"写入Binlog\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"生成Binlog\")]),_._v(\"：MySQL会生成一条对应的Binlog（针对事务性表的DML语句）。Binlog记录的是这次更新的逻辑变化（类似于SQL语句或行级变化），主要用于主从复制和数据恢复。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"刷写Binlog\")]),_._v(\"：Binlog首先被写入到Binlog缓存，当事务提交时会将缓存中的Binlog刷写到磁盘上的Binlog文件。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"事务提交\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"刷写Redo日志\")]),_._v(\"：在事务提交前，MySQL会将Redo日志从日志缓存刷写到磁盘的Redo日志文件（ib_logfile0, ib_logfile1）。此操作通常是顺序写入，因此效率较高。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"刷写Binlog\")]),_._v(\"：在事务提交时，Binlog也会被刷写到磁盘。根据MySQL的设置，可能会先刷写Binlog再刷写Redo日志，或以不同顺序执行。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"两阶段提交\")]),_._v(\"：为了确保Binlog和Redo日志的原子性，MySQL使用两阶段提交的机制。具体步骤是：首先写入Redo日志（处于Prepare状态），然后写入Binlog，最后更新Redo日志为Commit状态。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"数据页刷盘\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"异步刷盘\")]),_._v(\"：脏页的刷盘（即将修改后的数据页从Buffer Pool写回到磁盘）通常是异步进行的。InnoDB存储引擎会根据脏页数量、系统空闲时间等条件定期执行刷盘操作。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"检查点\")]),_._v(\"：MySQL通过检查点机制来控制Redo日志的循环使用和脏页的刷盘。当达到检查点时，会将所有脏页刷写到磁盘，同时更新Redo日志的检查点信息。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"完成更新操作\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"事务结束\")]),_._v(\"：当Redo日志和Binlog都刷写到磁盘后，事务就完成了。对于非事务性表，操作可能不会涉及Undo日志和Redo日志。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"释放锁\")]),_._v(\"：在事务完成后，MySQL会释放占用的锁资源。\")])])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说说-redo-log-、undo-log-和-bin-log\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说说-redo-log-、undo-log-和-bin-log\"}},[_._v(\"#\")]),_._v(\" 说说 redo log 、undo log 和 bin log ？\")]),_._v(\" \"),t(\"p\",[_._v(\"在 MySQL 中，特别是在使用 InnoDB 存储引擎时，\"),t(\"code\",[_._v(\"redo log\")]),_._v(\"（重做日志）、\"),t(\"code\",[_._v(\"undo log\")]),_._v(\"（回滚日志）和 \"),t(\"code\",[_._v(\"binlog\")]),_._v(\"（二进制日志）各自承担着不同的角色：\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"1. Redo Log（重做日志）：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"目的\")]),_._v(\"：确保事务的持久性。在系统崩溃后，\"),t(\"code\",[_._v(\"redo log\")]),_._v(\" 允许恢复未提交的事务更改，保证数据的完整性和一致性。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"内容\")]),_._v(\"：记录了事务对数据页所做的物理更改【\"),t(\"strong\",[_._v(\"物理日志\")]),_._v(\"】，以便在崩溃恢复时重新应用这些更改。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"写入时机\")]),_._v(\"：在事务提交时，将更改刷新到磁盘上的 \"),t(\"code\",[_._v(\"redo log\")]),_._v(\" 文件中。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"大小和循环\")]),_._v(\"：\"),t(\"code\",[_._v(\"redo log\")]),_._v(\" 通常配置为固定大小的日志文件，并且可以循环使用。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"用途\")]),_._v(\"：\"),t(\"strong\",[_._v(\"崩溃恢复\")]),_._v(\"，在数据库崩溃后，通过 redo log 恢复到崩溃前的状态，保证数据一致性。\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"redo log 不需要写磁盘吗？如果 redo log 也要写磁盘，干嘛不直接修改数据呢？redo log 是需要写磁盘的，但是 redo log 是\"),t(\"strong\",[_._v(\"顺序写\")]),_._v(\"的，所以也是 WAL（writeahead-log） 的一种。\")]),_._v(\" \"),t(\"p\",[_._v(\"redo log 本身也是先写进 redo log buffer，后面再刷新到操作系统的 page cache，或者一步到位刷新到磁盘\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 引擎本身提供了参数 innodb_flush_log_at_trx_commit 来控制写到磁盘的时机，里面有三个不同值。\")]),_._v(\" \"),t(\"p\",[_._v(\"0：每秒刷新到磁盘，是从 redo log buffer 到磁盘。\")]),_._v(\" \"),t(\"p\",[_._v(\"1：每次提交的时候刷新到磁盘上，也就是最安全的选项，InnoDB 的\"),t(\"strong\",[_._v(\"默认值\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"2：每次提交的时候刷新到 page cache 里，依赖于操作系统后续刷新到磁盘。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"2. Undo Log（回滚日志）：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"目的\")]),_._v(\"：提供事务的原子性和一致性。它允许撤销事务的更改，以保持数据的一致状态。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"内容\")]),_._v(\"：记录了事务对数据页所做的更改的逆操作【\"),t(\"strong\",[_._v(\"逻辑日志\")]),_._v(\"】，使得在事务失败或需要回滚时可以恢复原始数据。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"写入时机\")]),_._v(\"：当事务进行修改操作时，\"),t(\"code\",[_._v(\"undo log\")]),_._v(\" 会记录这些更改的逆操作，通常在事务提交前就已经写入。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"用途\")]),_._v(\"：主要用于 MVCC（多版本并发控制）和事务回滚。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"3. Binlog（二进制日志）：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"目的\")]),_._v(\"：记录数据库的所有修改操作，用于数据恢复、主从复制和数据审计。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"内容\")]),_._v(\"：记录了所有修改数据的 SQL 语句，如 \"),t(\"code\",[_._v(\"INSERT\")]),_._v(\"、\"),t(\"code\",[_._v(\"UPDATE\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"DELETE\")]),_._v(\"，但不记录 \"),t(\"code\",[_._v(\"SELECT\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"SHOW\")]),_._v(\" 这类的语句。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"写入时机\")]),_._v(\"：在 SQL 语句执行后，根据配置，\"),t(\"code\",[_._v(\"binlog\")]),_._v(\" 可以立即或事务提交时写入磁盘。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"大小和存储\")]),_._v(\"：\"),t(\"code\",[_._v(\"binlog\")]),_._v(\" 文件通常不循环使用，它们会随着时间持续增长，直到通过配置的策略进行清理。\")])]),_._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[_._v(\"特性\")]),_._v(\" \"),t(\"th\",[_._v(\"Redo Log\")]),_._v(\" \"),t(\"th\",[_._v(\"Undo Log\")]),_._v(\" \"),t(\"th\",[_._v(\"Bin Log\")])])]),_._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[_._v(\"主要用途\")]),_._v(\" \"),t(\"td\",[_._v(\"崩溃恢复\")]),_._v(\" \"),t(\"td\",[_._v(\"事务回滚、多版本并发控制（MVCC）\")]),_._v(\" \"),t(\"td\",[_._v(\"主从复制和数据恢复\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"日志类型\")]),_._v(\" \"),t(\"td\",[_._v(\"物理日志\")]),_._v(\" \"),t(\"td\",[_._v(\"逻辑日志\")]),_._v(\" \"),t(\"td\",[_._v(\"逻辑日志\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"存储内容\")]),_._v(\" \"),t(\"td\",[_._v(\"页级物理更改\")]),_._v(\" \"),t(\"td\",[_._v(\"数据快照\")]),_._v(\" \"),t(\"td\",[_._v(\"SQL 语句或行级数据变化\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"写入方式\")]),_._v(\" \"),t(\"td\",[_._v(\"循环写入\")]),_._v(\" \"),t(\"td\",[_._v(\"按需写入\")]),_._v(\" \"),t(\"td\",[_._v(\"追加写入\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"写入时机\")]),_._v(\" \"),t(\"td\",[_._v(\"事务提交时\")]),_._v(\" \"),t(\"td\",[_._v(\"事务操作时\")]),_._v(\" \"),t(\"td\",[_._v(\"事务提交时\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"大小\")]),_._v(\" \"),t(\"td\",[_._v(\"固定大小\")]),_._v(\" \"),t(\"td\",[_._v(\"可变大小\")]),_._v(\" \"),t(\"td\",[_._v(\"可变大小\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"作用\")]),_._v(\" \"),t(\"td\",[_._v(\"保证数据一致性和持久性\")]),_._v(\" \"),t(\"td\",[_._v(\"提供事务回滚和一致性读支持\")]),_._v(\" \"),t(\"td\",[_._v(\"实现数据复制和备份\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-的-binlog-有几种录入格式-分别有什么区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-的-binlog-有几种录入格式-分别有什么区别\"}},[_._v(\"#\")]),_._v(\" MySQL 的 binlog 有几种录入格式？分别有什么区别？\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"binlog\")]),_._v(\"日志有三种格式，分别为\"),t(\"code\",[_._v(\"STATMENT\")]),_._v(\"、\"),t(\"code\",[_._v(\"ROW\")]),_._v(\"和\"),t(\"code\",[_._v(\"MIXED\")]),_._v(\"。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"在 \"),t(\"code\",[_._v(\"MySQL 5.7.7\")]),_._v(\"之前，默认的格式是\"),t(\"code\",[_._v(\"STATEMENT\")]),_._v(\"，\"),t(\"code\",[_._v(\"MySQL 5.7.7\")]),_._v(\"之后，默认值是 \"),t(\"code\",[_._v(\"ROW\")]),_._v(\"。日志格式通过 \"),t(\"code\",[_._v(\"binlog-format\")]),_._v(\" 指定。\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"code\",[_._v(\"STATMENT\")]),_._v(\" ：基于 SQL 语句的复制(\"),t(\"code\",[_._v(\"statement-based replication, SBR\")]),_._v(\")，每一条会修改数据的 sql 语句会记录到 binlog 中**。**\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO, 从而提高了性能；\")]),_._v(\" \"),t(\"li\",[_._v(\"缺点：在某些情况下会导致主从数据不一致，比如执行\"),t(\"code\",[_._v(\"sysdate()\")]),_._v(\"、\"),t(\"code\",[_._v(\"slepp()\")]),_._v(\"等。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\"ROW\")]),_._v(\" ：基于行的复制(\"),t(\"code\",[_._v(\"row-based replication, RBR\")]),_._v(\")，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了**。 **\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题**；**\")]),_._v(\" \"),t(\"li\",[_._v(\"缺点：会产生大量的日志，尤其是 \"),t(\"code\",[_._v(\"alter table\")]),_._v(\" 的时候会让日志暴涨\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\"MIXED\")]),_._v(\" ：基于 STATMENT 和 ROW 两种模式的混合复制(\"),t(\"code\",[_._v(\"mixed-based replication, MBR\")]),_._v(\")，mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"为什么需要两阶段提交\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么需要两阶段提交\"}},[_._v(\"#\")]),_._v(\" 为什么需要两阶段提交\")]),_._v(\" \"),t(\"p\",[_._v(\"以 \"),t(\"code\",[_._v(\"update T set c=c+1 where ID=2;\")]),_._v(\" 为例，反向说明下原因\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"先写 redo log 后写 binlog\")]),_._v(\"。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。\\n但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。\\n然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"先写 binlog 后写 redo log\")]),_._v(\"。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。\")])]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"六、mysql-事务\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#六、mysql-事务\"}},[_._v(\"#\")]),_._v(\" 六、MySQL 事务\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"什么是事务-事务有哪些特性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是事务-事务有哪些特性\"}},[_._v(\"#\")]),_._v(\" 什么是事务？事务有哪些特性？\")]),_._v(\" \"),t(\"p\",[_._v(\"事务是由一组 SQL 语句组成的逻辑处理单元，具有 4 个属性，通常简称为事务的 ACID 属性。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"A (Atomicity) 原子性\")]),_._v(\"：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"C (Consistency) 一致性\")]),_._v(\"：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"I (Isolation)隔离性\")]),_._v(\"：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"D (Durability) 持久性\")]),_._v(\"：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"什么是脏读、不可重复读和幻读\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是脏读、不可重复读和幻读\"}},[_._v(\"#\")]),_._v(\" 什么是脏读、不可重复读和幻读？\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"并发事务处理带来的问题\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"更新丢失（Lost Update)： 事务 A 和事务 B 选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题\")]),_._v(\" \"),t(\"li\",[_._v(\"脏读(Dirty Reads)：事务 A 读取了事务 B 未提交的数据，然后 B  回滚操作，那么 A 读取到的数据是脏数据\")]),_._v(\" \"),t(\"li\",[_._v(\"不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。\")]),_._v(\" \"),t(\"li\",[_._v(\"幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务 A 读取了几行数据，接着另一个并发事务 B 插入了一些数据时。在随后的查询中，事务 A 就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[t(\"strong\",[_._v(\"幻读和不可重复读的区别：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"不可重复读的重点是修改\")]),_._v(\"：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"幻读的重点在于新增或者删除\")]),_._v(\"：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-支持哪些事务隔离级别-各有什么区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-支持哪些事务隔离级别-各有什么区别\"}},[_._v(\"#\")]),_._v(\" MySQL 支持哪些事务隔离级别？各有什么区别？\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 支持四种事务隔离级别，由低到高分别为：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"READ UNCOMMITTED(读未提交)：\")]),_._v(\" 最低的隔离级别，允许读取尚未提交的数据变更，\"),t(\"strong\",[_._v(\"可能会导致脏读、幻读或不可重复读\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"READ COMMITTED(读已提交)：\")]),_._v(\" 允许读取并发事务已经提交的数据，\"),t(\"strong\",[_._v(\"可以阻止脏读，但是幻读或不可重复读仍有可能发生\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"REPEATABLE READ(可重复读)：\")]),_._v(\" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，\"),t(\"strong\",[_._v(\"可以阻止脏读和不可重复读，但幻读仍有可能发生\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"SERIALIZABLE(可串行化)：\")]),_._v(\" 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，\"),t(\"strong\",[_._v(\"该级别可以防止脏读、不可重复读以及幻读\")]),_._v(\"。\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[t(\"strong\",[_._v(\"简单点的理解\")])]),_._v(\" \"),t(\"p\",[_._v(\"读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。\")]),_._v(\" \"),t(\"p\",[_._v(\"读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。\")]),_._v(\" \"),t(\"p\",[_._v(\"可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。\")]),_._v(\" \"),t(\"p\",[_._v(\"串行：我的事务尚未提交，别人就别想改数据。\")])]),_._v(\" \"),t(\"p\",[_._v(\"查看当前数据库的事务隔离级别：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"show variables like 'tx_isolation'\\n\")])])]),t(\"h3\",{attrs:{id:\"mysql-如何实现事务隔离-并发事务处理带来的问题的解决办法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-如何实现事务隔离-并发事务处理带来的问题的解决办法\"}},[_._v(\"#\")]),_._v(\" MySQL 如何实现事务隔离 | 并发事务处理带来的问题的解决办法\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"“更新丢失” 通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"一种是加\"),t(\"strong\",[_._v(\"锁\")]),_._v(\"：在读取数据前，对其加锁，阻止其他事务对数据进行修改。MySQL 通过行级锁和表级锁来管理并发访问。行级锁包括共享锁（读锁）和排他锁（写锁），表级锁包括意向锁和元数据锁。\")]),_._v(\" \"),t(\"li\",[_._v(\"另一种是数据\"),t(\"strong\",[_._v(\"多版本并发控制\")]),_._v(\"（MultiVersion Concurrency Control，简称 \"),t(\"strong\",[_._v(\"MVCC\")]),_._v(\"），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。\")])])])]),_._v(\" \"),t(\"p\",[_._v(\"MySQL InnoDB 存储引擎的默认支持的隔离级别是 \"),t(\"strong\",[_._v(\"REPEATABLE-READ（可重读）\")]),_._v(\"。我们可以通过\"),t(\"code\",[_._v(\"SELECT @@tx_isolation;\")]),_._v(\"命令来查看，MySQL 8.0 该命令改为\"),t(\"code\",[_._v(\"SELECT @@transaction_isolation;\")])]),_._v(\" \"),t(\"p\",[_._v(\"这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 \"),t(\"strong\",[_._v(\"REPEATABLE-READ（可重读）\"),t(\"strong\",[_._v(\"事务隔离级别下\")]),_._v(\"使用的是 Next-Key Lock 算法，因此可以避免幻读的产生\")]),_._v(\"，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(可串行化)**隔离级别，而且保留了比较好的并发性能。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[t(\"strong\",[_._v(\"Next-Key Locks\")]),_._v(\"：MySQL通过在索引上的间隙加锁（Gap Lock），结合行锁，形成所谓的Next-Key锁，锁定一个范围。这样即使在事务运行期间，其他事务也无法在该范围内插入新的行，从而避免了幻读\")])]),_._v(\" \"),t(\"p\",[_._v(\"因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是\"),t(\"strong\",[_._v(\"READ-COMMITTED(读已提交):\")]),_._v(\"，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"加锁的基本原则（RR隔离级别下）\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"原则1：加锁的对象是 next-key lock。（是一个前开后闭的区间）\")]),_._v(\" \"),t(\"li\",[_._v(\"原则2：查找过程中访问到的对象才加锁\")])]),_._v(\" \"),t(\"p\",[_._v(\"优化1：唯一索引加锁时，next-key lock 退化为行锁。\\n索引上的等值查询，向右遍历时最后一个不满足等值条件的时候，next-key lock 退化为间隙锁\\n唯一索引和普通索引在范围查询的时候 都会访问到不满足条件的第一个值为止\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mvcc-熟悉吗-它的底层原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mvcc-熟悉吗-它的底层原理\"}},[_._v(\"#\")]),_._v(\" MVCC 熟悉吗，它的底层原理？\")]),_._v(\" \"),t(\"p\",[_._v(\"MVCC（Multi-Version Concurrency Control）中文叫做多版本并发控制协议，是 MySQL InnoDB 引擎用于控制数据并发访问的协议。\")]),_._v(\" \"),t(\"p\",[_._v(\"MVCC 主要是借助于版本链来实现的。\")]),_._v(\" \"),t(\"p\",[_._v(\"在 InnoDB 引擎里面，每一行都有两个额外的列，一个是 trx_id，代表的是修改这一行数据的事务 ID。另外一个是 roll_ptr，代表的是回滚指针。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 引擎通过回滚指针，将数据的不同版本串联在一起，也就是版本链。这些串联起来的历史版本，被放到了 undolog 里面。当某一个事务发起查询的时候，MVCC 会根据事务的隔离级别来生成不同的 Read View，从而控制事务查询最终得到的结果。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"MySQL 的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。\")]),_._v(\" \"),t(\"p\",[_._v(\"多版本并发控制（MVCC, Multi-Version Concurrency Control）是一种用于处理数据库并发操作的机制，它允许多个事务同时读取和写入数据，而\"),t(\"strong\",[_._v(\"不会互相阻塞\")]),_._v(\"。MVCC 通过为每个事务提供数据的不同版本来实现，并确保每个事务都能看到一致的数据快照\")]),_._v(\" \"),t(\"p\",[_._v(\"可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"核心概念\")])]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"快照读（Snapshot Read）\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"每个事务在开始时，会获取一个数据快照，事务在读取数据时，总是读取该快照中的数据。\")]),_._v(\" \"),t(\"li\",[_._v(\"这意味着即使在事务进行期间，其他事务对数据的更新也不会影响当前事务的读取。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"版本链（Version Chain）\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"每个数据行都有多个版本，每个版本包含数据和元数据（如创建时间、删除时间等）。\")]),_._v(\" \"),t(\"li\",[_._v(\"新版本的数据行会被链接到旧版本的数据行，形成一个版本链。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"隐式锁（Implicit Locking）\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"MVCC 通过版本管理避免了显式锁定，减少了锁争用问题。\")]),_._v(\" \"),t(\"li\",[_._v(\"对于读取操作，事务读取其开始时的快照数据，不会被写操作阻塞。\")])])])]),_._v(\" \"),t(\"p\",[_._v(\"MySQL InnoDB 存储引擎使用 MVCC 来实现可重复读（REPEATABLE READ）隔离级别，避免脏读、不可重复读和幻读问题。具体机制如下：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"隐藏列\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"InnoDB 在每行记录中存储两个隐藏列：\"),t(\"code\",[_._v(\"trx_id\")]),_._v(\"（事务ID，也叫做事务版本号）和\"),t(\"code\",[_._v(\"roll_pointer\")]),_._v(\"（回滚指针）。\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\"trx_id\")]),_._v(\" 记录最后一次修改该行的事务ID，\"),t(\"code\",[_._v(\"roll_pointer\")]),_._v(\" 指向该行的上一版本，把每一行的历史版本串联在一起。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"Undo日志\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"每次数据更新时，InnoDB 会在 Undo 日志中记录旧版本数据。\")]),_._v(\" \"),t(\"li\",[_._v(\"如果需要读取旧版本数据，InnoDB 会通过 \"),t(\"code\",[_._v(\"roll_pointer\")]),_._v(\" 找到 Undo 日志中的旧版本。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"一致性视图（Consistent Read View）\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"InnoDB 为每个事务创建一致性视图，记录当前活动的所有事务ID。\")]),_._v(\" \"),t(\"li\",[_._v(\"读取数据时，会根据一致性视图决定哪些版本的数据对当前事务可见。\")])])])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作\")]),_._v(\"。\")]),_._v(\" \"),t(\"blockquote\",[t(\"h4\",{attrs:{id:\"mvcc-解决了什么问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mvcc-解决了什么问题\"}},[_._v(\"#\")]),_._v(\" MVCC 解决了什么问题\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"读写不冲突，极大的增加了系统的并发性能\")]),_._v(\" \"),t(\"li\",[_._v(\"解决脏读，幻读，不可重复读 等问题（注:其实多版本只是解决不可重复读问题，而加上临界（\"),t(\"strong\",[_._v(\"next-key\")]),_._v(\"）锁(也就是它这里所谓的并发控制)才解决了幻读问题。）\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"InnoDB下的Compact行结构，有三个隐藏的列\")]),_._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[_._v(\"列名\")]),_._v(\" \"),t(\"th\",[_._v(\"是否必须\")]),_._v(\" \"),t(\"th\",[_._v(\"描述\")])])]),_._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[_._v(\"row_id\")]),_._v(\" \"),t(\"td\",[_._v(\"否\")]),_._v(\" \"),t(\"td\",[_._v(\"行ID，唯一标识一条记录（如果定义主键，它就没有啦）\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"transaction_id\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")]),_._v(\" \"),t(\"td\",[_._v(\"事务ID\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"roll_pointer\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")]),_._v(\" \"),t(\"td\",[_._v(\"DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本\")])])])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"在可重复读（Repeatable Read）隔离级别下，MySQL的InnoDB存储引擎通过多版本并发控制（MVCC）和next-key锁机制在很大程度上减少了幻读的发生，但并没有完全消除幻读的可能性。\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"快照读（Snapshot Read）\")]),_._v(\"：在可重复读隔离级别下，InnoDB使用MVCC来处理普通的SELECT查询。MVCC通过为每个事务创建一个Read View，使得事务在其执行期间看到的是一致的快照数据，即使其他事务在这段时间内插入了新记录，当前事务的查询也不会看到这些新记录。这通常可以避免幻读。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"当前读（Current Read）\")]),_._v(\"：对于需要锁定结果集的查询，如SELECT ... FOR UPDATE或SELECT ... IN SHARE MODE，InnoDB使用next-key锁，这是记录锁和间隙锁的组合。这种锁机制可以防止其他事务在锁定的范围内插入新记录，从而避免幻读。\")])]),_._v(\" \"),t(\"p\",[_._v(\"然而，根据搜索结果中的讨论，即使在可重复读隔离级别下，仍然存在一些特殊情况可能导致幻读：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"如果事务在执行快照读之后，立即执行更新操作，可能会看到其他事务插入的新记录，因为更新操作会检查最新版本的数据。\")]),_._v(\" \"),t(\"li\",[_._v(\"如果事务在执行当前读之前，其他事务已经提交了插入操作，那么当前读可能会观察到这些新记录。\")])]),_._v(\" \"),t(\"p\",[_._v(\"因此，虽然InnoDB的可重复读隔离级别提供了强有力的幻读保护，但在某些特殊情况下，幻读仍然可能发生。开发者需要了解这些情况，并在必要时采取额外的措施来确保数据的一致性和隔离性。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"版本链问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#版本链问题\"}},[_._v(\"#\")]),_._v(\" 版本链问题？\")]),_._v(\" \"),t(\"p\",[_._v(\"我现在有三个事务，ID 分别是 101、102、103。如果事务 101 已经提交了，但是 102、103 还没提交。这个时候，我开启了一个事务，准备读取数据，那么我读到的是哪个事务的数据？如果这时候事务 103 提交了，但是 102 还没提交，那么会读到谁的呢？\")]),_._v(\" \"),t(\"p\",[_._v(\"这种题，就和隔离级别有关系了。\")]),_._v(\" \"),t(\"p\",[_._v(\"在MVCC机制中，事务读取数据的可见性取决于事务的隔离级别和事务的开始时间。以下是根据你描述的情况，按照可重复读（Repeatable Read）隔离级别来分析：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"事务101已提交，事务102和103未提交时开启新事务读取数据\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"当你开启一个新的事务时，这个事务会创建一个Read View。Read View会根据事务的隔离级别来确定哪些数据版本是可见的。在可重复读隔离级别下，新事务的Read View将只能看到在该事务开始之前已经提交的事务所做的修改。因此，如果你的新事务是在事务102和103提交之前开启的，你将能够读取到事务101提交的数据，但是看不到事务102和103的修改。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"事务103提交后，但事务102还未提交时读取数据\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"如果在新事务的Read View创建之后，事务103提交了，那么在可重复读隔离级别下，新事务的Read View已经创建完成，它不会包含事务103提交后的数据。因此，即使你的新事务在事务103提交后读取数据，你仍然不会看到事务103的修改，除非你的新事务重新启动并创建一个新的Read View。\")])])])]),_._v(\" \"),t(\"p\",[_._v(\"在可重复读隔离级别下，新事务读取的数据版本是基于事务开始时数据库的快照，这个快照包括了所有在此之前已经提交的事务的修改。一旦Read View创建，即使其他事务提交了，新事务也不会看到这些新提交的修改，除非新事务重新启动并创建一个新的Read View。\")]),_._v(\" \"),t(\"p\",[_._v(\"需要注意的是，如果隔离级别是读已提交（Read Committed），情况会有所不同。在这种情况下，每次读取操作都会看到最新的提交事务的结果，所以如果事务103提交了，即使新事务已经开启，它在读取数据时也会看到事务103的修改。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"简单说下事务日志\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#简单说下事务日志\"}},[_._v(\"#\")]),_._v(\" 简单说下事务日志？\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。\")]),_._v(\" \"),t(\"p\",[_._v(\"事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 用日志把随机 IO 变成顺序 IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。\")]),_._v(\" \"),t(\"p\",[_._v(\"事务日志可以帮助提高事务效率：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。\")]),_._v(\" \"),t(\"li\",[_._v(\"事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。\")]),_._v(\" \"),t(\"li\",[_._v(\"事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。\")]),_._v(\" \"),t(\"li\",[_._v(\"如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。\")])]),_._v(\" \"),t(\"p\",[_._v(\"目前来说，大多数存储引擎都是这样实现的，我们通常称之为\"),t(\"strong\",[_._v(\"预写式日志\")]),_._v(\"（Write-Ahead Logging），修改数据需要写两次磁盘。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-事务的-acid-实现原理-事务的实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-事务的-acid-实现原理-事务的实现\"}},[_._v(\"#\")]),_._v(\" MySQL 事务的 ACID 实现原理？ | 事务的实现？\")]),_._v(\" \"),t(\"p\",[_._v(\"事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。\")]),_._v(\" \"),t(\"p\",[_._v(\"事务的实现就是如何实现 ACID 特性。\")]),_._v(\" \"),t(\"p\",[_._v(\"事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[t(\"strong\",[_._v(\"还看到一种说法\")]),_._v(\"：\")]),_._v(\" \"),t(\"p\",[_._v(\"从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说 ACID 四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"原子性保证：\"),t(\"code\",[_._v(\"undo log\")]),_._v(\" 名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"持久性保证：持久性主要通过 redo log 和数据文件的刷新（flush）来实现。InnoDB 存储引擎在事务提交时会将 redo log 写入到磁盘，确保更改可以被恢复\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"隔离性保证：MySQL 支持不同的事务隔离级别，隔离级别的实现依赖于锁机制和多版本并发控制（MVCC）。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"一致性保证：MySQL 通过约束（如主键、外键、检查约束等）、触发器和存储过程等来维护数据的完整性和一致性。\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"分布式事务相关问题，可能还会问到 2PC、3PC，，，\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-对分布式事务的支持\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-对分布式事务的支持\"}},[_._v(\"#\")]),_._v(\" MySQL 对分布式事务的支持\")]),_._v(\" \"),t(\"p\",[_._v(\"分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 从 5.0.3  InnoDB 存储引擎开始支持 XA 协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。\")]),_._v(\" \"),t(\"p\",[_._v(\"以下是 MySQL 对分布式事务支持的几个关键点：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"XA 事务\")]),_._v(\"：MySQL 的 InnoDB 存储引擎支持 XA 事务，这是分布式事务处理的基础。XA 事务允许跨多个数据库实例的事务操作，要么全部提交，要么全部回滚，以保持数据的一致性。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"两阶段提交\")]),_._v(\"：XA 事务使用两阶段提交协议来确保事务的原子性和一致性。在第一阶段，所有的参与资源（如不同的数据库实例）准备提交事务；在第二阶段，根据第一阶段的准备结果，决定是提交还是回滚事务。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"隔离级别\")]),_._v(\"：在使用 XA 事务时，InnoDB 存储引擎的事务隔离级别必须设置为 \"),t(\"code\",[_._v(\"SERIALIZABLE\")]),_._v(\"，这是最高的隔离级别，可以避免脏读、不可重复读和幻读。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"XA 语法\")]),_._v(\"：MySQL 支持 XA 事务的特定语法，包括 \"),t(\"code\",[_._v(\"XA START\")]),_._v(\"、\"),t(\"code\",[_._v(\"XA END\")]),_._v(\"、\"),t(\"code\",[_._v(\"XA PREPARE\")]),_._v(\"、\"),t(\"code\",[_._v(\"XA COMMIT\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"XA ROLLBACK\")]),_._v(\" 等命令，用于控制分布式事务的流程。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"事务管理器和资源管理器\")]),_._v(\"：在 XA 事务中，事务管理器（TM）负责协调全局事务，而资源管理器（RM）负责管理具体的事务资源，如数据库连接。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"分布式事务的问题\")]),_._v(\"：XA 事务可能面临一些问题，如超时、死锁和资源管理器故障等。此外，MySQL 中的 XA 事务在早期版本中存在一些限制，比如在服务器故障重启后，已准备的事务的二进制日志可能会丢失，导致主从复制的数据不一致问题。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"MySQL 5.7 改进\")]),_._v(\"：在 MySQL 5.7 版本中，对分布式事务的支持有所改进，解决了一些长期存在的问题，比如在客户端退出或服务宕机时，已准备的事务会被正确回滚，以及在服务器故障重启后，相应的 Binlog 被正确处理。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"应用场景\")]),_._v(\"：分布式事务在分布式架构或需要跨多个数据库系统进行数据同步的场景中比较常见，例如金融行业的转账操作。\")])]),_._v(\" \"),t(\"p\",[_._v(\"总的来说，MySQL 通过 XA 事务为分布式系统提供了强大的事务支持，确保了跨多个数据库实例的操作能够满足 ACID 原则。随着 MySQL 版本的更新，分布式事务的支持也在不断改进和增强。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"关于分布式事务，首先你需要弄清楚一个东西，就是分布式事务既可以是纯粹多个数据库实例之间的分布式事务，也可以是跨越不同中间件的业务层面上的分布式事务。前者一般是分库分表中间件提供支持，后者一般是独立的第三方中间件提供支持，比如 Seata。\")])]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"七、mysql-查询\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#七、mysql-查询\"}},[_._v(\"#\")]),_._v(\" 七、MySQL 查询\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"count-和-count-1-和count-列名-区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#count-和-count-1-和count-列名-区别\"}},[_._v(\"#\")]),_._v(\" count(*) 和 count(1)和count(列名)区别\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"COUNT(*)\")]),_._v(\"：统计表中所有行的数量，包括 \"),t(\"code\",[_._v(\"NULL\")]),_._v(\" 值，性能最佳，适用于需要统计总行数的情况\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"COUNT(1)\")]),_._v(\"：与 \"),t(\"code\",[_._v(\"COUNT(*)\")]),_._v(\" 类似，统计表中所有行的数量，包括 \"),t(\"code\",[_._v(\"NULL\")]),_._v(\" 值，性能与 \"),t(\"code\",[_._v(\"COUNT(*)\")]),_._v(\" 基本相同\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"COUNT(列名)\")]),_._v(\"：统计指定列中非 \"),t(\"code\",[_._v(\"NULL\")]),_._v(\" 值的数量，适用于需要统计特定列中实际值数量的情况\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"union和union-all的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#union和union-all的区别\"}},[_._v(\"#\")]),_._v(\" UNION和UNION ALL的区别?\")]),_._v(\" \"),t(\"p\",[_._v(\"UNION和UNION ALL都是将两个结果集合并为一个，\"),t(\"strong\",[_._v(\"两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"UNION 在进行表连接后会筛选掉重复的数据记录（效率较低），而 UNION ALL 则不会去掉重复的数据记录；\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"UNION 会按照字段的顺序进行排序，而 UNION ALL 只是简单的将两个结果合并就返回；\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"sql执行顺序\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sql执行顺序\"}},[_._v(\"#\")]),_._v(\" SQL执行顺序\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/ferrer_essential_guide_sql_execution_order_6.png\",alt:\"The Essential Guide to SQL’s Execution Order\"}})]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"手写\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT DISTINCT <select_list>\\nFROM  <left_table> <join_type>\\nJOIN  <right_table> ON <join_condition>\\nWHERE  <where_condition>\\nGROUP BY  <group_by_list>\\nHAVING <having_condition>\\nORDER BY <order_by_condition>\\nLIMIT <limit_number>\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"机读\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"FROM  <left_table>\\nON <join_condition>\\n<join_type> JOIN  <right_table> \\nWHERE  <where_condition>\\nGROUP BY  <group_by_list>\\nHAVING <having_condition>\\nSELECT\\nDISTINCT <select_list>\\nORDER BY <order_by_condition>\\nLIMIT <limit_number>\\n\")])])])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"mysql 的内连接、左连接、右连接有什么区别？\")]),_._v(\" \"),t(\"p\",[_._v(\"什么是内连接、外连接、交叉连接、笛卡尔积呢？\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"join图\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#join图\"}},[_._v(\"#\")]),_._v(\" Join图\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/sql-joins.jpg\",alt:\"sql-joins\"}})]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"八、mysql-锁机制\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#八、mysql-锁机制\"}},[_._v(\"#\")]),_._v(\" 八、MySQL 锁机制\")]),_._v(\" \"),t(\"p\",[_._v(\"锁是计算机协调多个进程或线程并发访问某一资源的机制。\")]),_._v(\" \"),t(\"p\",[_._v(\"在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。\")]),_._v(\" \"),t(\"p\",[_._v(\"打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。\")]),_._v(\" \"),t(\"p\",[_._v(\"在 MySQL 的 InnoDB 引擎里面，锁是借助索引来实现的。或者说，加锁锁住的其实是索引项，更加具体地来说，就是锁住了\"),t(\"strong\",[_._v(\"叶子节点\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-中有哪几种锁-列举一下\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-中有哪几种锁-列举一下\"}},[_._v(\"#\")]),_._v(\" MySQL 中有哪几种锁，列举一下？\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"从对数据操作的类型分类\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"读锁\")]),_._v(\"（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"写锁\")]),_._v(\"（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁\")])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"从对数据操作的粒度分类\")]),_._v(\"：\")]),_._v(\" \"),t(\"p\",[_._v(\"为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"表级锁\")]),_._v(\"：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"行级锁\")]),_._v(\"：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"页面锁\")]),_._v(\"：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。\")]),_._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\"),_._v(\" \"),t(\"th\",[_._v(\"行锁\")]),_._v(\" \"),t(\"th\",[_._v(\"表锁\")]),_._v(\" \"),t(\"th\",[_._v(\"页锁\")])])]),_._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[_._v(\"MyISAM\")]),_._v(\" \"),t(\"td\"),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\")]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"BDB\")]),_._v(\" \"),t(\"td\"),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\",[_._v(\"√\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"InnoDB\")]),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\")]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"Memory\")]),_._v(\" \"),t(\"td\"),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"h5\",{attrs:{id:\"myisam-表锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#myisam-表锁\"}},[_._v(\"#\")]),_._v(\" MyISAM 表锁\")]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM 的表锁有两种模式：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；\")]),_._v(\" \"),t(\"li\",[_._v(\"表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；\")])]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。\")]),_._v(\" \"),t(\"p\",[_._v(\"默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"innodb-行锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#innodb-行锁\"}},[_._v(\"#\")]),_._v(\" InnoDB 行锁\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 实现了以下两种类型的\"),t(\"strong\",[_._v(\"行锁\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"共享锁又称为读锁，简称  S 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"排他锁又称为写锁，简称 X 锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是\"),t(\"strong\",[_._v(\"表锁\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。\")]),_._v(\" \"),t(\"li\",[_._v(\"意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"索引失效会导致行锁变表锁\")]),_._v(\"。比如 varchar 查询不写单引号的情况。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁\")]),_._v(\"。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-中-innodb-引擎的行锁是怎么实现的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-中-innodb-引擎的行锁是怎么实现的\"}},[_._v(\"#\")]),_._v(\" MySQL 中 InnoDB 引擎的行锁是怎么实现的？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"锁模式(InnoDB有三种行锁的算法)\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"记录锁(Record Locks)\")]),_._v(\"： 单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM table WHERE id = 1 FOR UPDATE;\\n\")])])]),t(\"p\",[_._v(\"它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行\")]),_._v(\" \"),t(\"p\",[_._v(\"在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"-- id 列为主键列或唯一索引列\\nUPDATE SET age = 50 WHERE id = 1;\\n\")])])]),t(\"p\",[_._v(\"但是如果查询条件没有命中任何记录，那么就不会使用记录锁，而是使用间隙锁。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"间隙锁（Gap Locks）\")]),_._v(\"： 当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。\")]),_._v(\" \"),t(\"p\",[_._v(\"对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。\")]),_._v(\" \"),t(\"p\",[_._v(\"间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的\"),t(\"code\",[_._v(\"Next-Key Locking\")]),_._v(\" 算法，请务必牢记：\"),t(\"strong\",[_._v(\"使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据\")]),_._v(\"。\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;\\n\")])])]),t(\"p\",[_._v(\"即所有在\"),t(\"code\",[_._v(\"（1，10）\")]),_._v(\"区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。\")]),_._v(\" \"),t(\"p\",[_._v(\"GAP 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"临键锁(Next-key Locks)\")]),_._v(\"： \"),t(\"strong\",[_._v(\"临键锁\")]),_._v(\"，是\"),t(\"strong\",[_._v(\"记录锁与间隙锁的组合\")]),_._v(\"，它的封锁范围，既包含索引记录，又包含索引区间。(临键锁的主要目的，也是为了避免\"),t(\"strong\",[_._v(\"幻读\")]),_._v(\"(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。)\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM table WHERE id BETWEEN 50 AND 100 FOR UPDATE\\n\")])])]),t(\"p\",[_._v(\"Next-Key 可以理解为一种特殊的\"),t(\"strong\",[_._v(\"间隙锁\")]),_._v(\"，也可以理解为一种特殊的\"),t(\"strong\",[_._v(\"算法\")]),_._v(\"。通过\"),t(\"strong\",[_._v(\"临建锁\")]),_._v(\"可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，\"),t(\"mark\",[t(\"code\",[_._v(\"InnoDB\")]),_._v(\" 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"对于行的查询，都是采用该方法，主要目的是解决幻读的问题。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"间隙锁和临键锁是在可重复读的隔离级别下才有效果的\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-隔离级别与锁的关系\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-隔离级别与锁的关系\"}},[_._v(\"#\")]),_._v(\" MySQL 隔离级别与锁的关系？\")]),_._v(\" \"),t(\"p\",[_._v(\"在 MySQL 中，隔离级别和锁的关系紧密相关，不同的隔离级别通过使用不同的锁机制来控制事务间的并发行为，确保数据的一致性和隔离性。以下是 MySQL 四种隔离级别与锁的关系：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"读未提交（Read Uncommitted）\")])])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"锁机制：最低级别，不使用锁，允许读取未提交的数据。\")]),_._v(\" \"),t(\"li\",[_._v(\"并发性：高。\")]),_._v(\" \"),t(\"li\",[_._v(\"数据一致性：低，可能导致脏读。\")])]),_._v(\" \"),t(\"ol\",{attrs:{start:\"2\"}},[t(\"li\",[t(\"strong\",[_._v(\"读已提交（Read Committed）\")])])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"锁机制：读取时使用共享锁（S Lock），更新时使用排他锁（X Lock）。\")]),_._v(\" \"),t(\"li\",[_._v(\"并发性：中等。\")]),_._v(\" \"),t(\"li\",[_._v(\"数据一致性：避免脏读，但可能发生不可重复读。\")])]),_._v(\" \"),t(\"ol\",{attrs:{start:\"3\"}},[t(\"li\",[t(\"strong\",[_._v(\"可重复读（Repeatable Read）\")])])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"锁机制：读取时使用共享锁（S Lock），更新时使用排他锁（X Lock），并使用间隙锁（Gap Lock）防止幻读。\")]),_._v(\" \"),t(\"li\",[_._v(\"并发性：较低。\")]),_._v(\" \"),t(\"li\",[_._v(\"数据一致性：避免脏读和不可重复读，但在默认设置下防止幻读。\")])]),_._v(\" \"),t(\"ol\",{attrs:{start:\"4\"}},[t(\"li\",[t(\"strong\",[_._v(\"串行化（Serializable）\")])])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"锁机制：事务间完全隔离，所有读取和写入都使用表级锁或行级锁，确保完全隔离。\")]),_._v(\" \"),t(\"li\",[_._v(\"并发性：最低。\")]),_._v(\" \"),t(\"li\",[_._v(\"数据一致性：最高，避免所有并发问题。\")])]),_._v(\" \"),t(\"p\",[_._v(\"选择适当的隔离级别和锁机制，可以在数据一致性和系统并发性之间找到最佳平衡。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"在高并发情况下-如何做到安全的修改同一行数据\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在高并发情况下-如何做到安全的修改同一行数据\"}},[_._v(\"#\")]),_._v(\" 在高并发情况下，如何做到安全的修改同一行数据？\")]),_._v(\" \"),t(\"p\",[_._v(\"在高并发情况下安全地修改同一行数据需要确保数据的一致性和完整性，避免并发导致的问题，如脏读、不可重复读和幻读。以下是一些常见的策略：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"乐观锁\")]),_._v(\"：乐观锁通过在数据表中添加一个版本号或时间戳字段来实现。每次更新数据时，检查版本号或时间戳是否一致，如果不一致，说明数据在读取后被其他事务修改过，当前事务应该放弃更新。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"悲观锁\")]),_._v(\"：悲观锁在事务开始时就对数据行进行锁定，直到事务结束才释放锁。这可以防止其他事务同时修改同一数据行。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"原子操作\")]),_._v(\"：使用数据库提供的原子操作，如 \"),t(\"code\",[_._v(\"UPDATE ... WHERE\")]),_._v(\" 语句，确保修改操作的原子性。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"事务隔离级别\")]),_._v(\"：适当设置事务的隔离级别，如可重复读（REPEATABLE READ）或串行化（SERIALIZABLE），以减少并发事务间的干扰。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"数据库的锁机制\")]),_._v(\"：利用数据库的锁机制，如行锁、表锁等，来控制对数据的并发访问。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"应用层控制\")]),_._v(\"：在应用层实现重试逻辑，当检测到更新冲突时，可以重试事务。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"分布式锁\")]),_._v(\"：使用分布式锁来确保在分布式系统中，同一时间只有一个操作能够修改数据。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"消息队列\")]),_._v(\"：将更新操作封装在消息中，通过消息队列顺序处理更新，以避免并发冲突。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"唯一索引\")]),_._v(\"：在可能发生冲突的列上设置唯一索引，确保数据库层面上避免重复数据的插入。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"条件更新\")]),_._v(\"：使用条件更新，如 \"),t(\"code\",[_._v(\"UPDATE ... IF EXISTS\")]),_._v(\"，来避免在数据已被其他事务修改的情况下进行更新。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"数据库的乐观锁和悲观锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据库的乐观锁和悲观锁\"}},[_._v(\"#\")]),_._v(\" 数据库的乐观锁和悲观锁？\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题\")])]),_._v(\" \"),t(\"p\",[_._v(\"乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式\")]),_._v(\" \"),t(\"p\",[_._v(\"悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，\"),t(\"strong\",[_._v(\"悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"怎么在数据库里面使用乐观锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#怎么在数据库里面使用乐观锁\"}},[_._v(\"#\")]),_._v(\" 怎么在数据库里面使用乐观锁？\")]),_._v(\" \"),t(\"p\",[_._v(\"乐观锁（Optimistic Locking）是一种用于解决并发控制问题的技术，特别适用于读多写少的场景。它假设冲突很少发生，因此不在操作开始时加锁，而是在提交更新时检查是否有冲突。通常通过以下几种方式实现：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"版本号：在表中添加一个版本号字段，每次更新记录时，版本号加1。更新操作时，检查版本号是否匹配，匹配则更新，不匹配则说明有冲突，需要重新读取数据再进行操作。\")]),_._v(\" \"),t(\"li\",[_._v(\"时间戳：用时间戳字段记录最后修改时间，更新操作时检查时间戳是否匹配。\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"可以用来解决电商中的“超卖”问题。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"select-for-update有什么含义-会锁表还是锁行还是其他\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#select-for-update有什么含义-会锁表还是锁行还是其他\"}},[_._v(\"#\")]),_._v(\" select for update有什么含义，会锁表还是锁行还是其他？\")]),_._v(\" \"),t(\"p\",[_._v(\"for update 仅适用于 InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL  会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！\")]),_._v(\" \"),t(\"p\",[_._v(\"假设有个表单 products ，里面有 id 跟 name 二个栏位，id 是主键。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"明确指定主键，并且有此笔资料，row lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE id='3' FOR UPDATE;\\nSELECT * FROM products WHERE id='3' and type=1 FOR UPDATE;\\n\")])])]),t(\"ul\",[t(\"li\",[_._v(\"明确指定主键，若查无此笔资料，无lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE id='-1' FOR UPDATE;\\n\")])])]),t(\"ul\",[t(\"li\",[_._v(\"无主键，table lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE name='Mouse' FOR UPDATE;\\n\")])])]),t(\"ul\",[t(\"li\",[_._v(\"主键不明确，table lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE id <>'3' FOR UPDATE;\\n\")])])]),t(\"ul\",[t(\"li\",[_._v(\"主键不明确，table lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;\\n\")])])]),t(\"p\",[t(\"strong\",[_._v(\"注1\")]),_._v(\": FOR UPDATE 仅适用于 InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。\\n\"),t(\"strong\",[_._v(\"注2\")]),_._v(\": 要测试锁定的状况，可以利用 MySQL 的 Command Mode ，开二个视窗来做测试。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"死锁有没有了解-写一段会造成死锁的-sql-语句\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁有没有了解-写一段会造成死锁的-sql-语句\"}},[_._v(\"#\")]),_._v(\" 死锁有没有了解，写一段会造成死锁的 sql 语句?\")]),_._v(\" \"),t(\"p\",[_._v(\"死锁是指两个或多个事务在等待彼此持有的资源，从而导致所有事务都无法继续执行的情况。在 MySQL 中，死锁通常发生在并发更新相同的资源时。\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"START TRANSACTION;\\nUPDATE table_name SET column_a = 1 WHERE id = 1;\\n-- 这里事务 1 锁定了 id = 1 的记录\\nUPDATE table_name SET column_b = 2 WHERE id = 2;\\n-- 等待事务 2 释放 id = 2 的锁\\n\")])])]),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"START TRANSACTION;\\nUPDATE table_name SET column_b = 2 WHERE id = 2;\\n-- 这里事务 2 锁定了 id = 2 的记录\\nUPDATE table_name SET column_a = 1 WHERE id = 1;\\n-- 等待事务 1 释放 id = 1 的锁\\n\")])])]),t(\"h3\",{attrs:{id:\"死锁发生了如何解决-mysql-有没有提供什么机制去解决死锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁发生了如何解决-mysql-有没有提供什么机制去解决死锁\"}},[_._v(\"#\")]),_._v(\" 死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"MySQL 遇到过死锁问题吗，你是如何解决的？\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"死锁产生\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环\")]),_._v(\" \"),t(\"li\",[_._v(\"当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁\")]),_._v(\" \"),t(\"li\",[_._v(\"锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"死锁产生的四个必要条件\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"互斥： 多个线程不能同时使用一个资源。比如线程 A 已经持有的资源，不能再同时被线程 B 持有。\")]),_._v(\" \"),t(\"li\",[_._v(\"持有并等待： 当线程 A 已经持有了资源 1，又提出申请资源 2，但是资源 2 已经被线程 C 占用，所以线程 A 就会处于等待状态，但它在等待资源 2 的同时并不会释放自己已经获取的资源 1。\")]),_._v(\" \"),t(\"li\",[_._v(\"不可剥夺： 线程 A 获取到资源 1 之后，在自己使用完之前不能被其他线程（比如线程 B）抢占使用。如果线程 B 也想使用资源 1，只能在线程 A 使用完后，主动释放后再获取\")]),_._v(\" \"),t(\"li\",[_._v(\"循环等待： 发生死锁时，必然会存在一个线程，也就是资源的环形链。比如线程 A 已经获取了资源 1，但同时又请求获取资源 2。线程 B 已经获取了资源 2，但同时又请求获取资源 1，这就会形成一个线程和资源请求等待的环形图。\")])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"检测死锁\")]),_._v(\"：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB 存储引擎能检测到死锁的循环依赖并立即返回一个错误。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"死锁恢复\")]),_._v(\"：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，\"),t(\"strong\",[_._v(\"InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚\")]),_._v(\"。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"外部锁的死锁检测\")]),_._v(\"：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"死锁影响性能\")]),_._v(\"：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖\"),t(\"code\",[_._v(\"innodb_lock_wait_timeout\")]),_._v(\"设置进行事务回滚。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"如何尽可能避免死锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何尽可能避免死锁\"}},[_._v(\"#\")]),_._v(\" 如何尽可能避免死锁？\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"合理的设计索引，区分度高的列放到组合索引前面，使业务 SQL 尽可能通过索引\"),t(\"code\",[_._v(\"定位更少的行，减少锁竞争\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[_._v(\"调整业务逻辑 SQL 执行顺序， 避免 update/delete 长时间持有锁的 SQL 在事务前面。\")]),_._v(\" \"),t(\"li\",[_._v(\"避免\"),t(\"code\",[_._v(\"大事务\")]),_._v(\"，尽量将大事务拆成多个小事务来处理，小事务发生锁冲突的几率也更小。\")]),_._v(\" \"),t(\"li\",[_._v(\"以\"),t(\"code\",[_._v(\"固定的顺序\")]),_._v(\"访问表和行。比如两个更新数据的事务，事务 A 更新数据的顺序为 1，2;事务 B 更新数据的顺序为 2，1。这样更可能会造成死锁。\")]),_._v(\" \"),t(\"li\",[_._v(\"在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select … for update 语句，如果是在事务里\"),t(\"code\",[_._v(\"（运行了 start transaction 或设置了autocommit 等于0）\")]),_._v(\",那么就会锁定所查找到的记录。\")]),_._v(\" \"),t(\"li\",[_._v(\"尽量按\"),t(\"code\",[_._v(\"主键/索引\")]),_._v(\"去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外额度计算工作。比如有的程序会用到 “select … where … order by rand();”这样的语句，由于类似这样的语句用不到索引，因此将导致整个表的数据都被锁住。\")]),_._v(\" \"),t(\"li\",[_._v(\"优化 SQL 和表设计，减少同时占用太多资源的情况。比如说，\"),t(\"code\",[_._v(\"减少连接的表\")]),_._v(\"，将复杂 SQL \"),t(\"code\",[_._v(\"分解\")]),_._v(\"为多个简单的 SQL。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说个自己遇到的死锁案例\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说个自己遇到的死锁案例\"}},[_._v(\"#\")]),_._v(\" 说个自己遇到的死锁案例？\")]),_._v(\" \"),t(\"p\",[_._v(\"早期我优化过一个死锁问题，是\"),t(\"strong\",[_._v(\"临键锁引起\")]),_._v(\"的。业务逻辑很简单，先用 SELECT FOR UPDATE 查询数据。如果查询到了数据，那么就执行一段业务逻辑，然后更新结果；如果没有查询到，那么就执行另外一段业务逻辑，然后插入计算结果。\")]),_._v(\" \"),t(\"p\",[_._v(\"那么如果 SELECT FOR UPDATE 查找的数据不存在，那么数据库会使用一个临键锁。此时，如果有两个线程加了临键锁，然后又希望插入计算结果，那么就会造成死锁。\")]),_._v(\" \"),t(\"p\",[_._v(\"我这个优化也很简单，就是上来先不管三七二十一，直接插入数据。如果插入成功，那么就执行没有数据的逻辑，此时不会再持有临键锁，而是持有了行锁。如果插入不成功，那么就执行有数据的业务逻辑。\")]),_._v(\" \"),t(\"p\",[_._v(\"此外，还有两个思路。一个是修改数据库的隔离级别为 RC，那么自然不存在临键锁了，但是这个修改影响太大，被 DBA 否决了。\")]),_._v(\" \"),t(\"p\",[_._v(\"另外一个思路就是使用乐观锁，不过代码改起来要更加复杂，所以就没有使用。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"假设表 t 中最大 id 是 10，那么如果两个业务进来，同时执行这个逻辑。一个准备插入 id=11 的数据，一个准备插入 id = 12 的数据。如果它们的执行时序如下图，那么你就会得到一个死锁错误\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/MySQL-dead-lock-demo-1.png\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"造成死锁的原因也很简单。在线程 A 执行 SELECT FOR UPDATE 的时候，因为 id=11 的数据不存在，所以实际上数据库会产生一个(11，supremum] 的临键锁。类似地，线程 B 也会产生一个(10，supremum] 临键锁。\")])]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"九、mysql-调优\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#九、mysql-调优\"}},[_._v(\"#\")]),_._v(\" 九、MySQL 调优\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"影响-mysql-的性能因素有哪些\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#影响-mysql-的性能因素有哪些\"}},[_._v(\"#\")]),_._v(\" 影响  mysql 的性能因素有哪些?\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"业务需求对MySQL的影响(合适合度)\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"存储定位对MySQL的影响\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"不适合放进MySQL的数据\\n\"),t(\"ul\",[t(\"li\",[_._v(\"二进制多媒体数据\")]),_._v(\" \"),t(\"li\",[_._v(\"流水队列数据\")]),_._v(\" \"),t(\"li\",[_._v(\"超大文本数据\")])])]),_._v(\" \"),t(\"li\",[_._v(\"需要放进缓存的数据\\n\"),t(\"ul\",[t(\"li\",[_._v(\"系统各种配置及规则数据\")]),_._v(\" \"),t(\"li\",[_._v(\"活跃用户的基本信息数据\")]),_._v(\" \"),t(\"li\",[_._v(\"活跃用户的个性化定制信息数据\")]),_._v(\" \"),t(\"li\",[_._v(\"准实时的统计信息数据\")]),_._v(\" \"),t(\"li\",[_._v(\"其他一些访问频繁但变更较少的数据\")])])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"Schema设计对系统的性能影响\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"尽量减少对数据库访问的请求\")]),_._v(\" \"),t(\"li\",[_._v(\"尽量减少无用数据的查询请求\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"硬件环境对系统性能的影响\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"日常工作中你是怎么优化sql的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#日常工作中你是怎么优化sql的\"}},[_._v(\"#\")]),_._v(\" 日常工作中你是怎么优化SQL的？\")]),_._v(\" \"),t(\"p\",[_._v(\"优化SQL的日常工作可以从以下几个方面进行：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"索引优化\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"创建索引\")]),_._v(\"：为频繁查询的列创建合适的索引，特别是主键和外键列。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"使用覆盖索引\")]),_._v(\"：通过索引来满足查询需求，避免回表查询。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"删除冗余索引\")]),_._v(\"：清理不常用或重复的索引，以减少维护开销。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"查询优化\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"避免选择所有列\")]),_._v(\"：只选择需要的列，避免使用 \"),t(\"code\",[_._v(\"SELECT *\")]),_._v(\"。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"使用合适的SQL语法\")]),_._v(\"：如使用 \"),t(\"code\",[_._v(\"JOIN\")]),_._v(\" 替代子查询，避免N+1查询问题。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"优化WHERE子句\")]),_._v(\"：使用索引列进行过滤，避免在过滤条件中进行函数运算或转换。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"数据库结构优化\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"规范化与反规范化\")]),_._v(\"：根据实际需求选择合适的数据库设计，平衡数据冗余和查询性能。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"分区表\")]),_._v(\"：对于大表，使用分区技术来提升查询和维护性能。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"缓存机制\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"应用层缓存\")]),_._v(\"：如Memcached或Redis，缓存频繁访问的数据，减少数据库负载。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"数据库缓存\")]),_._v(\"：合理设置数据库缓存参数，优化数据库内存使用。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"SQL分析与监控\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"执行计划分析\")]),_._v(\"：使用 \"),t(\"code\",[_._v(\"EXPLAIN\")]),_._v(\" 分析SQL的执行计划，了解查询的执行步骤和时间。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"慢查询日志\")]),_._v(\"：启用慢查询日志，找出并优化执行时间较长的SQL语句。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"性能监控工具\")]),_._v(\"：如使用New Relic、APM等工具，持续监控数据库性能。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"事务控制\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"减少事务范围\")]),_._v(\"：尽量缩小事务的范围和持续时间，避免长时间锁定资源。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"合理设置隔离级别\")]),_._v(\"：根据业务需求选择合适的事务隔离级别，平衡并发性和数据一致性。\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"数据库参数调整\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"调整连接池\")]),_._v(\"：合理设置数据库连接池大小，避免过多连接导致资源争用。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"优化数据库配置\")]),_._v(\"：根据硬件资源和业务需求，调整数据库内存、缓存、IO等参数。\")])])])])]),_._v(\" \"),t(\"p\",[_._v(\"通过以上方法，可以有效地优化SQL性能，提高数据库的响应速度和稳定性。持续关注数据库的运行情况，并根据实际需求进行调整，是保持数据库高效运行的关键。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"什么是最左前缀原则-什么是最左匹配原则\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是最左前缀原则-什么是最左匹配原则\"}},[_._v(\"#\")]),_._v(\" 什么是最左前缀原则？什么是最左匹配原则？\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"最左前缀原则\")]),_._v(\" 和 \"),t(\"strong\",[_._v(\"最左匹配原则\")]),_._v(\" 是在使用索引时的两个相关概念，它们通常与复合索引（即在多个列上创建的索引）的使用相关：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"最左前缀原则\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"当使用复合索引时，最左前缀原则指的是查询优化器只会使用复合索引中最左边的列（或前几列）来查找数据。\")]),_._v(\" \"),t(\"li\",[_._v(\"这意味着，如果要利用复合索引，查询条件中必须包含最左边的列。如果查询条件不包含最左边的列，那么索引将不会被使用，或者不会完全被使用。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"最左匹配原则\")]),_._v(\"：\\n\"),t(\"ul\",[t(\"li\",[_._v(\"最左匹配原则是指在复合索引中，只有当前面的列匹配后，才能继续向后匹配。换句话说，只有当前一个列的值已经确定，才能利用下一个列的索引。\")]),_._v(\" \"),t(\"li\",[_._v(\"例如，如果你有一个 (\"),t(\"code\",[_._v(\"col1\")]),_._v(\", \"),t(\"code\",[_._v(\"col2\")]),_._v(\", \"),t(\"code\",[_._v(\"col3\")]),_._v(\") 的复合索引，那么只有当 \"),t(\"code\",[_._v(\"col1\")]),_._v(\" 的值确定后，\"),t(\"code\",[_._v(\"col2\")]),_._v(\" 的索引才会被使用；同样，只有当 \"),t(\"code\",[_._v(\"col1\")]),_._v(\" 和 \"),t(\"code\",[_._v(\"col2\")]),_._v(\" 的值都确定后，\"),t(\"code\",[_._v(\"col3\")]),_._v(\" 的索引才会被使用。\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql常见性能分析手段\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql常见性能分析手段\"}},[_._v(\"#\")]),_._v(\" MySQL常见性能分析手段？\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"MySQL Query Optimizer\")])]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimizer 时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。\")])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"MySQL常见瓶颈\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"CPU：CPU 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"IO：磁盘 I/O 瓶颈发生在装入数据远大于内存容量的时候\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"服务器硬件的性能瓶颈：top，free，iostat 和 vmstat 来查看系统的性能状态\")])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"性能下降SQL慢 执行时间长 等待时间长 原因分析\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"查询语句写的烂\")]),_._v(\" \"),t(\"li\",[_._v(\"索引失效（单值、复合）\")]),_._v(\" \"),t(\"li\",[_._v(\"关联查询太多 join（设计缺陷或不得已的需求）\")]),_._v(\" \"),t(\"li\",[_._v(\"服务器调优及各个参数设置（缓冲、线程数等）\")])]),_._v(\" \"),t(\"p\",[_._v(\"在优化 MySQL 时，通常需要对数据库进行分析，常见的分析手段有\"),t(\"strong\",[_._v(\"慢查询日志\")]),_._v(\"，\"),t(\"strong\",[_._v(\"EXPLAIN 分析查询\")]),_._v(\"，\"),t(\"strong\",[_._v(\"profiling分析\")]),_._v(\"以及\"),t(\"strong\",[_._v(\"show命令查询系统状态及系统变量\")]),_._v(\"，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"性能瓶颈定位\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#性能瓶颈定位\"}},[_._v(\"#\")]),_._v(\" 性能瓶颈定位\")]),_._v(\" \"),t(\"p\",[_._v(\"我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"Mysql> show status ——显示状态信息（扩展show status like ‘XXX’）\\n\\nMysql> show variables ——显示系统变量（扩展show variables like ‘XXX’）\\n\\nMysql> show innodb status ——显示InnoDB存储引擎的状态\\n\\nMysql> show processlist ——查看当前SQL执行，包括执行状态、是否锁表等\\n\\nShell> mysqladmin variables -u username -p password——显示系统变量\\n\\nShell> mysqladmin extended-status -u username -p password——显示状态信息\\n\")])])]),t(\"h3\",{attrs:{id:\"怎么看执行计划-explain-如何理解其中各个字段的含义\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#怎么看执行计划-explain-如何理解其中各个字段的含义\"}},[_._v(\"#\")]),_._v(\" 怎么看执行计划（explain），如何理解其中各个字段的含义？\")]),_._v(\" \"),t(\"p\",[_._v(\"使用 \"),t(\"strong\",[_._v(\"Explain\")]),_._v(\" 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈\")]),_._v(\" \"),t(\"p\",[_._v(\"各字段解释\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"id\")])]),_._v(\"（select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序）\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"id 相同，执行顺序从上往下\")]),_._v(\" \"),t(\"li\",[_._v(\"id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行\")]),_._v(\" \"),t(\"li\",[_._v(\"id 相同不同，同时存在，相同的属于一组，从上往下执行\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"select_type\")])]),_._v(\"（查询的类型，用于区别普通查询、联合查询、子查询等复杂查询）\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"SIMPLE\")]),_._v(\" ：简单的 select 查询，查询中不包含子查询或 UNION\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"PRIMARY\")]),_._v(\"：查询中若包含任何复杂的子部分，最外层查询被标记为 PRIMARY\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"SUBQUERY\")]),_._v(\"：在 select 或 where 列表中包含了子查询\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"DERIVED\")]),_._v(\"：在 from 列表中包含的子查询被标记为 DERIVED，mysql 会递归执行这些子查询，把结果放在临时表里\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"UNION\")]),_._v(\"：若第二个 select 出现在 UNION 之后，则被标记为 UNION，若 UNION 包含在 from 子句的子查询中，外层 select 将被标记为 DERIVED\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"UNION RESULT\")]),_._v(\"：从 UNION 表获取结果的 select\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"table\")])]),_._v(\"（显示这一行的数据是关于哪张表的）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"partitions\")])]),_._v(\"（匹配的分区信息，高版本才有的）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"type\")])]),_._v(\"（显示查询使用了那种类型，从最好到最差依次排列 \"),t(\"strong\",[_._v(\"system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL\")]),_._v(\" ）\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现\")]),_._v(\" \"),t(\"li\",[_._v(\"const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量\")]),_._v(\" \"),t(\"li\",[_._v(\"eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描\")]),_._v(\" \"),t(\"li\",[_._v(\"ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体\")]),_._v(\" \"),t(\"li\",[_._v(\"ref_or_null：当对普通二级索引进行等值匹配查询，该索引列的值也可以是\"),t(\"code\",[_._v(\"NULL\")]),_._v(\"值时，那么对该表的访问方法就可能是ref_or_null\")]),_._v(\" \"),t(\"li\",[_._v(\"index_merge: 在某些场景下可以使用\"),t(\"code\",[_._v(\"Intersection\")]),_._v(\"、\"),t(\"code\",[_._v(\"Union\")]),_._v(\"、\"),t(\"code\",[_._v(\"Sort-Union\")]),_._v(\"这三种索引合并的方式来执行查询\")]),_._v(\" \"),t(\"li\",[_._v(\"range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的 where 语句中出现了between、<、>、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引\")]),_._v(\" \"),t(\"li\",[_._v(\"index：Full Index Scan，index 于 ALL 区别为 index 类型只遍历索引树。通常比 ALL 快，因为索引文件通常比数据文件小。（\"),t(\"strong\",[_._v(\"也就是说虽然 all 和 index 都是读全表，但 index 是从索引中读取的，而 all 是从硬盘中读的\")]),_._v(\"）\")]),_._v(\" \"),t(\"li\",[_._v(\"all：Full Table Scan，将遍历全表找到匹配的行\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"一般来说，得保证查询至少达到 range 级别，最好到达 ref\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"possible_keys\")])]),_._v(\"（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"key\")])])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"实际使用的索引，如果为NULL，则没有使用索引\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"查询中若指定了使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在 key 列表中\")]),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/explain-key.png\",alt:\"\"}})])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"key_len\")])])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好\")]),_._v(\" \"),t(\"li\",[_._v(\"key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"ref\")])]),_._v(\" （显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/explain-ref.png\",alt:\"\"}})])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"rows\")])]),_._v(\" （根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"filtered\")])]),_._v(\"（某个表经过搜索条件过滤后剩余记录条数的百分比）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"Extra\")])]),_._v(\"（包含不适合在其他列中显示但十分重要的额外信息）\")]),_._v(\" \"),t(\"p\",[_._v(\"额外信息有好几十个，我们看几个常见的\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[t(\"font\",{attrs:{color:\"red\"}},[t(\"code\",[_._v(\"using filesort\")])]),_._v(\"：说明 MySQL 会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/explain-extra-using-filesort.png\",alt:\"\"}})],1)]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"font\",{attrs:{color:\"red\"}},[t(\"code\",[_._v(\"Using temporary\")])]),_._v(\"：使用了临时表保存中间结果，比如去重、排序之类的，比如我们在执行许多包含\"),t(\"code\",[_._v(\"DISTINCT\")]),_._v(\"、\"),t(\"code\",[_._v(\"GROUP BY\")]),_._v(\"、\"),t(\"code\",[_._v(\"UNION\")]),_._v(\"等子句的查询过程中，如果不能有效利用索引来完成查询，\"),t(\"code\",[_._v(\"MySQL\")]),_._v(\"很有可能寻求通过建立内部的临时表来执行查询。\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/explain-extra-using-tmp.png\",alt:\"\"}})],1)]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"font\",{attrs:{color:\"red\"}},[t(\"code\",[_._v(\"using index\")])]),_._v(\"：表示相应的 select 操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现 \"),t(\"code\",[_._v(\"using where\")]),_._v(\"，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/explain-extra-using-index.png\",alt:\"\"}})],1)]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\"using where\")]),_._v(\"：当某个搜索条件需要在\"),t(\"code\",[_._v(\"server层\")]),_._v(\"进行判断时\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/explain-extra-using-where.png\",alt:\"\"}})])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\"using join buffer\")]),_._v(\"：使用了连接缓存\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/explain-extra-using-join-buffer.png\",alt:\"\"}})])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\"impossible where\")]),_._v(\"：where 子句的值总是 false，不能用来获取任何元祖\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/explain-extra-impossible-where.png\",alt:\"\"}})])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\"Using index condition\")]),_._v(\" : 查询使用了索引，但是查询条件不能完全由索引本身来满足\"),t(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/explain-extra-using-index-condition.png\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"Using index condition\")]),_._v(\"通常出现在以下几种情况：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"索引条件下推（Index Condition Pushdown, ICP）\")]),_._v(\"：这是 MySQL 的一个优化策略，它将查询条件的过滤逻辑“下推”到存储引擎层，而不是在服务器层处理。这样可以减少从存储引擎检索的数据量，从而提高查询效率。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"部分索引\")]),_._v(\"：当查询条件只涉及索引的一部分列时，MySQL 可以使用索引来快速定位到满足条件的行，但是可能需要回表（即访问表的实际数据行）来检查剩余的条件。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"复合索引\")]),_._v(\"：在使用复合索引（即索引包含多个列）的情况下，如果查询条件只匹配索引的前几列，那么剩余的列可能需要通过 \"),t(\"code\",[_._v(\"Using index condition\")]),_._v(\" 来进一步过滤。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\"select tables optimized away\")]),_._v(\"：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\"distinct\")]),_._v(\"：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作\")])])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"一般你们怎么建mysql索引-基于什么原则-遇到过索引失效的情况么-怎么优化的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一般你们怎么建mysql索引-基于什么原则-遇到过索引失效的情况么-怎么优化的\"}},[_._v(\"#\")]),_._v(\" 一般你们怎么建mysql索引，基于什么原则，遇到过索引失效的情况么，怎么优化的?\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"_1-mysql索引建立的原则\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-mysql索引建立的原则\"}},[_._v(\"#\")]),_._v(\" 1. MySQL索引建立的原则\")]),_._v(\" \"),t(\"blockquote\",[t(\"ol\",[t(\"li\",[_._v(\"最左前缀匹配原则，非常重要的原则，mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如 \"),t(\"code\",[_._v(\"a = 1 and b = 2 and c > 3 and d = 4\")]),_._v(\" 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\")]),_._v(\" \"),t(\"li\",[_._v(\"=和in可以乱序，比如 \"),t(\"code\",[_._v(\"a = 1 and b = 2 and c = 3\")]),_._v(\"  建立(a,b,c)索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。\")]),_._v(\" \"),t(\"li\",[_._v(\"尽量选择\"),t(\"strong\",[_._v(\"区分度高\")]),_._v(\"的列作为索引，区分度的公式是 \"),t(\"code\",[_._v(\"区分度 = distinct(col)/count(*)\")]),_._v(\"，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。\")]),_._v(\" \"),t(\"li\",[_._v(\"索引列不能参与计算，保持列“干净”，比如  \"),t(\"code\",[_._v(\"from_unixtime(create_time) = ’2014-05-29’\")]),_._v(\"  就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成 \"),t(\"code\",[_._v(\"create_time = unix_timestamp(’2014-05-29’)\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[_._v(\"尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可。\")])])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"选择合适的列\")]),_._v(\"：优先考虑在查询条件、排序（\"),t(\"code\",[_._v(\"ORDER BY\")]),_._v(\"）、分组（\"),t(\"code\",[_._v(\"GROUP BY\")]),_._v(\"）、连接（\"),t(\"code\",[_._v(\"JOIN\")]),_._v(\"）中频繁使用的列上建立索引。这些列通常对查询性能有显著影响。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"唯一性\")]),_._v(\"：在唯一性要求较高的列上建立唯一索引（\"),t(\"code\",[_._v(\"UNIQUE\")]),_._v(\"），如ID号、邮箱等。唯一索引不仅能加快查询速度，还能保证数据的唯一性。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"覆盖索引\")]),_._v(\"：尽量选择创建覆盖索引（即索引包含了查询所需的所有列），避免回表操作。这样可以显著提升查询性能，尤其是涉及多列的查询。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"前缀索引\")]),_._v(\"：对于文本类型（如\"),t(\"code\",[_._v(\"VARCHAR\")]),_._v(\"、\"),t(\"code\",[_._v(\"TEXT\")]),_._v(\"）的列，如果列值较长且前缀具有较高区分度，可以使用前缀索引来节省空间和提高查询效率。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"复合索引\")]),_._v(\"：在多个列上建立复合索引（即组合索引），以优化涉及多列的查询。但要注意列的顺序，通常将选择性更高的列放在最前面。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"考虑查询频率\")]),_._v(\"：根据查询的频率和响应时间要求，对高频查询的列进行索引优化。在写操作频繁的表上，要平衡索引的数量，以避免过多索引导致的插入和更新性能下降。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"避免过多索引\")]),_._v(\"：虽然索引可以加快查询速度，但过多的索引会增加插入、更新、删除操作的成本。因此，需要在查询性能和写性能之间取得平衡。\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"_2-常见的索引失效情况\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-常见的索引失效情况\"}},[_._v(\"#\")]),_._v(\" 2. 常见的索引失效情况\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"查询条件中使用了函数或表达式\")]),_._v(\"：当在查询条件中对索引列使用了函数或表达式（如\"),t(\"code\",[_._v(\"UPPER(column_name)\")]),_._v(\"），索引可能失效。MySQL需要扫描所有行来计算函数结果，导致全表扫描。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"隐式类型转换\")]),_._v(\"：如果查询条件中的列和参数类型不匹配（如将字符串列与数字比较），MySQL会进行隐式类型转换，导致索引失效。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"模糊查询以通配符开头\")]),_._v(\"：使用\"),t(\"code\",[_._v(\"LIKE '%value'\")]),_._v(\"形式的模糊查询时，由于通配符位于开头，索引无法使用，MySQL需要进行全表扫描。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"索引列不在最左侧\")]),_._v(\"：对于复合索引，如果查询条件中未使用复合索引的最左侧列，索引将无法使用（“最左前缀”原则）。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[t(\"code\",[_._v(\"OR\")]),_._v(\"条件未全部使用索引\")]),_._v(\"：如果查询条件中有\"),t(\"code\",[_._v(\"OR\")]),_._v(\"，且每个条件都未使用索引，则MySQL无法利用索引，需要进行全表扫描。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"查询条件中有NULL值\")]),_._v(\"：在某些情况下，索引列的查询条件中如果包含\"),t(\"code\",[_._v(\"IS NULL\")]),_._v(\"或\"),t(\"code\",[_._v(\"IS NOT NULL\")]),_._v(\"，可能会导致索引失效。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"查询条件中使用不等号\")]),_._v(\"：使用\"),t(\"code\",[_._v(\"<>\")]),_._v(\"或\"),t(\"code\",[_._v(\"!=\")]),_._v(\"查询条件时，MySQL可能会选择不使用索引，因为这种条件通常需要扫描大量行。\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"_3-索引优化方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-索引优化方法\"}},[_._v(\"#\")]),_._v(\" 3. 索引优化方法\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"重构查询\")]),_._v(\"：避免在索引列上使用函数、表达式、隐式类型转换等操作。尽可能让查询条件直接作用于索引列，确保索引生效。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"使用合适的类型\")]),_._v(\"：确保查询条件中的类型与列的类型匹配，避免隐式类型转换。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"合理使用通配符\")]),_._v(\"：对于模糊查询，尽量避免通配符开头。如果业务允许，可以考虑在应用层进行拆分查询或引入全文索引（\"),t(\"code\",[_._v(\"FULLTEXT\")]),_._v(\"）来处理文本搜索。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"优化复合索引的顺序\")]),_._v(\"：根据查询条件的使用情况，调整复合索引的列顺序，确保最左前缀列经常在查询条件中使用。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"拆分复杂查询\")]),_._v(\"：对于使用\"),t(\"code\",[_._v(\"OR\")]),_._v(\"的复杂查询，可以尝试将查询拆分为多个子查询，并使用\"),t(\"code\",[_._v(\"UNION\")]),_._v(\"合并结果，确保每个子查询都能利用索引。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"使用覆盖索引\")]),_._v(\"：如果可能，创建覆盖索引，使查询能够直接从索引中获取所需数据，避免回表，提高查询效率。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"分析查询性能\")]),_._v(\"：使用\"),t(\"code\",[_._v(\"EXPLAIN\")]),_._v(\"命令分析查询的执行计划，检查索引是否被使用。根据执行计划的结果，调整索引设计和查询语句。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"定期维护索引\")]),_._v(\"：对于频繁更新的表，定期进行索引重建或优化，以保持索引结构的高效性。\")])]),_._v(\" \"),t(\"p\",[_._v(\"通过合理的索引设计和优化，可以显著提高MySQL的查询性能。但在实际应用中，需要根据具体的业务需求、数据量和查询频率等因素来灵活调整索引策略，避免索引失效带来的性能问题。\")]),_._v(\" \"),t(\"blockquote\",[t(\"h5\",{attrs:{id:\"如何写sql能够有效的使用到复合索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何写sql能够有效的使用到复合索引\"}},[_._v(\"#\")]),_._v(\" 如何写sql能够有效的使用到复合索引？\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"全值匹配我最爱\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"最佳左前缀法则\")]),_._v(\"，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"存储引擎不能使用索引中范围条件右边的列\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"尽量使用\"),t(\"strong\",[_._v(\"覆盖索引\")]),_._v(\"(只访问索引的查询(索引列和查询列一致))，减少select\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"is null ,is not null 也无法使用索引\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v('like \"xxxx%\" 是可以用到索引的，like \"%xxxx\" 则不行(like \"%xxx%\" 同理)。like以通配符开头(\\'%abc...\\')索引失效会变成全表扫描的操作，')])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"字符串不加单引号索引失效\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"少用or，用它来连接时会索引失效\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"<，<=，=，>，>=，BETWEEN，IN 可用到索引，<>，not in ，!= 则不行，会导致全表扫描\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"前缀索引：前缀索引就是用某个字段中，字符串的前几个字符建立索引，比如我们可以在订单表上对商品名称字段的前 5 个字符建立索引。使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。\")]),_._v(\" \"),t(\"p\",[_._v(\"但是，前缀索引有一定的局限性，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"一条sql执行过长的时间-你如何优化-从哪些方面\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一条sql执行过长的时间-你如何优化-从哪些方面\"}},[_._v(\"#\")]),_._v(\" 一条sql执行过长的时间，你如何优化，从哪些方面？\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）\")]),_._v(\" \"),t(\"li\",[_._v(\"涉及连表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合\")]),_._v(\" \"),t(\"li\",[_._v(\"如果以上两种都不能操作，非要连表查询，那么考虑对相对应的查询条件做索引。加快查询速度\")]),_._v(\" \"),t(\"li\",[_._v(\"针对数量大的表进行历史表分离（如交易流水表）\")]),_._v(\" \"),t(\"li\",[_._v(\"数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步\")]),_._v(\" \"),t(\"li\",[_._v(\"explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等\")]),_._v(\" \"),t(\"li\",[_._v(\"查看mysql执行日志，看看是否有其他方面的问题\")])]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"十、分区、分表、分库\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#十、分区、分表、分库\"}},[_._v(\"#\")]),_._v(\" 十、分区、分表、分库\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql分区\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql分区\"}},[_._v(\"#\")]),_._v(\" MySQL分区？\")]),_._v(\" \"),t(\"p\",[_._v(\"一般情况下我们创建的表对应一组存储文件，使用\"),t(\"code\",[_._v(\"MyISAM\")]),_._v(\"存储引擎时是一个\"),t(\"code\",[_._v(\".MYI\")]),_._v(\"和\"),t(\"code\",[_._v(\".MYD\")]),_._v(\"文件，使用\"),t(\"code\",[_._v(\"Innodb\")]),_._v(\"存储引擎时是一个\"),t(\"code\",[_._v(\".ibd\")]),_._v(\"和\"),t(\"code\",[_._v(\".frm\")]),_._v(\"（表结构）文件。\")]),_._v(\" \"),t(\"p\",[_._v(\"当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL分区是一种数据库优化技术，通过将表的数据划分为更小、更易管理的部分，来提高查询性能和管理效率。下面是关于MySQL分区的一些关键点，适合在面试中讨论：\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"能干嘛\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"逻辑数据分割\")]),_._v(\" \"),t(\"li\",[_._v(\"提高单一的写和读应用速度\")]),_._v(\" \"),t(\"li\",[_._v(\"提高分区范围读查询的速度\")]),_._v(\" \"),t(\"li\",[_._v(\"分割数据能够有多个不同的物理文件路径\")]),_._v(\" \"),t(\"li\",[_._v(\"高效的保存历史数据\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"分区类型及操作\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"RANGE分区\")]),_._v(\"：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。\")]),_._v(\" \"),t(\"p\",[_._v(\"按照 range 来分，就是每个库一段连续的数据，这个一般是按比如\"),t(\"strong\",[_._v(\"时间范围\")]),_._v(\"来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。\")]),_._v(\" \"),t(\"p\",[_._v(\"range 来分，好处在于说，扩容的时候很简单。\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"CREATE TABLE sales (\\n    id INT,\\n    amount DECIMAL(10,2),\\n    sale_date DATE\\n)\\nPARTITION BY RANGE (YEAR(sale_date)) (\\n    PARTITION p0 VALUES LESS THAN (2000),\\n    PARTITION p1 VALUES LESS THAN (2005),\\n    PARTITION p2 VALUES LESS THAN (2010),\\n    PARTITION p3 VALUES LESS THAN MAXVALUE\\n);\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"LIST分区\")]),_._v(\"：按列表划分，类似于RANGE分区，但使用的是明确的值列表。\")]),_._v(\" \"),t(\"p\",[_._v(\"它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"CREATE TABLE customers (\\n    id INT,\\n    name VARCHAR(50),\\n    country VARCHAR(50)\\n)\\nPARTITION BY LIST (country) (\\n    PARTITION p0 VALUES IN ('USA', 'Canada'),\\n    PARTITION p1 VALUES IN ('UK', 'France'),\\n    PARTITION p2 VALUES IN ('Germany', 'Italy')\\n);\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"HASH分区\")]),_._v(\"：按哈希算法划分，将数据根据某个列的哈希值均匀分布到不同的分区中。\")]),_._v(\" \"),t(\"p\",[_._v(\"hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"CREATE TABLE orders (\\n    id INT,\\n    order_date DATE,\\n    customer_id INT\\n)\\nPARTITION BY HASH(id) PARTITIONS 4;\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"KEY分区\")]),_._v(\"：类似于HASH分区，但使用MySQL内部的哈希函数。\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"CREATE TABLE logs (\\n    id INT,\\n    log_date DATE\\n)\\nPARTITION BY KEY(id) PARTITIONS 4;\\n\")])])])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁\")]),_._v(\" \"),t(\"li\",[_._v(\"一旦数据并发量上来，如果在分区表实施关联，就是一个灾难\")]),_._v(\" \"),t(\"li\",[_._v(\"自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"如何确定分库还是分表\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何确定分库还是分表\"}},[_._v(\"#\")]),_._v(\" 如何确定分库还是分表？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"针对“如何确定分库还是分表？”的问题，你要结合具体的场景。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"何时分表\")])]),_._v(\" \"),t(\"p\",[_._v(\"当数据量过大造成事务执行缓慢时，就要考虑分表，因为减少每次查询数据总量是解决数据查询缓慢的主要原因。你可能会问：“查询可以通过主从分离或缓存来解决，为什么还要分表？”但这里的查询是指事务中的查询和更新操作。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"何时分库\")])]),_._v(\" \"),t(\"p\",[_._v(\"为了应对高并发，一个数据库实例撑不住，即单库的性能无法满足高并发的要求，就把并发请求分散到多个实例中去\")]),_._v(\" \"),t(\"p\",[_._v(\"总的来说，分库分表使用的场景不一样：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"分表是因为数据量比较大，导致事务执行缓慢；\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"分库是因为单库的性能无法满足要求。\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql分库\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql分库\"}},[_._v(\"#\")]),_._v(\" MySQL分库?\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"为什么要分库?\")])]),_._v(\" \"),t(\"p\",[_._v(\"数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说大数据、频繁的写入操作对 master 性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"分库是什么？\")])]),_._v(\" \"),t(\"p\",[_._v(\"一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"分库的优点：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"减少增量数据写入时的锁对查询的影响\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短\")])])]),_._v(\" \"),t(\"p\",[_._v(\"但是它无法解决单表数据量太大的问题\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql分表\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql分表\"}},[_._v(\"#\")]),_._v(\" MySQL分表?\")]),_._v(\" \"),t(\"p\",[_._v(\"分表有两种分割方式，一种垂直拆分，另一种水平拆分。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"垂直拆分\")])]),_._v(\" \"),t(\"p\",[_._v(\"垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"水平拆分(数据分片)\")])]),_._v(\" \"),t(\"p\",[_._v(\"单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。\")]),_._v(\" \"),t(\"p\",[_._v(\"水平分割的几种方法：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。\")]),_._v(\" \"),t(\"li\",[_._v(\"还可根据时间放入不同的表，比如：article_201601，article_201602。\")]),_._v(\" \"),t(\"li\",[_._v(\"按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。\")]),_._v(\" \"),t(\"li\",[_._v(\"根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"分布式id生成方案\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分布式id生成方案\"}},[_._v(\"#\")]),_._v(\" 分布式ID生成方案？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"分库分表之后，id主键如何处理？\")]),_._v(\" \"),t(\"p\",[_._v(\"推荐：https://zhuanlan.zhihu.com/p/107939861\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"UUID：\"),t(\"code\",[_._v(\"UUID\")]),_._v(\"的生成简单到只有一行代码，输出结果 \"),t(\"code\",[_._v(\"c2b8c2b9e46c47e3b30dca3b0d447718\")]),_._v(\"，但UUID却并不适用于实际的业务需求。像用作订单号\"),t(\"code\",[_._v(\"UUID\")]),_._v(\"这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务\"),t(\"code\",[_._v(\"主键ID\")]),_._v(\"，它不仅是太长还是字符串，而且不是自增的，存储性能差查询也很耗时，所以不推荐用作\"),t(\"code\",[_._v(\"分布式ID\")]),_._v(\"。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"UUID 最大的缺陷是它产生的 ID 不是递增的。一般来说，我们倾向于在数据库中使用自增主键，因为这样可以迫使数据库的树朝着一个方向增长，而不会造成中间叶节点分裂，这样插入性能最好。而整体上 UUID 生成的 ID 可以看作是随机，那么就会导致数据往页中间插入，引起更加频繁地页分裂，在糟糕的情况下，这种分裂可能引起连锁反应，整棵树的树形结构都会受到影响。所以我们普遍倾向于采用递增的主键。\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"数据库自增ID：需要一个单独的MySQL实例用来生成ID（DB单点存在宕机风险，无法扛住高并发场景）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"数据库多主模式\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"号段模式\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"Redis：利用\"),t(\"code\",[_._v(\"redis\")]),_._v(\"的 \"),t(\"code\",[_._v(\"incr\")]),_._v(\"命令实现ID的原子性自增。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"雪花算法（SnowFlake）：\"),t(\"code\",[_._v(\"Snowflake\")]),_._v(\"生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特\")]),_._v(\" \"),t(\"p\",[_._v(\"Snowflake ID组成结构：\"),t(\"code\",[_._v(\"正数位\")]),_._v(\"（占1比特）+ \"),t(\"code\",[_._v(\"时间戳\")]),_._v(\"（占41比特）+ \"),t(\"code\",[_._v(\"机器ID\")]),_._v(\"（占5比特）+ \"),t(\"code\",[_._v(\"数据中心\")]),_._v(\"（占5比特）+ \"),t(\"code\",[_._v(\"自增值\")]),_._v(\"（占12比特），总共64比特组成的一个Long类型。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"滴滴出品（TinyID）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"百度 （Uidgenerator）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"美团（Leaf）\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"如何解决分库分表中的分页问题的-有没有因为排序或者分页而引起的性能问题-如果有-最终是怎么解决的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何解决分库分表中的分页问题的-有没有因为排序或者分页而引起的性能问题-如果有-最终是怎么解决的\"}},[_._v(\"#\")]),_._v(\" 如何解决分库分表中的分页问题的？有没有因为排序或者分页而引起的性能问题？如果有，最终是怎么解决的？\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"分库分表容量是怎么确定的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分库分表容量是怎么确定的\"}},[_._v(\"#\")]),_._v(\" 分库分表容量是怎么确定的？\")]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"十一、集群\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#十一、集群\"}},[_._v(\"#\")]),_._v(\" 十一、集群\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说下-mysql-主从\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说下-mysql-主从\"}},[_._v(\"#\")]),_._v(\" 说下 MySQL 主从？\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[_._v(\"什么是 MySQL 主从复制？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"主从复制用于建立一个或多个与主库相同的数据库，称为从库，实现读写分离，提高并发处理能力。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"主从复制的作用是什么？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"主从复制用于数据热备份、架构扩展、提高并发处理能力，实现读写分离。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"MySQL 主从复制是如何实现的？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"主从复制通过 I/O 线程和 SQL 线程实现，I/O 线程负责从主库请求 binlog，SQL 线程负责将 binlog 应用到从库。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"主从复制可能会遇到哪些问题？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"可能遇到的问题包括复制延迟、数据不一致、锁表导致的阻塞、宕机导致的数据丢失。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"如何解决主从复制的问题？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"可以通过半同步复制策略减少数据丢失风险，采用并行复制减少复制延迟。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"什么是 MySQL 集群？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"MySQL 集群是一组 MySQL 服务器的集合，它们协同工作以提供高可用性、负载均衡和读写分离。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"MySQL 集群有哪些类型？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"包括主从集群、互主集群、Galera 集群等，每种集群有其特定的应用场景和特点。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"如何搭建 MySQL 集群？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"搭建 MySQL 集群通常涉及配置多个 MySQL 服务实例，实现主从复制，配置读写分离，以及设置故障转移机制。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"什么是 GTID 同步集群？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"GTID（全局事务 ID）同步集群是一种基于全局唯一 ID 标识事务的复制方式，引入于 MySQL 5.6 版本，用于确保事务在复制集群中的一致性。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"如何实现 MySQL 的读写分离？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"读写分离通常由业务层实现，可以通过智能路由、负载均衡器或中间件如 ShardingSphere、MyCat 来实现。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"什么是半同步复制？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"半同步复制是一种提高数据安全性的机制，主库在事务提交后等待至少一个从库接收并写入 relay log 后才返回客户端响应。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"MySQL 集群扩容和数据迁移怎么做？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"扩容集群可能需要数据迁移，可以通过 mysqldump 工具备份数据，然后在新节点上恢复数据，再配置数据同步。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"如何解决 MySQL 主从复制的延迟问题？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"可以通过优化网络条件、升级硬件、使用并行复制等方法减少延迟。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"MySQL 集群的高可用性是如何实现的？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"高可用性可以通过故障检测、自动故障转移、多副本等机制实现。\")])])]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"MySQL 集群中的分库分表是如何考虑的？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"分库分表需要考虑数据量、查询模式、业务逻辑等因素，以优化性能和扩展性\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"复制的基本原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制的基本原理\"}},[_._v(\"#\")]),_._v(\" 复制的基本原理？\")]),_._v(\" \"),t(\"p\",[_._v(\"主从复制用于建立一个或多个与主库相同的数据库，称为从库，实现读写分离，提高并发处理能力\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"slave 会从 master 读取 binlog 来进行数据同步\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"三个步骤\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；\")]),_._v(\" \"),t(\"li\",[_._v(\"salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;\")]),_._v(\" \"),t(\"li\",[_._v(\"slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"这么记忆\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"回放 Binlog：回放 binlog，并更新存储数据\")])])])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-一主多从\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-一主多从\"}},[_._v(\"#\")]),_._v(\" MySQL 一主多从？\")]),_._v(\" \"),t(\"p\",[_._v(\"一旦你提及“一主多从”，面试官很容易设陷阱问你：那大促流量大时，是不是只要多增加几台从库，就可以抗住大促的并发读请求了？\")]),_._v(\" \"),t(\"p\",[_._v(\"当然不是。\")]),_._v(\" \"),t(\"p\",[_._v(\"因为从库数量增加，从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。\")]),_._v(\" \"),t(\"p\",[_._v(\"其实，你从 MySQL 主从复制过程也能发现，MySQL 默认是异步模式：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。\")]),_._v(\" \"),t(\"p\",[_._v(\"而这时，面试官一般会追问你“**MySQL 主从复制还有哪些模型？”**主要有三种。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"同步复制：事务线程要等待所有从库的复制成功响应。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"异步复制：事务线程完全不等待从库的复制成功响应。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"半同步复制：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"复制的基本原则\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制的基本原则\"}},[_._v(\"#\")]),_._v(\" 复制的基本原则？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"每个 slave 只有一个 master\")]),_._v(\" \"),t(\"li\",[_._v(\"每个 salve 只能有一个唯一的服务器 ID\")]),_._v(\" \"),t(\"li\",[_._v(\"每个 master 可以有多个 salve\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"复制的最大问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制的最大问题\"}},[_._v(\"#\")]),_._v(\" 复制的最大问题\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"延时\")])]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"十二、其他问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#十二、其他问题\"}},[_._v(\"#\")]),_._v(\" 十二、其他问题\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-设计需要注意什么\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-设计需要注意什么\"}},[_._v(\"#\")]),_._v(\" MySQL 设计需要注意什么?\")]),_._v(\" \"),t(\"p\",[_._v(\"在设计MySQL数据库时，有许多方面需要注意，以确保数据库的性能、可扩展性、安全性和可维护性\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"表结构设计：\"),t(\"strong\",[_._v(\"规范化\")]),_._v(\"、合适的数据类型\")]),_._v(\" \"),t(\"li\",[_._v(\"索引：覆盖索引\")]),_._v(\" \"),t(\"li\",[_._v(\"查询优化：合理使用JOIN\")]),_._v(\" \"),t(\"li\",[_._v(\"分区与分库分表\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"如何在不停机的情况下保证迁移数据的一致性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何在不停机的情况下保证迁移数据的一致性\"}},[_._v(\"#\")]),_._v(\" 如何在不停机的情况下保证迁移数据的一致性？\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"创建目标表。\")]),_._v(\" \"),t(\"li\",[_._v(\"用源表的数据初始化目标表。\")]),_._v(\" \"),t(\"li\",[_._v(\"执行一次校验，并且修复数据，此时用源表数据修复目标表数据。\")]),_._v(\" \"),t(\"li\",[_._v(\"业务代码开启双写，此时读源表，并且先写源表，数据以源表为准。\")]),_._v(\" \"),t(\"li\",[_._v(\"开启增量校验和数据修复，保持一段时间。\")]),_._v(\" \"),t(\"li\",[_._v(\"切换双写顺序，此时读目标表，并且先写目标表，数据以目标表为准。\")]),_._v(\" \"),t(\"li\",[_._v(\"继续保持增量校验和数据修复。\")]),_._v(\" \"),t(\"li\",[_._v(\"切换为目标表单写，读写都只操作目标表。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"初始化目标表数据\")])]),_._v(\" \"),t(\"p\",[_._v(\"我选择了从源表导出数据，使用的是 mysqldump 工具。mysqldump 是一个开源的逻辑备份工具，优点是使用简单，能够直接导出整个数据库。缺点则是导出和导入的速度都比较慢，尤其是在数据量非常大的情况下。所以我针对mysqldump 做了一些优化，来提高导出和导入的性能。加快导出速度能做的事情并不多，主要就是开启 extended-insert 选项，将多行合并为一个INSERT 语句。\")]),_._v(\" \"),t(\"p\",[_._v(\"加快导入速度就可以做比较多的事情。\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"关闭唯一性检查和外键检查，源表已经保证了这两项，所以目标表并不需要检查。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"关闭 binlog，毕竟导入数据用不着 binlog。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"调整 redo log 的刷盘时机，把 innodb_flush_log_at_trx_commit 设置为0。\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说一说三个范式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说一说三个范式\"}},[_._v(\"#\")]),_._v(\" 说一说三个范式？\")]),_._v(\" \"),t(\"p\",[_._v(\"数据库设计中的三个范式（3NF）是用于规范数据库的结构，以减少数据冗余和提高数据的一致性。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。\")]),_._v(\" \"),t(\"li\",[_._v(\"第二范式（2NF）：第二范式在第一范式的基础上进一步规范化，要求表中的每一列都与主键直接相关，而不是间接相关\")]),_._v(\" \"),t(\"li\",[_._v('第三范式（3NF）：第三范式要求列之间没有传递依赖，即非主键列之间不能相互依赖。所谓传递函数依赖，指的是如果存在\"A → B → C\"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y')])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"百万级别或以上的数据如何删除\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#百万级别或以上的数据如何删除\"}},[_._v(\"#\")]),_._v(\" 百万级别或以上的数据如何删除？\")]),_._v(\" \"),t(\"p\",[_._v(\"关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件，所以当我们对数据的增加、修改、删除，都会产生额外的对索引文件的操作，这些操作需要消耗额外的IO，会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）\")]),_._v(\" \"),t(\"li\",[_._v(\"然后删除其中无用数据（此过程需要不到两分钟）\")]),_._v(\" \"),t(\"li\",[_._v(\"删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。\")]),_._v(\" \"),t(\"li\",[_._v(\"与之前的直接删除绝对是要快速很多，更别说万一删除中断，一切删除会回滚。那更是坑了。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"limit-100000-加载很慢的话-你是怎么解决的呢\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#limit-100000-加载很慢的话-你是怎么解决的呢\"}},[_._v(\"#\")]),_._v(\" limit 100000 加载很慢的话，你是怎么解决的呢？\")]),_._v(\" \"),t(\"p\",[_._v(\"在 mysql 中 limit 可以实现快速分页，但是如果数据到了几百万时我们的 limit 必须优化才能有效的合理的实现分页了，否则可能卡死你的服务器\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"当一个表数据有几百万的数据的时候成了问题！\")])]),_._v(\" \"),t(\"p\",[_._v(\"日常分页SQL语句\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"select id,name,content from users order by id asc limit 100000,20\\n\")])])]),t(\"p\",[_._v(\"扫描100020行\")]),_._v(\" \"),t(\"p\",[_._v(\"如果记录了上次的最大ID\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\" select id,name,content from users where id>100073 order by id asc limit 20\\n\")])])]),t(\"p\",[_._v(\"扫描 20 行。\")]),_._v(\" \"),t(\"p\",[_._v(\"总数据有500万左右，以下例子\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"select * from wl_tagindex where byname='f' order by id limit 300000,10 \\n\")])])]),t(\"p\",[_._v(\"执行时间是 3.21s\")]),_._v(\" \"),t(\"p\",[_._v(\"优化后：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"select * from (\\n  select id from wl_tagindex\\nwhere byname='f' order by id limit 300000,10\\n) a\\nleft join wl_tagindex b on a.id=b.id\\n\")])])]),t(\"p\",[_._v(\"执行时间为 0.11s 速度明显提升\")]),_._v(\" \"),t(\"p\",[_._v(\"这里需要说明的是 我这里用到的字段是 byname ,id 需要把这两个字段做复合索引，否则的话效果提升不明显\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"在高并发情况下-如何做到安全的修改同一行数据-2\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在高并发情况下-如何做到安全的修改同一行数据-2\"}},[_._v(\"#\")]),_._v(\" 在高并发情况下，如何做到安全的修改同一行数据？\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"1、使用悲观锁\")])]),_._v(\" \"),t(\"p\",[_._v(\"悲观锁本质是当前只有一个线程执行操作，排斥外部请求的修改。遇到加锁的状态，就必须等待。结束了唤醒其他线程进行处理。虽然此方案的确解决了数据安全的问题，但是，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"2、FIFO（First Input First Output，先进先出）缓存队列思路\")])]),_._v(\" \"),t(\"p\",[_._v(\"直接将请求放入队列中，就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/20190508231654761.\",alt:\"在这里插入图片描述\"}})]),_._v(\" \"),t(\"p\",[_._v(\"然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时间还是会大幅下降，系统还是陷入异常。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"3、使用乐观锁\")])]),_._v(\" \"),t(\"p\",[_._v(\"这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"表中有大字段-x-例如-text-类型-且字段-x-不会经常更新-以读为-为主-将该字段拆成子表好处是什么\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#表中有大字段-x-例如-text-类型-且字段-x-不会经常更新-以读为-为主-将该字段拆成子表好处是什么\"}},[_._v(\"#\")]),_._v(\" 表中有大字段 \"),t(\"strong\",[_._v(\"X\")]),_._v(\"(例如:\"),t(\"strong\",[_._v(\"text\")]),_._v(\" 类型)，且字段 \"),t(\"strong\",[_._v(\"X\")]),_._v(\" 不会经常更新，以读为 为主，将该字段拆成子表好处是什么?\")]),_._v(\" \"),t(\"p\",[_._v(\"如果字段里面有大字段(text,blob)类型的，而且这些字段的访问并不多，这 时候放在一起就变成缺点了。 MYSQL 数据库的记录存储是按行存储的，数据 块大小又是固定的(16K)，每条记录越小，相同的块存储的记录就越多。此 时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需 要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后， 对字段的 UPDAE 就要 UPDATE 多个表了\")]),_._v(\" \"),t(\"h2\",{attrs:{id:\"参考与感谢\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考与感谢\"}},[_._v(\"#\")]),_._v(\" 参考与感谢：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"https://zhuanlan.zhihu.com/p/29150809\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"https://juejin.im/post/5e3eb616f265da570d734dcb#heading-105\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"https://blog.csdn.net/yin767833376/article/details/81511377\")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);","extractedComments":[]}