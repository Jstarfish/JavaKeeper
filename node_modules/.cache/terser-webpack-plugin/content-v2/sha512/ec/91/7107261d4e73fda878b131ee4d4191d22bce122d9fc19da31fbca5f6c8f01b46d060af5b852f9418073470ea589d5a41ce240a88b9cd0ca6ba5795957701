{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[202],{723:function(t,v,_){\"use strict\";_.r(v);var s=_(6),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[_(\"p\",[_(\"img\",{attrs:{src:\"https://img.starfish.ink/common/faq-banner.png\",alt:\"\"}})]),t._v(\" \"),_(\"blockquote\",[_(\"p\",[t._v(\"C：Consistency，数据一致性\")]),t._v(\" \"),_(\"p\",[t._v(\"A：Availability，服务可用性\")]),t._v(\" \"),_(\"p\",[t._v(\"P：Partition-tolerance，分区容错性\")]),t._v(\" \"),_(\"p\",[t._v(\"CAP 理论告诉我们，一个分布式系统不可能同时满足数据一致性、服务可用性和分区容错性这三个基本需求，最多只能同时满足其中的两个\")])]),t._v(\" \"),_(\"p\",[t._v(\"服务注册与发现的基本模型\")]),t._v(\" \"),_(\"p\",[t._v(\"![](/Users/starfish/Documents/截图/截屏2024-07-02 10.04.09.png)\")]),t._v(\" \"),_(\"p\",[t._v(\"举一个例子，你去一个陌生的城市出差，下班了想去吃个火锅，还得是重庆火锅。那么你怎 么知道这个城市哪里有重庆火锅？ 你可能会说，我在 App 里面搜一下。那么 App 又怎么知道这里有一家重庆火锅店呢？你继 续说，这肯定是商家去这个 App 注册过了呀！对，服务注册与发现模型就是这样。你扮演了 客户端的角色，火锅店扮演了服务端的角色，而 App 则是扮演了我们常说的注册中心的角 色。\")]),t._v(\" \"),_(\"p\",[t._v(\"![](/Users/starfish/Documents/截图/截屏2024-07-02 10.08.12.png)\")]),t._v(\" \"),_(\"ol\",[_(\"li\",[t._v(\"服务端启动的时候，需要往注册中心里注册自身的信息，主要是定位信息。\")]),t._v(\" \"),_(\"li\",[t._v(\"注册成功之后，注册中心和服务端要保持心跳。\")]),t._v(\" \"),_(\"li\",[t._v(\"客户端第一次发起对某个服务的调用之前，要先找注册中心获得所有可用服务节点列表， 随后客户端会在本地缓存每个服务对应的可用节点列表。\")]),t._v(\" \"),_(\"li\",[t._v(\"客户端和注册中心要保持心跳和数据同步，后续服务端有任何变动，注册中心都会通知客 户端，客户端会更新本地的可用节点列表。\")]),t._v(\" \"),_(\"li\",[t._v(\"客户端发送请求。\")]),t._v(\" \"),_(\"li\",[t._v(\"服务端返回响应。\")])]),t._v(\" \"),_(\"p\",[t._v(\"你们用了什么中间件作为注册中心以及该中间件的优缺点。确保自己在回答“你为什么用 某个中间价作为注册中心”的时候，能够综合这些优缺点来回答。 注册中心的集群规模。 读写 QPS（每秒查询率）。 机器性能，如 CPU 和内存大小。 最好准备一个注册中心出故障之后你排查和后续优化的案例。在讨论使用注册中心的注意 事项，或者遇到过什么 Bug 的时候可以用这个案例。\")]),t._v(\" \"),_(\"p\",[t._v(\"在注册中心选型上，重要的是 CAP 原理中应该选择 AP，比如说 Eureka，又或者 Nacos 启用 AP 模式。\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"服务注册与发现怎么保证高可用呢\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#服务注册与发现怎么保证高可用呢\"}},[t._v(\"#\")]),t._v(\" 服务注册与发现怎么保证高可用呢？\")]),t._v(\" \"),_(\"p\",[t._v(\"高可用的服务注册与发现要围绕\"),_(\"strong\",[t._v(\"注册服务端崩溃检测、客户端容错和注册中心选型\")]),t._v(\"三个方面进行\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"负载均衡\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#负载均衡\"}},[t._v(\"#\")]),t._v(\" 负载均衡\")]),t._v(\" \"),_(\"p\",[t._v(\"负载均衡，本质上就是回答一个问题：\"),_(\"strong\",[t._v(\"我该把请求发给哪个服务端？\")])]),t._v(\" \"),_(\"p\",[t._v(\"负载均衡算法\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[_(\"strong\",[t._v(\"静态负载均衡算法\")]),t._v(\"，它们依靠的是统计学上的“最合适”。也就是说，如果请求都差不多，请求数量也足够多，那么它们能够挑选出比较合适的节点\\n\"),_(\"ul\",[_(\"li\",[_(\"strong\",[t._v(\"轮询与加权轮询\")])]),t._v(\" \"),_(\"li\",[_(\"strong\",[t._v(\"随机与加权随机\")])]),t._v(\" \"),_(\"li\",[_(\"strong\",[t._v(\"哈希与一致性哈希\")])])])]),t._v(\" \"),_(\"li\",[_(\"strong\",[t._v(\"动态负载均衡算法\")]),t._v(\"，或者说是实时检测负载均衡算法。这一类算法依赖于实时判断所有候选节点的状态，并且从里面挑选出最合适的节点。这一类算法包含最少连接数、最少活跃请求数、最快响应时间等算法\")])]),t._v(\" \"),_(\"h3\",{attrs:{id:\"熔断-恢复-熔断-恢复-抖来抖去怎么办\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#熔断-恢复-熔断-恢复-抖来抖去怎么办\"}},[t._v(\"#\")]),t._v(\" 熔断-恢复-熔断-恢复，抖来抖去怎么办？\")]),t._v(\" \"),_(\"p\",[_(\"strong\",[t._v(\"熔断可以给服务端恢复的机会\")])]),t._v(\" \"),_(\"h3\",{attrs:{id:\"降级\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#降级\"}},[t._v(\"#\")]),t._v(\" 降级\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"限流\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#限流\"}},[t._v(\"#\")]),t._v(\" 限流\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"隔离\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#隔离\"}},[t._v(\"#\")]),t._v(\" 隔离\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"rpc\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rpc\"}},[t._v(\"#\")]),t._v(\" RPC\")])])}),[],!1,null,null,null);v.default=a.exports}}]);","extractedComments":[]}