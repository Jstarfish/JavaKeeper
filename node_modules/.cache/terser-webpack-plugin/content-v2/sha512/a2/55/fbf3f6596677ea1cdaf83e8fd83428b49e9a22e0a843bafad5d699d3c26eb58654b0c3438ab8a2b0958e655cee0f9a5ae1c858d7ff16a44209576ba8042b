{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{622:function(t,a,s){\"use strict\";s.r(a);var e=s(6),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"p\",[s(\"img\",{attrs:{src:\"https://img.starfish.ink/leetcode/backtracking-banner.png\",alt:\"\"}})]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"「回溯算法」是解决很多算法问题的常见思想，它也是传统的人工智能的方法，其本质是 \"),s(\"strong\",[t._v(\"在树形问题中寻找解\")]),t._v(\" 。\")]),t._v(\" \"),s(\"p\",[t._v(\"回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。所以也可以叫做\"),s(\"strong\",[t._v(\"回溯搜索法\")]),t._v(\"。\")]),t._v(\" \"),s(\"p\",[t._v(\"回溯是递归的副产品，只要有递归就会有回溯。\")])]),t._v(\" \"),s(\"h1\",{attrs:{id:\"回溯算法\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#回溯算法\"}},[t._v(\"#\")]),t._v(\" 回溯算法\")]),t._v(\" \"),s(\"h2\",{attrs:{id:\"基本思想\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基本思想\"}},[t._v(\"#\")]),t._v(\" 基本思想\")]),t._v(\" \"),s(\"p\",[s(\"strong\",[t._v(\"回溯法\")]),t._v(\" 采用试错的思想，它尝试分步的去解决一个问题。\")]),t._v(\" \"),s(\"p\",[t._v(\"回溯算法（Backtracking）是一种系统地搜索解问题空间的算法，主要用于解决组合问题。\")]),t._v(\" \"),s(\"p\",[t._v(\"其基本思想是通过构建一个问题的解空间树（Solution Space Tree），逐步构造候选解，并在构造过程中判断候选解是否满足约束条件。如果满足，则继续向下构造；如果不满足，则回溯（Backtrack）到上一步，尝试其他候选解。\")]),t._v(\" \"),s(\"p\",[t._v(\"回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"找到一个可能存在的正确的答案；\")]),t._v(\" \"),s(\"li\",[t._v(\"在尝试了所有可能的分步方法后宣告该问题没有答案。\")])]),t._v(\" \"),s(\"p\",[t._v(\"我刚开始学习「回溯算法」的时候觉得很抽象，一直不能理解为什么 \"),s(\"strong\",[t._v(\"递归之后需要做和递归之前相同的逆向操作\")]),t._v(\"，在做了很多相关的问题以后，我发现其实「回溯算法」与「 \"),s(\"strong\",[t._v(\"深度优先遍历\")]),t._v(\" 」有着千丝万缕的联系。\")]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[s(\"strong\",[t._v(\"深度优先搜索\")]),t._v(\" 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 \"),s(\"strong\",[t._v(\"尽可能深\")]),t._v(\" 的搜索树的分支。当结点 \"),s(\"code\",[t._v(\"v\")]),t._v(\" 的所在边都己被探寻过，搜索将 \"),s(\"strong\",[t._v(\"回溯\")]),t._v(\" 到发现结点 \"),s(\"code\",[t._v(\"v\")]),t._v(\" 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。\")])]),t._v(\" \"),s(\"p\",[t._v(\"回溯法，一般可以解决如下几种问题：\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"组合问题：N个数里面按一定规则找出k个数的集合\")]),t._v(\" \"),s(\"li\",[t._v(\"切割问题：一个字符串按一定规则有几种切割方式\")]),t._v(\" \"),s(\"li\",[t._v(\"子集问题：一个N个数的集合里有多少符合条件的子集\")]),t._v(\" \"),s(\"li\",[t._v(\"排列问题：N个数按一定规则全排列，有几种排列方式\")]),t._v(\" \"),s(\"li\",[t._v(\"棋盘问题：N皇后，解数独等等\")])]),t._v(\" \"),s(\"h2\",{attrs:{id:\"回溯算法的基本框架\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#回溯算法的基本框架\"}},[t._v(\"#\")]),t._v(\" 回溯算法的基本框架\")]),t._v(\" \"),s(\"p\",[t._v(\"回溯算法的基本框架可以用递归来实现，通常包含以下几个步骤：\")]),t._v(\" \"),s(\"ol\",[s(\"li\",[s(\"strong\",[t._v(\"选择和扩展\")]),t._v(\"：选择一个可行的扩展步骤，扩展当前的解。\")]),t._v(\" \"),s(\"li\",[s(\"strong\",[t._v(\"约束检查\")]),t._v(\"：检查当前扩展后的解是否满足问题的约束条件。\")]),t._v(\" \"),s(\"li\",[s(\"strong\",[t._v(\"递归调用\")]),t._v(\"：如果当前解满足约束条件，则递归地尝试扩展该解。\")]),t._v(\" \"),s(\"li\",[s(\"strong\",[t._v(\"回溯\")]),t._v(\"：如果当前解不满足约束条件，或所有扩展步骤都已经尝试，则回溯到上一步，尝试其他可能的扩展步骤。\")])]),t._v(\" \"),s(\"p\",[t._v(\"以下是回溯算法的一般伪代码：\")]),t._v(\" \"),s(\"div\",{staticClass:\"language-java extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[s(\"code\",[t._v(\"result \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),t._v(\"\\nfunction \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"backtrack\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"solution\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" candidates\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\"  \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//入参可以理解为 路径, 选择列表\")]),t._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"if\")]),t._v(\" solution 是一个完整解\"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\"  \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//满足结束条件\")]),t._v(\"\\n        result\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"add\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"solution\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"  \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 处理当前完整解\")]),t._v(\"\\n        \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"return\")]),t._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"for\")]),t._v(\" candidate in candidates\"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\"\\n        \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"if\")]),t._v(\" candidate 满足约束条件\"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\"\\n            solution\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"add\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"candidate\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"  \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 扩展解\")]),t._v(\"\\n            \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"backtrack\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"solution\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" new_candidates\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"  \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 递归调用\")]),t._v(\"\\n            solution\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"remove\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"candidate\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"  \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 回溯,撤销选择\")]),t._v(\"\\n\\n\")])])]),s(\"h2\",{attrs:{id:\"热门面试题\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#热门面试题\"}},[t._v(\"#\")]),t._v(\" 热门面试题\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"电话号码的字母组合-17\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#电话号码的字母组合-17\"}},[t._v(\"#\")]),t._v(\" \"),s(\"a\",{attrs:{href:\"https://leetcode.cn/problems/letter-combinations-of-a-phone-number/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"电话号码的字母组合_17\"),s(\"OutboundLink\")],1)]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\")]),t._v(\" \"),s(\"p\",[t._v(\"给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png\",alt:\"img\"}})]),t._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[t._v('输入：digits = \"23\"\\n输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\\n')])])])]),t._v(\" \"),s(\"p\",[t._v(\"思路：\")]),t._v(\" \"),s(\"p\",[t._v('图中可以看出遍历的深度，就是输入\"23\"的长度，而叶子节点就是我们要收集的结果，输出[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]。')]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/02b0ec926e3da5f12a0a118293b8ac10dc236741ccb04414ded44a30f7fc70af-1573829897(1).jpg\",alt:\"\"}})]),t._v(\" \"),s(\"h3\",{attrs:{id:\"括号生成-22\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#括号生成-22\"}},[t._v(\"#\")]),t._v(\" \"),s(\"a\",{attrs:{href:\"https://leetcode.cn/problems/generate-parentheses/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"括号生成_22\"),s(\"OutboundLink\")],1)]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"数字 \"),s(\"code\",[t._v(\"n\")]),t._v(\" 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 \"),s(\"strong\",[t._v(\"有效的\")]),t._v(\" 括号组合。\")]),t._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[t._v('输入：n = 3\\n输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n')])])])]),t._v(\" \"),s(\"h3\",{attrs:{id:\"全排列-46\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#全排列-46\"}},[t._v(\"#\")]),t._v(\" \"),s(\"a\",{attrs:{href:\"https://leetcode.cn/problems/permutations/description/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"全排列_46\"),s(\"OutboundLink\")],1)]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"给定一个不含重复数字的数组 \"),s(\"code\",[t._v(\"nums\")]),t._v(\" ，返回其 \"),s(\"em\",[t._v(\"所有可能的全排列\")]),t._v(\" 。你可以 \"),s(\"strong\",[t._v(\"按任意顺序\")]),t._v(\" 返回答案。\")]),t._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[t._v(\"输入：nums = [1,2,3]\\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\n\")])])])]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\")]),t._v(\" \"),s(\"p\",[s(\"strong\",[t._v(\"n 皇后问题\")]),t._v(\" 研究的是如何将 \"),s(\"code\",[t._v(\"n\")]),t._v(\" 个皇后放置在 \"),s(\"code\",[t._v(\"n×n\")]),t._v(\" 的棋盘上，并且使皇后彼此之间不能相互攻击。\")]),t._v(\" \"),s(\"p\",[t._v(\"给你一个整数 \"),s(\"code\",[t._v(\"n\")]),t._v(\" ，返回所有不同的 \"),s(\"strong\",[t._v(\"n 皇后问题\")]),t._v(\" 的解决方案。\")]),t._v(\" \"),s(\"p\",[t._v(\"每一种解法包含一个不同的 \"),s(\"strong\",[t._v(\"n 皇后问题\")]),t._v(\" 的棋子放置方案，该方案中 \"),s(\"code\",[t._v(\"'Q'\")]),t._v(\" 和 \"),s(\"code\",[t._v(\"'.'\")]),t._v(\" 分别代表了皇后和空位。\")]),t._v(\" \"),s(\"p\",[s(\"strong\",[t._v(\"示例 1：\")])]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\",alt:\"img\"}})]),t._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[t._v('输入：n = 4\\n输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\\n解释：如上图所示，4 皇后问题存在两个不同的解法。\\n')])])])])])}),[],!1,null,null,null);a.default=n.exports}}]);","extractedComments":[]}