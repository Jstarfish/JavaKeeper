{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[265],{788:function(M,a,t){\"use strict\";t.r(a);var v=t(6),D=Object(v.a)({},(function(){var M=this,a=M.$createElement,t=M._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":M.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"xml-解析方式对比\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#xml-解析方式对比\"}},[M._v(\"#\")]),M._v(\" XML 解析方式对比\")]),M._v(\" \"),t(\"p\",[M._v(\"https://blog.csdn.net/wuwenxiang91322/article/details/10230363\")]),M._v(\" \"),t(\"h2\",{attrs:{id:\"dom\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dom\"}},[M._v(\"#\")]),M._v(\" DOM\")]),M._v(\" \"),t(\"p\",[M._v(\"DOM的全称是Document ObjectModel，也即文档对象模型。在应用程序中，基于DOM的XML分析器将一个XML文档转换成一个对象模型的集合（通常称DOM树），应用程序正是通过对这个对象模型的操作，来实现对XML文档数据的操作。通过DOM接口，应用程序可以在任何时候访问XML文档中的任何一部分数据，因此，这种利用DOM接口的机制也被称作随机访问机制。\")]),M._v(\" \"),t(\"p\",[M._v(\"DOM接口提供了一种通过分层对象模型来访问XML文档信息的方式，这些分层对象模型依据XML的文档结构形成了一棵节点树。无论XML文档中所描述的是什么类型的信息，即便是制表数据、项目列表或一个文档，利用DOM所生成的模型都是节点树的形式。也就是说，DOM强制使用树模型来访问XML文档中的信息。由于XML本质上就是一种分层结构，所以这种描述方法是相当有效的。\")]),M._v(\" \"),t(\"p\",[M._v(\"DOM树所提供的随机访问方式给应用程序的开发带来了很大的灵活性，它可以任意地控制整个XML文档中的内容。然而，由于DOM分析器把整个XML文档转化成DOM树放在了内存中，因此，当文档比较大或者结构比较复杂时，对内存的需求就比较高。而且，对于结构复杂的树的遍历也是一项耗时的操作。所以，DOM分析器对机器性能的要求比较高，实现效率不十分理想。不过，由于DOM分析器所采用的树结构的思想与XML文档的结构相吻合，同时鉴于随机访问所带来的方便，因此，DOM分析器还是有很广泛的使用价值的。\")]),M._v(\" \"),t(\"h2\",{attrs:{id:\"sax\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sax\"}},[M._v(\"#\")]),M._v(\" SAX\")]),M._v(\" \"),t(\"p\",[M._v(\"SAX的全称是Simple APIs for XML，也即XML简单应用程序接口。与DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过这些事件处理函数实现对XML文档的访问，因而SAX接口也被称作事件驱动接口。\")]),M._v(\" \"),t(\"p\",[M._v(\"​    SAX 解析器采用了基于事件的模型，它在解析 XML 文档的时候可以触发一系列的事件，当发现给定的tag的时候，它可以激活一个回调方法，告诉该方法制定的标签已经找到。SAX 对内存的要求通常会比较低，因为它让开发人员自己来决定所要处理的tag。特别是当开发人员只需要处理文档中所包含的部分数据时，SAX 这种扩展能力得到了更好的体现。但用 SAX 解析器的时候编码工作会比较困难，而且很难同时访问同一个文档中的多处不同数据\")]),M._v(\" \"),t(\"h2\",{attrs:{id:\"jdom\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jdom\"}},[M._v(\"#\")]),M._v(\" JDOM\")]),M._v(\" \"),t(\"p\",[M._v(\"JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。（http://jdom.org）\")]),M._v(\" \"),t(\"p\",[M._v(\"•JDOM 直接为JAVA编程服务。它利用更为强有力的JAVA语言的诸多特性（方法重载、集合概念等），把SAX和DOM的功能有效地结合起来。\")]),M._v(\" \"),t(\"p\",[M._v(\"•JDOM是用Java语言读、写、操作XML的新API函数。在直接、简单和高效的前提下，这些API函数被最大限度的优化。\")]),M._v(\" \"),t(\"p\",[M._v(\"JDOM 与 DOM 主要有两方面不同。首先，JDOM 仅使用具体类而不使用接口。这在某些方面简化了 API，但是也限制了灵活性。第二，API 大量使用了 Collections 类，简化了那些已经熟悉这些类的 Java 开发者的使用。\\n　　JDOM 文档声明其目的是“使用 20%（或更少）的精力解决 80%（或更多）Java/XML 问题”（根据学习曲线假定为 20%）。JDOM 对于大多数 Java/XML 应用程序来说当然是有用的，并且大多数开发者发现 API 比 DOM 容易理解得多。JDOM 还包括对程序行为的相当广泛检查以防止用户做任何在 XML 中无意义的事。然而，它仍需要您充分理解 XML 以便做一些超出基本的工作（或者甚至理解某些情况下的错误）。这也许是比学习 DOM 或 JDOM 接口都更有意义的工作。\\n　　JDOM 自身不包含解析器。它通常使用 SAX2 解析器来解析和验证输入 XML 文档（尽管它还可以将以前构造的 DOM 表示作为输入）。它包含一些转换器以将 JDOM 表示输出成 SAX2 事件流、DOM 模型或 XML 文本文档。JDOM 是在 Apache 许可证变体下发布的开放源码。\")]),M._v(\" \"),t(\"h2\",{attrs:{id:\"dom4j\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dom4j\"}},[M._v(\"#\")]),M._v(\" Dom4j\")]),M._v(\" \"),t(\"p\",[M._v(\"官网：DOM4Jhttp://dom4j.sourceforge.net/\")]),M._v(\" \"),t(\"p\",[M._v(\"虽然 DOM4J 代表了完全独立的开发结果，但最初，它是 JDOM 的一种智能分支。它合并了许多超出基本 XML 文档表示的功能，包括集成的 XPath 支持、XML Schema 支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项，它通过 DOM4J API 和标准 DOM 接口具有并行访问功能。从 2000 下半年开始，它就一直处于开发之中。\")]),M._v(\" \"),t(\"p\",[M._v(\"为支持所有这些功能，DOM4J 使用接口和抽象基本类方法。DOM4J 大量使用了 API 中的 Collections 类，但是在许多情况下，它还提供一些替代方法以允许更好的性能或更直接的编码方法。直接好处是，虽然 DOM4J 付出了更复杂的 API 的代价，但是它提供了比 JDOM 大得多的灵活性。\")]),M._v(\" \"),t(\"p\",[M._v(\"在添加灵活性、XPath 集成和对大文档处理的目标时，DOM4J 的目标与 JDOM 是一样的：针对 Java 开发者的易用性和直观操作。它还致力于成为比 JDOM 更完整的解决方案，实现在本质上处理所有 Java/XML 问题的目标。在完成该目标时，它比 JDOM 更少强调防止不正确的应用程序行为。\")]),M._v(\" \"),t(\"p\",[M._v(\"DOM4J 是一个非常非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看到越来越多的 Java 软件都在使用 DOM4J 来读写 XML，特别值得一提的是连 Sun 的 JAXM 也在用 DOM4J。\")]),M._v(\" \"),t(\"p\",[t(\"strong\",[M._v(\"Dom解析：\")])]),M._v(\" \"),t(\"p\",[M._v(\"​    在内存中创建一个DOM树，该结构通常需要加载整个文档然后才能做工作。由于它是基于信息层次的，因而DOM被认为是基于树或基于对象的，树在内存中是持久的，因此可以修改它以便应用程序能对数据和结构作出更改能随机访问文件内容，也可以修改原文件内容.\")]),M._v(\" \"),t(\"p\",[t(\"strong\",[M._v(\"SAX解析 ：\")])]),M._v(\" \"),t(\"p\",[M._v(\"​    SAX处理的优点非常类似于流媒体的优点。分析能够立即开始，而不是等待所有的数据被处理。SAX解析器采用了基于事件的模型，它在解析XML文档的时候可以触发一系列的事件，当发现给定的tag的时候，它可以激活一个回调方法，告诉该方法制定的标签已经找到。而且，由于应用程序只是在读取数据时检查数据，因此不需要将数据存储在内存中。这对于大型文档来说是个巨大的优点线性解析，不能随机访问，也无法修改原文件\")]),M._v(\" \"),t(\"p\",[t(\"strong\",[M._v(\"JDOM解析：\")])]),M._v(\" \"),t(\"p\",[M._v(\"​    JDOM的目的是成为Java特定文档模型,它简化与XML的交互并且比使用DOM实现更快.JDOM仅使用具体类而不使用接口。这在某些方面简化了API，但是也限制了灵活性。第二，API大量使用了Collections类，简化了那些已经熟悉这些类的Java开发者的使用。\")]),M._v(\" \"),t(\"p\",[t(\"strong\",[M._v(\"DOM4j：\")])]),M._v(\" \"),t(\"p\",[M._v(\"​    解析 DOM4J使用接口和抽象基本类方法。DOM4J大量使用了API中的Collections类，但是在许多情况下，它还提供一些替代方法以允许更好的性能或更直接的编码方法。直接好处是，虽然DOM4J付出了更复杂的API的代价，但是它提供了比JDOM大得多的灵活性。\")])])}),[],!1,null,null,null);a.default=D.exports}}]);","extractedComments":[]}