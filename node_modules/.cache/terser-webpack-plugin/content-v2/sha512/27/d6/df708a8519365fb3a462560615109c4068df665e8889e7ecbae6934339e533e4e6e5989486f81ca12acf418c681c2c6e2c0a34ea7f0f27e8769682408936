{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[206],{754:function(_,v,t){\"use strict\";t.r(v);var e=t(6),a=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":_.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"mysql-三万字精华总结-面试100-问-和面试官扯皮绰绰有余\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-三万字精华总结-面试100-问-和面试官扯皮绰绰有余\"}},[_._v(\"#\")]),_._v(\" MySQL 三万字精华总结 + 面试100 问，和面试官扯皮绰绰有余\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"写在之前：不建议那种上来就是各种面试题罗列，然后背书式的去记忆，对技术的提升帮助很小，对正经面试也没什么帮助，有点东西的面试官深挖下就懵逼了。\")]),_._v(\" \"),t(\"p\",[_._v(\"个人建议把面试题看作是费曼学习法中的回顾、简化的环节，准备面试的时候，跟着题目先自己讲给自己听，看看自己会满意吗，不满意就继续学习这个点，如此反复，好的offer离你不远的，奥利给\")])]),_._v(\" \"),t(\"h2\",{attrs:{id:\"一、mysql架构\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、mysql架构\"}},[_._v(\"#\")]),_._v(\" 一、MySQL架构\")]),_._v(\" \"),t(\"p\",[_._v(\"和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，\"),t(\"strong\",[_._v(\"插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离\")]),_._v(\"。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj0sffrl6ij30t30gqdlf.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"连接层\")]),_._v(\"：最上层是一些客户端和连接服务。\"),t(\"strong\",[_._v(\"主要完成一些类似于连接处理、授权认证、及相关的安全方案\")]),_._v(\"。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"服务层\")]),_._v(\"：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"引擎层\")]),_._v(\"：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"存储层\")]),_._v(\"：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"画出 MySQL 架构图，这种变态问题都能问的出来\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 的查询流程具体是？or  一条SQL语句在MySQL中如何执行的？\")])]),_._v(\" \"),t(\"p\",[_._v(\"客户端请求 ---\\x3e 连接器（验证用户身份，给予权限）  ---\\x3e 查询缓存（存在缓存则直接返回，不存在则执行后续操作） ---\\x3e 分析器（对SQL进行词法分析和语法分析操作）  ---\\x3e 优化器（主要对执行的sql优化选择最优的执行方案方法）  ---\\x3e 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） ---\\x3e 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://pic2.zhimg.com/80/v2-0d2070e8f84c4801adbfa03bda1f98d9_720w.jpg\",alt:\"img\"}})]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"说说MySQL有哪些存储引擎？都有哪些区别？\")])]),_._v(\" \"),t(\"h2\",{attrs:{id:\"二、存储引擎\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、存储引擎\"}},[_._v(\"#\")]),_._v(\" 二、存储引擎\")]),_._v(\" \"),t(\"p\",[_._v(\"存储引擎是 MySQL 的组件，用于处理不同表类型的 SQL 操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。\")]),_._v(\" \"),t(\"p\",[_._v(\"使用哪一种引擎可以灵活选择，\"),t(\"strong\",[t(\"mark\",[_._v(\"一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求\")])]),_._v(\"，使用合适的存储引擎，将会提高整个数据库的性能 。\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL服务器使用\"),t(\"strong\",[_._v(\"可插拔\")]),_._v(\"的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"查看存储引擎\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#查看存储引擎\"}},[_._v(\"#\")]),_._v(\" 查看存储引擎\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"-- 查看支持的存储引擎\\nSHOW ENGINES\\n\\n-- 查看默认存储引擎\\nSHOW VARIABLES LIKE 'storage_engine'\\n\\n--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！\\nshow create table tablename\\n\\n--准确查看某个数据库中的某一表所使用的存储引擎\\nshow table status like 'tablename'\\nshow table status from database where name=\\\"tablename\\\"\\n\")])])]),t(\"h3\",{attrs:{id:\"设置存储引擎\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#设置存储引擎\"}},[_._v(\"#\")]),_._v(\" 设置存储引擎\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"-- 建表时指定存储引擎。默认的就是INNODB，不需要设置\\nCREATE TABLE t1 (i INT) ENGINE = INNODB;\\nCREATE TABLE t2 (i INT) ENGINE = CSV;\\nCREATE TABLE t3 (i INT) ENGINE = MEMORY;\\n\\n-- 修改存储引擎\\nALTER TABLE t ENGINE = InnoDB;\\n\\n-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎\\nSET default_storage_engine=NDBCLUSTER;\\n\")])])]),t(\"p\",[_._v(\"默认情况下，每当 \"),t(\"code\",[_._v(\"CREATE TABLE\")]),_._v(\" 或 \"),t(\"code\",[_._v(\"ALTER TABLE\")]),_._v(\" 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 \"),t(\"code\",[_._v(\"NO_ENGINE_SUBSTITUTION SQL\")]),_._v(\" 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"存储引擎对比\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#存储引擎对比\"}},[_._v(\"#\")]),_._v(\" 存储引擎对比\")]),_._v(\" \"),t(\"p\",[_._v(\"常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 现在是 MySQL 默认的存储引擎，支持\"),t(\"strong\",[_._v(\"事务、行级锁定和外键\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"文件存储结构对比\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#文件存储结构对比\"}},[_._v(\"#\")]),_._v(\" 文件存储结构对比\")]),_._v(\" \"),t(\"p\",[_._v(\"在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 \"),t(\"code\",[_._v(\".frm\")]),_._v(\" 文件，\"),t(\"code\",[_._v(\".frm\")]),_._v(\" 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有\"),t(\"code\",[_._v(\".frm\")]),_._v(\"文件，命名方式为 数据表名.frm，如user.frm。\")]),_._v(\" \"),t(\"p\",[_._v(\"查看MySQL 数据保存在哪里：\"),t(\"code\",[_._v(\"show variables like 'data%'\")])]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM 物理文件结构为：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"code\",[_._v(\".frm\")]),_._v(\"文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\".MYD\")]),_._v(\" (\"),t(\"code\",[_._v(\"MYData\")]),_._v(\") 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\".MYI\")]),_._v(\" (\"),t(\"code\",[_._v(\"MYIndex\")]),_._v(\")文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息\")])]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 物理文件结构为：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"code\",[_._v(\".frm\")]),_._v(\" 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"code\",[_._v(\".ibd\")]),_._v(\" 文件或 \"),t(\"code\",[_._v(\".ibdata\")]),_._v(\" 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用\"),t(\"strong\",[_._v(\"共享表空间\")]),_._v(\"存放存储数据，还是用\"),t(\"strong\",[_._v(\"独享表空间\")]),_._v(\"存放存储数据。\")]),_._v(\" \"),t(\"p\",[_._v(\"独享表空间存储方式使用\"),t(\"code\",[_._v(\".ibd\")]),_._v(\"文件，并且每个表一个\"),t(\"code\",[_._v(\".ibd\")]),_._v(\"文件\\n共享表空间存储方式使用\"),t(\"code\",[_._v(\".ibdata\")]),_._v(\"文件，所有表共同使用一个\"),t(\"code\",[_._v(\".ibdata\")]),_._v(\"文件（或多个，可自己配置）\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"ps：正经公司，这些都有专业运维去做，数据备份、恢复啥的，让我一个 Javaer 搞这的话，加钱不？\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"面试这么回答\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#面试这么回答\"}},[_._v(\"#\")]),_._v(\" 面试这么回答\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；\")]),_._v(\" \"),t(\"li\",[_._v(\"InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；\")]),_._v(\" \"),t(\"li\",[_._v(\"InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。\")]),_._v(\" \"),t(\"li\",[_._v(\"InnoDB 不保存表的具体行数，执行\"),t(\"code\",[_._v(\"select count(*) from table\")]),_._v(\" 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；\")]),_._v(\" \"),t(\"li\",[_._v(\"InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；\")])]),_._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[_._v(\"对比项\")]),_._v(\" \"),t(\"th\",[_._v(\"MyISAM\")]),_._v(\" \"),t(\"th\",[_._v(\"InnoDB\")])])]),_._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[_._v(\"主外键\")]),_._v(\" \"),t(\"td\",[_._v(\"不支持\")]),_._v(\" \"),t(\"td\",[_._v(\"支持\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"事务\")]),_._v(\" \"),t(\"td\",[_._v(\"不支持\")]),_._v(\" \"),t(\"td\",[_._v(\"支持\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"行表锁\")]),_._v(\" \"),t(\"td\",[_._v(\"表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作\")]),_._v(\" \"),t(\"td\",[_._v(\"行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"缓存\")]),_._v(\" \"),t(\"td\",[_._v(\"只缓存索引，不缓存真实数据\")]),_._v(\" \"),t(\"td\",[_._v(\"不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"表空间\")]),_._v(\" \"),t(\"td\",[_._v(\"小\")]),_._v(\" \"),t(\"td\",[_._v(\"大\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"关注点\")]),_._v(\" \"),t(\"td\",[_._v(\"性能\")]),_._v(\" \"),t(\"td\",[_._v(\"事务\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"默认安装\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")])])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？\")])]),_._v(\" \"),t(\"p\",[_._v(\"如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；\")]),_._v(\" \"),t(\"p\",[_._v(\"如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"哪个存储引擎执行 select count(*) 更快，为什么?\")])]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。\")]),_._v(\" \"),t(\"h2\",{attrs:{id:\"三、数据类型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、数据类型\"}},[_._v(\"#\")]),_._v(\" 三、数据类型\")]),_._v(\" \"),t(\"p\",[_._v(\"主要包括以下五大类：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT\")]),_._v(\" \"),t(\"li\",[_._v(\"浮点数类型：FLOAT、DOUBLE、DECIMAL\")]),_._v(\" \"),t(\"li\",[_._v(\"字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB\")]),_._v(\" \"),t(\"li\",[_._v(\"日期类型：Date、DateTime、TimeStamp、Time、Year\")]),_._v(\" \"),t(\"li\",[_._v(\"其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等\")])]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf29eij8zsj316x0u0gsn.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf29fk2f4rj31ac0gi0w3.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf29g2azwtj31a80nywit.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"h3\",{attrs:{id:\"char-和-varchar-的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#char-和-varchar-的区别\"}},[_._v(\"#\")]),_._v(\" CHAR 和 VARCHAR 的区别？\")]),_._v(\" \"),t(\"p\",[_._v(\"char是固定长度，varchar长度可变：\")]),_._v(\" \"),t(\"p\",[_._v(\"char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。\")]),_._v(\" \"),t(\"p\",[_._v(\"存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间\")]),_._v(\" \"),t(\"p\",[_._v(\"相同点：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"char(n)，varchar(n)中的n都代表字符的个数\")]),_._v(\" \"),t(\"li\",[_._v(\"超过char，varchar最大长度n的限制后，字符串会被截断。\")])]),_._v(\" \"),t(\"p\",[_._v(\"不同点：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0<=length<255）或加2（length>255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。\")]),_._v(\" \"),t(\"li\",[_._v(\"能存储的最大空间限制不一样：char的存储上限为255字节。\")]),_._v(\" \"),t(\"li\",[_._v(\"char在存储时会截断尾部的空格，而varchar不会。\")])]),_._v(\" \"),t(\"p\",[_._v(\"char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"列的字符串类型可以是什么\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#列的字符串类型可以是什么\"}},[_._v(\"#\")]),_._v(\" 列的字符串类型可以是什么？\")]),_._v(\" \"),t(\"p\",[_._v(\"字符串类型是：SET、BLOB、ENUM、CHAR、TEXT、VARCHAR\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"blob和text有什么区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#blob和text有什么区别\"}},[_._v(\"#\")]),_._v(\" BLOB和TEXT有什么区别？\")]),_._v(\" \"),t(\"p\",[_._v(\"BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB\")]),_._v(\" \"),t(\"p\",[_._v(\"TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。\")]),_._v(\" \"),t(\"p\",[_._v(\"BLOB 保存二进制数据，TEXT 保存字符数据。\")]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"四、索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#四、索引\"}},[_._v(\"#\")]),_._v(\" 四、索引\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"说说你对 MySQL 索引的理解？\")]),_._v(\" \"),t(\"p\",[_._v(\"数据库索引的原理，为什么要用 B+树，为什么不用二叉树？\")]),_._v(\" \"),t(\"p\",[_._v(\"聚集索引与非聚集索引的区别？\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB引擎中的索引策略，了解过吗？\")]),_._v(\" \"),t(\"p\",[_._v(\"创建索引的方式有哪些？\")]),_._v(\" \"),t(\"p\",[_._v(\"聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"MYSQL官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构，所以说\"),t(\"strong\",[_._v(\"索引的本质是：数据结构\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，\"),t(\"font\",{attrs:{color:\"#FF0000\"}},[t(\"strong\",[_._v(\"数据库还维护者一个满足特定查找算法的数据结构\")])]),_._v(\"，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例。\")],1),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf3u9tli6gj30gt08xdg2.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址\")]),_._v(\" \"),t(\"p\",[_._v(\"为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"索引本身也很大，不可能全部存储在内存中，\"),t(\"strong\",[_._v(\"一般以索引文件的形式存储在磁盘上\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"平常说的索引，没有特别指明的话，就是 B+ 树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用 B+ 树索引，统称索引。此外还有哈希索引等。\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"基本语法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基本语法\"}},[_._v(\"#\")]),_._v(\" 基本语法：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"创建：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"创建索引：\"),t(\"code\",[_._v(\"CREATE [UNIQUE] INDEX indexName ON mytable(username(length));\")])]),_._v(\" \"),t(\"p\",[_._v(\"如果是 CHAR，VARCHAR 类型，length 可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"修改表结构(添加索引)：\"),t(\"code\",[_._v(\"ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)\")])])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"删除：\"),t(\"code\",[_._v(\"DROP INDEX [indexName] ON mytable;\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"查看：\"),t(\"code\",[_._v(\"SHOW INDEX FROM table_name\\\\G\")]),_._v(\"             --可以通过添加 \\\\G 来格式化输出信息。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"使用ALERT命令\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"code\",[_._v(\"ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):\")]),_._v(\" 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\"ALTER TABLE tbl_name ADD UNIQUE index_name (column_list\")]),_._v(\" 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\"ALTER TABLE tbl_name ADD INDEX index_name (column_list)\")]),_._v(\" 添加普通索引，索引值可出现多次。\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\"ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)\")]),_._v(\"该语句指定了索引为 FULLTEXT ，用于全文索引。\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"优势\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优势\"}},[_._v(\"#\")]),_._v(\" 优势\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"提高数据检索效率，降低数据库IO成本\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"降低数据排序的成本，降低CPU的消耗\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"劣势\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#劣势\"}},[_._v(\"#\")]),_._v(\" 劣势\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存\")]),_._v(\" \"),t(\"li\",[_._v(\"虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。\\n因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，\\n都会调整因为更新所带来的键值变化后的索引信息\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql索引分类\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql索引分类\"}},[_._v(\"#\")]),_._v(\" MySQL索引分类\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"数据结构角度\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据结构角度\"}},[_._v(\"#\")]),_._v(\" 数据结构角度\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"B+树索引\")]),_._v(\" \"),t(\"li\",[_._v(\"Hash索引\")]),_._v(\" \"),t(\"li\",[_._v(\"Full-Text全文索引\")]),_._v(\" \"),t(\"li\",[_._v(\"R-Tree索引\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"从物理存储角度\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#从物理存储角度\"}},[_._v(\"#\")]),_._v(\" 从物理存储角度\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"聚集索引（clustered index）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"非聚集索引（non-clustered index），也叫辅助索引（secondary index）\")]),_._v(\" \"),t(\"p\",[_._v(\"聚集索引和非聚集索引都是B+树结构\")])])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"从逻辑角度\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#从逻辑角度\"}},[_._v(\"#\")]),_._v(\" 从逻辑角度\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"主键索引：主键索引是一种特殊的唯一索引，不允许有空值\")]),_._v(\" \"),t(\"li\",[_._v(\"普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引\")]),_._v(\" \"),t(\"li\",[_._v(\"多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合\")]),_._v(\" \"),t(\"li\",[_._v(\"唯一索引或者非唯一索引\")]),_._v(\" \"),t(\"li\",[_._v(\"空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。\\nMYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引\")]),_._v(\" \"),t(\"p\",[_._v(\"聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？\")]),_._v(\" \"),t(\"p\",[_._v(\"使用索引查询一定能提高查询的性能吗？为什么?\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql索引结构\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql索引结构\"}},[_._v(\"#\")]),_._v(\" MySQL索引结构\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面\")]),_._v(\"。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"b-tree索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#b-tree索引\"}},[_._v(\"#\")]),_._v(\" B+Tree索引\")]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"先了解下 B-Tree 和 B+Tree 的区别\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"b-tree\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#b-tree\"}},[_._v(\"#\")]),_._v(\" B-Tree\")]),_._v(\" \"),t(\"p\",[_._v(\"B-Tree是为磁盘等外存储设备设计的一种平衡查找树。\")]),_._v(\" \"),t(\"p\",[_._v(\"系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 \"),t(\"code\",[_._v(\"innodb_page_size\")]),_._v(\" 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：\"),t(\"code\",[_._v(\"show variables like 'innodb_page_size';\")])]),_._v(\" \"),t(\"p\",[_._v(\"而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。\")]),_._v(\" \"),t(\"p\",[_._v(\"B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。\")]),_._v(\" \"),t(\"p\",[_._v(\"一棵m阶的B-Tree有如下特性：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"每个节点最多有m个孩子\")]),_._v(\" \"),t(\"li\",[_._v(\"除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。\")]),_._v(\" \"),t(\"li\",[_._v(\"若根节点不是叶子节点，则至少有2个孩子\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"所有叶子节点都在同一层，且不包含其它关键字信息\")])]),_._v(\" \"),t(\"li\",[_._v(\"每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）\")]),_._v(\" \"),t(\"li\",[_._v(\"关键字的个数n满足：ceil(m/2)-1 <= n <= m-1\")]),_._v(\" \"),t(\"li\",[_._v(\"ki(i=1,…n)为关键字，且关键字升序排序\")]),_._v(\" \"),t(\"li\",[_._v(\"Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)\")])]),_._v(\" \"),t(\"p\",[_._v(\"B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gg1de1fj9qj30ou08aaas.jpg\",alt:\"索引\"}})]),_._v(\" \"),t(\"p\",[_._v(\"每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。\")]),_._v(\" \"),t(\"p\",[_._v(\"模拟查找关键字29的过程：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】\")]),_._v(\" \"),t(\"li\",[_._v(\"比较关键字29在区间（17,35），找到磁盘块1的指针P2。\")]),_._v(\" \"),t(\"li\",[_._v(\"根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】\")]),_._v(\" \"),t(\"li\",[_._v(\"比较关键字29在区间（26,30），找到磁盘块3的指针P2。\")]),_._v(\" \"),t(\"li\",[_._v(\"根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】\")]),_._v(\" \"),t(\"li\",[_._v(\"在磁盘块8中的关键字列表中找到关键字29。\")])]),_._v(\" \"),t(\"p\",[_._v(\"分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"b-tree-2\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#b-tree-2\"}},[_._v(\"#\")]),_._v(\" B+Tree\")]),_._v(\" \"),t(\"p\",[_._v(\"B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。\")]),_._v(\" \"),t(\"p\",[_._v(\"从上一节中的 B-Tree 结构图中可以看到每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，\"),t(\"strong\",[_._v(\"所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上\")]),_._v(\"，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。\")]),_._v(\" \"),t(\"p\",[_._v(\"B+Tree相对于B-Tree有几点不同：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"非叶子节点只存储键值信息；\")]),_._v(\" \"),t(\"li\",[_._v(\"所有叶子节点之间都有一个链指针；\")]),_._v(\" \"),t(\"li\",[_._v(\"数据记录都存放在叶子节点中\")])]),_._v(\" \"),t(\"p\",[_._v(\"将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：\\n\"),t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf3t57jvq1j30sc0aj0tj.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。\")]),_._v(\" \"),t(\"p\",[_._v(\"可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。\")]),_._v(\" \"),t(\"p\",[_._v(\"实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。\")]),_._v(\" \"),t(\"p\",[_._v(\"B+Tree性质\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"通过上面的分析，我们知道 IO 次数取决于 b+ 数的高度h，假设当前数据表的数据为 N，每个磁盘块的数据项的数量是 m，则有 h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。\")]),_._v(\" \"),t(\"li\",[_._v(\"当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个\"),t(\"strong\",[_._v(\"比较因子\")]),_._v(\"，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即\"),t(\"strong\",[_._v(\"索引的最左匹配特性\")]),_._v(\"。\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"数据库为什么使用b-树而不是b树\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据库为什么使用b-树而不是b树\"}},[_._v(\"#\")]),_._v(\" 数据库为什么使用B+树而不是B树\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"B 树只适合随机检索，而 B+ 树同时支持随机检索和顺序检索；\")]),_._v(\" \"),t(\"li\",[_._v(\"B+ 树空间利用率更高，可减少 I/O 次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗。B+ 树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比 B 树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO 读写次数也就降低了。而 IO 读写次数是影响索引检索效率的最大因素；\")]),_._v(\" \"),t(\"li\",[_._v(\"B+ 树的查询效率更加稳定。B 树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在 B+ 树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。\")]),_._v(\" \"),t(\"li\",[_._v(\"B- 树在提高了磁盘 IO 性能的同时并没有解决元素遍历的效率低下的问题。B+ 树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。\")]),_._v(\" \"),t(\"li\",[_._v(\"增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"为什么-mysql-会选择-b-tree-当索引数据结构\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么-mysql-会选择-b-tree-当索引数据结构\"}},[_._v(\"#\")]),_._v(\" 为什么 MySQL 会选择 B+Tree 当索引数据结构\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"考察两个方面： B+Tree 的索引原理； B+Tree 索引相比于其他索引类型的优势。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"B+Tree 相对于 B 树 索引结构的优势：\")])]),_._v(\" \"),t(\"p\",[_._v(\"B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。\")]),_._v(\" \"),t(\"p\",[_._v(\"另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"B+Tree 相对于二叉树索引结构的优势：\")])]),_._v(\" \"),t(\"p\",[_._v(\"对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据（这里的查询参考上面 B+Tree 的聚簇索引的查询过程）。\")]),_._v(\" \"),t(\"p\",[_._v(\"而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"B+Tree 相对于 Hash 表存储结构的优势\")]),_._v(\"：\")]),_._v(\" \"),t(\"p\",[_._v(\"我们知道范围查询是 MySQL 中常见的场景，但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"myisam主键索引与辅助索引的结构\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#myisam主键索引与辅助索引的结构\"}},[_._v(\"#\")]),_._v(\" MyISAM主键索引与辅助索引的结构\")]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM 引擎的索引文件和数据文件是分离的。\"),t(\"strong\",[t(\"mark\",[_._v(\"MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址\")])]),_._v('。索引文件与数据文件分离，这样的索引称为\"'),t(\"mark\",[t(\"strong\",[_._v(\"非聚簇索引\")])]),_._v('\"。MyISAM 的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。')]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gewoy5bddkj31bp0u04lv.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"在 MyISAM 中，索引（含叶子节点）存放在单独的 .myi 文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。\")]),_._v(\" \"),t(\"p\",[_._v(\"主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。\")]),_._v(\" \"),t(\"p\",[_._v(\"通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"innodb主键索引与辅助索引的结构\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#innodb主键索引与辅助索引的结构\"}},[_._v(\"#\")]),_._v(\" InnoDB主键索引与辅助索引的结构\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录\")]),_._v(\"（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，\"),t(\"strong\",[_._v(\"InnoDB的数据文件本身就是主键索引文件\")]),_._v('，这样的索引被称为\"'),t(\"mark\",[_._v(\"“聚簇索引”\")]),_._v(\"，一个表只能有一个聚簇索引。\")]),_._v(\" \"),t(\"h6\",{attrs:{id:\"主键索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#主键索引\"}},[_._v(\"#\")]),_._v(\" 主键索引：\")]),_._v(\" \"),t(\"p\",[_._v(\"我们知道InnoDB索引是聚集索引，它的索引和数据是存入同一个 .idb 文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的 id、stu_id、name数据项。\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gewoy2lhr5j320d0u016k.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb 的数据文件可以按照表来切分（只需要开启\"),t(\"code\",[_._v(\"innodb_file_per_table)\")]),_._v(\"，切分后存放在\"),t(\"code\",[_._v(\"xxx.ibd\")]),_._v(\"中，默认不切分，存放在\"),t(\"code\",[_._v(\"xxx.ibdata\")]),_._v(\"中。\")]),_._v(\" \"),t(\"h6\",{attrs:{id:\"辅助-非主键-索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#辅助-非主键-索引\"}},[_._v(\"#\")]),_._v(\" 辅助（非主键）索引：\")]),_._v(\" \"),t(\"p\",[_._v(\"这次我们以示例中学生表中的name列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。\")]),_._v(\" \"),t(\"p\",[_._v(\"这就意味着，对name列进行条件搜索，需要两个步骤：\")]),_._v(\" \"),t(\"p\",[_._v(\"① 在辅助索引上检索name，到达其叶子节点获取对应的主键；\")]),_._v(\" \"),t(\"p\",[_._v(\"② 使用主键在主索引上再进行对应的检索操作\")]),_._v(\" \"),t(\"p\",[_._v(\"这也就是所谓的“\"),t(\"strong\",[_._v(\"回表查询\")]),_._v(\"”\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gewsc7l623j320r0u0gwt.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"InnoDB 索引结构需要注意的点\")])]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"数据文件本身就是索引文件\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"表数据文件本身就是按 B+Tree 组织的一个索引结构文件\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"聚集索引中叶节点包含了完整的数据记录\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"InnoDB 表必须要有主键，并且推荐使用整型自增主键\")])])]),_._v(\" \"),t(\"p\",[_._v(\"正如我们上面介绍 InnoDB 存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"那为什么推荐使用整型自增主键而不是选择 UUID？\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"UUID 是字符串，比整型消耗更多的存储空间；\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"在 B+ 树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行 where id > 5 && id < 20 的条件查询语句。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"为什么非主键索引结构叶子节点存储的是主键值？\")])]),_._v(\" \"),t(\"p\",[_._v(\"保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"hash索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hash索引\"}},[_._v(\"#\")]),_._v(\" Hash索引\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。\")]),_._v(\" \"),t(\"p\",[_._v(\"检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL目前有Memory引擎和NDB引擎支持Hash索引。\")])])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"full-text全文索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#full-text全文索引\"}},[_._v(\"#\")]),_._v(\" full-text全文索引\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。\")])])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"r-tree空间索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#r-tree空间索引\"}},[_._v(\"#\")]),_._v(\" R-Tree空间索引\")]),_._v(\" \"),t(\"p\",[_._v(\"空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"innodb表为什么要建议用自增列做主键\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#innodb表为什么要建议用自增列做主键\"}},[_._v(\"#\")]),_._v(\" InnoDB表为什么要建议用自增列做主键\")]),_._v(\" \"),t(\"p\",[_._v(\"1、InnoDB引擎表是基于B+树的索引组织表(IOT)\")]),_._v(\" \"),t(\"p\",[_._v(\"关于B+树\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"http://images2015.cnblogs.com/blog/268981/201510/268981-20151009211335362-543150641.jpg\",alt:\"img\"}})]),_._v(\" \"),t(\"p\",[_._v(\"（图片来源于网上）\")]),_._v(\" \"),t(\"p\",[_._v(\"B+ 树的特点:\")]),_._v(\" \"),t(\"p\",[_._v(\"（1）所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的;\")]),_._v(\" \"),t(\"p\",[_._v(\"（2）不可能在非叶子结点命中;\")]),_._v(\" \"),t(\"p\",[_._v(\"（3）非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层;\")]),_._v(\" \"),t(\"p\",[_._v(\"2、如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。\")]),_._v(\" \"),t(\"p\",[_._v(\"3、数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）\")]),_._v(\" \"),t(\"p\",[_._v(\"4、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页\")]),_._v(\" \"),t(\"p\",[_._v(\"5、如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。\")]),_._v(\" \"),t(\"p\",[_._v(\"综上总结，如果 InnoDB 表的数据写入顺序能和 B+ 树索引的叶子节点顺序一致的话，这时候存取效率是最高的，也就是下面这几种情况的存取效率最高：\")]),_._v(\" \"),t(\"p\",[_._v(\"1、使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致；\")]),_._v(\" \"),t(\"p\",[_._v(\"2、该表不指定自增列做主键，同时也没有可以被选为主键的唯一索引(上面的条件)，这时候InnoDB会选择内置的ROWID作为主键，写入顺序和ROWID增长顺序一致；\\n除此以外，如果一个InnoDB表又没有显示主键，又有可以被选择为主键的唯一索引，但该唯一索引可能不是递增关系时(例如字符串、UUID、多字段联合唯一索引的情况)，该表的存取效率就会比较差。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"页分裂\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#页分裂\"}},[_._v(\"#\")]),_._v(\" 页分裂\")]),_._v(\" \"),t(\"p\",[_._v(\"http://www.uxys.com/html/MySQL/20190722/70361.html\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"哪些情况需要创建索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#哪些情况需要创建索引\"}},[_._v(\"#\")]),_._v(\" 哪些情况需要创建索引\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"主键自动建立唯一索引\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"频繁作为查询条件的字段\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"查询中与其他表关联的字段，外键关系建立索引\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"单键/组合索引的选择问题，高并发下倾向创建组合索引\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"查询中排序的字段，排序字段通过索引访问大幅提高排序速度\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"查询中统计或分组字段\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"哪些情况不要创建索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#哪些情况不要创建索引\"}},[_._v(\"#\")]),_._v(\" 哪些情况不要创建索引\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"表记录太少\")]),_._v(\" \"),t(\"li\",[_._v(\"经常增删改的表\")]),_._v(\" \"),t(\"li\",[_._v(\"数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）\")]),_._v(\" \"),t(\"li\",[_._v(\"频繁更新的字段不适合创建索引（会加重IO负担）\")]),_._v(\" \"),t(\"li\",[_._v(\"where条件里用不到的字段不创建索引\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql高效索引\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql高效索引\"}},[_._v(\"#\")]),_._v(\" MySQL高效索引\")]),_._v(\" \"),t(\"p\",[_._v(\"https://www.cnblogs.com/myseries/p/11265849.html\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"覆盖索引\")]),_._v(\"（Covering Index），或者叫索引覆盖， 也就是平时所说的不需要回表操作\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"就是 select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL 可以利用索引返回 select 列表中的字段，而不必根据索引再次读取数据文件，换句话说\"),t(\"strong\",[_._v(\"查询列要被所建的索引覆盖\")]),_._v(\"。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"判断标准\")])]),_._v(\" \"),t(\"p\",[_._v(\"使用 explain，可以通过输出的 extra 列来判断，对于一个索引覆盖查询，显示为\"),t(\"strong\",[_._v(\"using index\")]),_._v(\"，MySQL 查询优化器在执行查询前会决定是否有索引覆盖查询\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"常见问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常见问题\"}},[_._v(\"#\")]),_._v(\" 常见问题\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"非聚簇索引一定会回表查询吗\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#非聚簇索引一定会回表查询吗\"}},[_._v(\"#\")]),_._v(\" \"),t(\"strong\",[_._v(\"非聚簇索引一定会回表查询吗?\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。\")]),_._v(\" \"),t(\"p\",[_._v(\"举个简单的例子：假设我们在员工表的年龄上建立了索引，那么当进行的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-sql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"select\")]),_._v(\" age \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"from\")]),_._v(\" employee \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"where\")]),_._v(\" age \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[_._v(\"<\")]),_._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[_._v(\"20\")]),_._v(\"\\n\")])])])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"主键索引和唯一索引的区别-mysql-唯一索引的字段值-允许多个-null-值存在吗\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#主键索引和唯一索引的区别-mysql-唯一索引的字段值-允许多个-null-值存在吗\"}},[_._v(\"#\")]),_._v(\" 主键索引和唯一索引的区别，Mysql 唯一索引的字段值 允许多个 NULL 值存在吗\")]),_._v(\" \"),t(\"p\",[_._v(\"主键索引是特殊的唯一索引，唯一索引查询会涉及到“回表”操作\")]),_._v(\" \"),t(\"p\",[_._v(\"MYSQL 引擎innodb ，设置了唯一索引的列值 允许 多个NULL值存在。\")]),_._v(\" \"),t(\"p\",[_._v(\"因为这里 NULL 的定义 ，是指 未知值。 所以多个 NULL ，都是未知的，不能说它们是相等的，也不能说是不等，就是未知的。所以多个NULL的存在是不违反唯一约束的。\")]),_._v(\" \"),t(\"h2\",{attrs:{id:\"五、mysql查询\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#五、mysql查询\"}},[_._v(\"#\")]),_._v(\" 五、MySQL查询\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"count(*) 和 count(1)和count(列名)区别   ps：这道题说法有点多\")])]),_._v(\" \"),t(\"p\",[_._v(\"执行效果上：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL\")]),_._v(\" \"),t(\"li\",[_._v(\"count(1)包括了所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL\")]),_._v(\" \"),t(\"li\",[_._v(\"count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是指空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。\")])]),_._v(\" \"),t(\"p\",[_._v(\"执行效率上：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"列名为主键，count(列名)会比count(1)快\")]),_._v(\" \"),t(\"li\",[_._v(\"列名不为主键，count(1)会比count(列名)快\")]),_._v(\" \"),t(\"li\",[_._v(\"如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)\")]),_._v(\" \"),t(\"li\",[_._v(\"如果有主键，则 select count（主键）的执行效率是最优的\")]),_._v(\" \"),t(\"li\",[_._v(\"如果表只有一个字段，则 select count(*) 最优。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql中-in和-exists-的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql中-in和-exists-的区别\"}},[_._v(\"#\")]),_._v(\" MySQL中 in和 exists 的区别？\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false\")]),_._v(\" \"),t(\"li\",[_._v(\"in：in查询相当于多个or条件的叠加\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM A WHERE A.id IN (SELECT id FROM B);\\nSELECT * FROM A WHERE EXISTS (SELECT * from B WHERE B.id = A.id);\\n\")])])]),t(\"p\",[t(\"strong\",[_._v(\"如果查询的两个表大小相当，那么用in和exists差别不大\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"UNION和UNION ALL的区别?\")])]),_._v(\" \"),t(\"p\",[_._v(\"UNION和UNION ALL都是将两个结果集合并为一个，\"),t(\"strong\",[_._v(\"两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"sql执行顺序\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sql执行顺序\"}},[_._v(\"#\")]),_._v(\" SQL执行顺序\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"手写\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT DISTINCT <select_list>\\nFROM  <left_table> <join_type>\\nJOIN  <right_table> ON <join_condition>\\nWHERE  <where_condition>\\nGROUP BY  <group_by_list>\\nHAVING <having_condition>\\nORDER BY <order_by_condition>\\nLIMIT <limit_number>\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"机读\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"FROM  <left_table>\\nON <join_condition>\\n<join_type> JOIN  <right_table> \\nWHERE  <where_condition>\\nGROUP BY  <group_by_list>\\nHAVING <having_condition>\\nSELECT\\nDISTINCT <select_list>\\nORDER BY <order_by_condition>\\nLIMIT <limit_number>\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"总结\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf3t8jyy81j30s2083wg2.jpg\",alt:\"sql-parse\"}})])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"mysql 的内连接、左连接、右连接有什么区别？\")]),_._v(\" \"),t(\"p\",[_._v(\"什么是内连接、外连接、交叉连接、笛卡尔积呢？\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"join图\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#join图\"}},[_._v(\"#\")]),_._v(\" Join图\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf3t8novxpj30qu0l4wi7.jpg\",alt:\"sql-joins\"}})]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"六、mysql-事务\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#六、mysql-事务\"}},[_._v(\"#\")]),_._v(\" 六、MySQL 事务\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"事务的隔离级别有哪些？MySQL的默认隔离级别是什么？\")]),_._v(\" \"),t(\"p\",[_._v(\"什么是幻读，脏读，不可重复读呢？\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL事务的四大特性以及实现原理\")]),_._v(\" \"),t(\"p\",[_._v(\"MVCC熟悉吗，它的底层原理？\")])]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"acid-事务基本要素\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#acid-事务基本要素\"}},[_._v(\"#\")]),_._v(\" ACID — 事务基本要素\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1geu10kkswnj305q05mweo.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"A (Atomicity) 原子性\")]),_._v(\"：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"C (Consistency) 一致性\")]),_._v(\"：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"I (Isolation)隔离性\")]),_._v(\"：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"D (Durability) 持久性\")]),_._v(\"：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"并发事务处理带来的问题\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"更新丢失（Lost Update)： 事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题\")]),_._v(\" \"),t(\"li\",[_._v(\"脏读(Dirty Reads)：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\")]),_._v(\" \"),t(\"li\",[_._v(\"不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。\")]),_._v(\" \"),t(\"li\",[_._v(\"幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"幻读和不可重复读的区别：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"不可重复读的重点是修改\")]),_._v(\"：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"幻读的重点在于新增或者删除\")]),_._v(\"：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"并发事务处理带来的问题的解决办法：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。\")]),_._v(\" \"),t(\"li\",[_._v(\"另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 \"),t(\"strong\",[_._v(\"MVCC\")]),_._v(\" 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"事务隔离级别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事务隔离级别\"}},[_._v(\"#\")]),_._v(\" 事务隔离级别\")]),_._v(\" \"),t(\"p\",[_._v(\"数据库事务的隔离级别有4种，由低到高分别为\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"READ-UNCOMMITTED(读未提交)：\")]),_._v(\" 最低的隔离级别，允许读取尚未提交的数据变更，\"),t(\"strong\",[_._v(\"可能会导致脏读、幻读或不可重复读\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"READ-COMMITTED(读已提交)：\")]),_._v(\" 允许读取并发事务已经提交的数据，\"),t(\"strong\",[_._v(\"可以阻止脏读，但是幻读或不可重复读仍有可能发生\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"REPEATABLE-READ(可重复读)：\")]),_._v(\" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，\"),t(\"strong\",[_._v(\"可以阻止脏读和不可重复读，但幻读仍有可能发生\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"SERIALIZABLE(可串行化)：\")]),_._v(\" 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，\"),t(\"strong\",[_._v(\"该级别可以防止脏读、不可重复读以及幻读\")]),_._v(\"。\")])]),_._v(\" \"),t(\"p\",[_._v(\"查看当前数据库的事务隔离级别：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"show variables like 'tx_isolation'\\n\")])])]),t(\"p\",[_._v(\"下面通过事例一一阐述在事务的并发操作中可能会出现脏读，不可重复读，幻读和事务隔离级别的联系。\")]),_._v(\" \"),t(\"p\",[_._v(\"数据库的事务隔离越严格，并发副作用越小，但付出的代价就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"read-uncommitted\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#read-uncommitted\"}},[_._v(\"#\")]),_._v(\" Read uncommitted\")]),_._v(\" \"),t(\"p\",[_._v(\"读未提交，就是一个事务可以读取另一个未提交事务的数据。\")]),_._v(\" \"),t(\"p\",[_._v(\"事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。\")]),_._v(\" \"),t(\"p\",[_._v(\"分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。\")]),_._v(\" \"),t(\"p\",[_._v(\"那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"read-committed\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#read-committed\"}},[_._v(\"#\")]),_._v(\" Read committed\")]),_._v(\" \"),t(\"p\",[_._v(\"读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。\")]),_._v(\" \"),t(\"p\",[_._v(\"事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…\")]),_._v(\" \"),t(\"p\",[_._v(\"分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是\"),t(\"strong\",[_._v(\"不可重复读\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"那怎么解决可能的不可重复读问题？Repeatable read ！\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"repeatable-read\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#repeatable-read\"}},[_._v(\"#\")]),_._v(\" Repeatable read\")]),_._v(\" \"),t(\"p\",[_._v(\"重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。 \"),t(\"mark\",[t(\"strong\",[_._v(\"MySQL的默认事务隔离级别\")])])]),_._v(\" \"),t(\"p\",[_._v(\"事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。\")]),_._v(\" \"),t(\"p\",[_._v(\"分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，\"),t(\"strong\",[_._v(\"不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"什么时候会出现幻读？\")])]),_._v(\" \"),t(\"p\",[_._v(\"事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。\")]),_._v(\" \"),t(\"p\",[_._v(\"那怎么解决幻读问题？Serializable！\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"serializable-序列化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#serializable-序列化\"}},[_._v(\"#\")]),_._v(\" Serializable 序列化\")]),_._v(\" \"),t(\"p\",[_._v(\"Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[t(\"strong\",[_._v(\"简单点的理解\")])]),_._v(\" \"),t(\"p\",[_._v(\"读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。\")]),_._v(\" \"),t(\"p\",[_._v(\"读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。\")]),_._v(\" \"),t(\"p\",[_._v(\"可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。\")]),_._v(\" \"),t(\"p\",[_._v(\"串行：我的事务尚未提交，别人就别想改数据。\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"比较\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#比较\"}},[_._v(\"#\")]),_._v(\" 比较\")]),_._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[_._v(\"事务隔离级别\")]),_._v(\" \"),t(\"th\",[_._v(\"读数据一致性\")]),_._v(\" \"),t(\"th\",[_._v(\"脏读\")]),_._v(\" \"),t(\"th\",[_._v(\"不可重复读\")]),_._v(\" \"),t(\"th\",[_._v(\"幻读\")])])]),_._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[_._v(\"读未提交（read-uncommitted）\")]),_._v(\" \"),t(\"td\",[_._v(\"最低级被，只能保证不读取物理上损坏的数据\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"读已提交（read-committed）\")]),_._v(\" \"),t(\"td\",[_._v(\"语句级\")]),_._v(\" \"),t(\"td\",[_._v(\"否\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"可重复读（repeatable-read）\")]),_._v(\" \"),t(\"td\",[_._v(\"事务级\")]),_._v(\" \"),t(\"td\",[_._v(\"否\")]),_._v(\" \"),t(\"td\",[_._v(\"否\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"串行化（serializable）\")]),_._v(\" \"),t(\"td\",[_._v(\"最高级别，事务级\")]),_._v(\" \"),t(\"td\",[_._v(\"否\")]),_._v(\" \"),t(\"td\",[_._v(\"否\")]),_._v(\" \"),t(\"td\",[_._v(\"否\")])])])]),_._v(\" \"),t(\"p\",[_._v(\"需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"什么是幻读-如何解决的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是幻读-如何解决的\"}},[_._v(\"#\")]),_._v(\" 什么是幻读？如何解决的\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"“幻读”面试关注点：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"要想解决幻读不能升级事务隔离级别到“可串行化”，那样数据库也失去了并发处理能力。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"行锁解决不了幻读，因为即使锁住所有记录，还是阻止不了插入新数据。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"解决幻读的办法是锁住记录之间的“间隙”，为此 MySQL InnoDB 引入了新的锁，叫间隙锁（Gap Lock），所以在面试中，你也要掌握间隙锁，以及间隙锁与行锁结合的 next-key lock 锁。\")])])])]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。\")]),_._v(\" \"),t(\"li\",[_._v(\"幻读仅专指“新插入的行”\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"由于在 RR 级别下，普通的读是快照读（一致性读），所以\"),t(\"mark\",[_._v(\"幻读仅发生在当前读的基础上\")]),_._v(\"。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"一致性读也被称为\"),t(\"strong\",[_._v(\"快照读\")]),_._v(\"，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。\")]),_._v(\" \"),t(\"p\",[_._v(\"与 \"),t(\"strong\",[_._v(\"快照读\")]),_._v(\" 相对应的则是 \"),t(\"strong\",[_._v(\"当前读\")]),_._v(\"，\"),t(\"strong\",[_._v(\"当前读\")]),_._v(\"就是读取最新数据，而不是历史版本的数据。\")])]),_._v(\" \"),t(\"p\",[_._v(\"举例来说：\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"select * from t where d=0\")]),_._v(\" 就是快照读，对于同一个事务来说，每次读到的结果是一样的。\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"select * from t where d=0 in share mode\")]),_._v(\" 或 \"),t(\"code\",[_._v(\"select * from t where d=0 for update\")]),_._v(\" 就是当前读，总是读取当前数据行的最新版本\")]),_._v(\" \"),t(\"p\",[_._v(\"所谓当前读，指的是加锁的 select(S或者X), update, delete 等语句。在 RR 的事务隔离级别下，数据库会使用next-key locks来锁住本条记录以及索引区间。\")]),_._v(\" \"),t(\"p\",[_._v(\"拿上面那个例子来说，在 RR 的情况下，假设使用的是当前读，加锁了的读\")]),_._v(\" \"),t(\"p\",[_._v(\"select * from table where id>3 锁住的就是 id=3 这条记录以及 id>3 这个区间范围，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录。\")])]),_._v(\" \"),t(\"p\",[_._v(\"MySQL InnoDB 存储引擎的默认支持的隔离级别是 \"),t(\"strong\",[_._v(\"REPEATABLE-READ（可重读）\")]),_._v(\"。我们可以通过\"),t(\"code\",[_._v(\"SELECT @@tx_isolation;\")]),_._v(\"命令来查看，MySQL 8.0 该命令改为\"),t(\"code\",[_._v(\"SELECT @@transaction_isolation;\")])]),_._v(\" \"),t(\"p\",[_._v(\"这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 **REPEATABLE-READ（可重读）**事务隔离级别下使用的是 Next-Key Lock 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(可串行化)**隔离级别，而且保留了比较好的并发性能。\")]),_._v(\" \"),t(\"p\",[_._v(\"因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是\"),t(\"strong\",[_._v(\"READ-COMMITTED(读已提交):\")]),_._v(\"，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"加锁的基本原则（RR隔离级别下）\\n原则1：加锁的对象是next-key lock。（是一个前开后闭的区间）\\n原则2：查找过程中访问到的对象才加锁\\n优化1：唯一索引加锁时，next-key lock退化为行锁。\\n索引上的等值查询，向右遍历时最后一个不满足等值条件的时候，next-key lock 退化为间隙锁\\n唯一索引和普通索引在范围查询的时候 都会访问到不满足条件的第一个值为止\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mvcc-多版本并发控制\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mvcc-多版本并发控制\"}},[_._v(\"#\")]),_._v(\" MVCC 多版本并发控制\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。\")]),_._v(\" \"),t(\"p\",[_._v(\"可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。\")]),_._v(\" \"),t(\"p\",[_._v(\"MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。\")]),_._v(\" \"),t(\"p\",[_._v(\"典型的 MVCC 实现方式，分为\"),t(\"strong\",[_._v(\"乐观（optimistic）并发控制和悲观（pressimistic）并发控制\")]),_._v(\"。下边通过 InnoDB 的简化版行为来说明 MVCC 是如何工作的。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作：\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"SELECT\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 会根据以下两个条件检查每行记录：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除\")])])]),_._v(\" \"),t(\"p\",[_._v(\"只有符合上述两个条件的才会被查询出来\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"UPDATE：InnoDB 为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识\")])])]),_._v(\" \"),t(\"p\",[_._v(\"保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作\")]),_._v(\"。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"mvcc-解决了什么问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mvcc-解决了什么问题\"}},[_._v(\"#\")]),_._v(\" MVCC 解决了什么问题\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"读写不冲突，极大的增加了系统的并发性能\")]),_._v(\" \"),t(\"li\",[_._v(\"解决脏读，幻读，不可重复读 等问题（注:其实多版本只是解决不可重复读问题，而加上间隙锁(也 就是它这里所谓的并发控制)才解决了幻读问题。）\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"InnoDB下的Compact行结构，有三个隐藏的列\")]),_._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[_._v(\"列名\")]),_._v(\" \"),t(\"th\",[_._v(\"是否必须\")]),_._v(\" \"),t(\"th\",[_._v(\"描述\")])])]),_._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[_._v(\"row_id\")]),_._v(\" \"),t(\"td\",[_._v(\"否\")]),_._v(\" \"),t(\"td\",[_._v(\"行ID，唯一标识一条记录（如果定义主键，它就没有啦）\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"transaction_id\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")]),_._v(\" \"),t(\"td\",[_._v(\"事务ID\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"roll_pointer\")]),_._v(\" \"),t(\"td\",[_._v(\"是\")]),_._v(\" \"),t(\"td\",[_._v(\"DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本\")])])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"事务日志\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事务日志\"}},[_._v(\"#\")]),_._v(\" 事务日志\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。\")]),_._v(\" \"),t(\"p\",[_._v(\"事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 用日志把随机 IO 变成顺序 IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。\")]),_._v(\" \"),t(\"p\",[_._v(\"事务日志可以帮助提高事务效率：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。\")]),_._v(\" \"),t(\"li\",[_._v(\"事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。\")]),_._v(\" \"),t(\"li\",[_._v(\"事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。\")]),_._v(\" \"),t(\"li\",[_._v(\"如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。\")])]),_._v(\" \"),t(\"p\",[_._v(\"目前来说，大多数存储引擎都是这样实现的，我们通常称之为\"),t(\"strong\",[_._v(\"预写式日志\")]),_._v(\"（Write-Ahead Logging），修改数据需要写两次磁盘。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"事务的实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事务的实现\"}},[_._v(\"#\")]),_._v(\" 事务的实现\")]),_._v(\" \"),t(\"p\",[_._v(\"事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。\")]),_._v(\" \"),t(\"p\",[_._v(\"事务的实现就是如何实现 ACID 特性。\")]),_._v(\" \"),t(\"p\",[_._v(\"事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"事务是如何通过日志来实现的，说得越深入越好。\")])]),_._v(\" \"),t(\"p\",[_._v(\"事务日志包括：\"),t(\"strong\",[_._v(\"重做日志redo\")]),_._v(\"和\"),t(\"strong\",[_._v(\"回滚日志undo\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"redo log（重做日志\")]),_._v(\"） 实现持久性\")]),_._v(\" \"),t(\"p\",[_._v(\"在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。\")]),_._v(\" \"),t(\"p\",[_._v(\"在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"undo log（回滚日志）\")]),_._v(\"  实现原子性\")]),_._v(\" \"),t(\"p\",[_._v(\"undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。\")]),_._v(\" \"),t(\"p\",[_._v(\"Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。\")])])])]),_._v(\" \"),t(\"p\",[_._v(\"二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"又引出个问题：你知道MySQL 有多少种日志吗？\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"错误日志\")]),_._v(\"：记录出错信息，也记录一些警告信息或者正确的信息。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"查询日志\")]),_._v(\"：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"慢查询日志\")]),_._v(\"：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"二进制日志\")]),_._v(\"：记录对数据库执行更改的所有操作。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"中继日志\")]),_._v(\"：中继日志也是二进制日志，用来给slave 库恢复\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"事务日志\")]),_._v(\"：重做日志redo和回滚日志undo\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"分布式事务相关问题，可能还会问到 2PC、3PC，，，\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql对分布式事务的支持\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql对分布式事务的支持\"}},[_._v(\"#\")]),_._v(\" MySQL对分布式事务的支持\")]),_._v(\" \"),t(\"p\",[_._v(\"分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 从 5.0.3  InnoDB 存储引擎开始支持 XA 协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。\")]),_._v(\" \"),t(\"p\",[_._v(\"在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj0sqpwsvdj30k009dtak.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"应用程序：定义了事务的边界，指定需要做哪些事务；\")]),_._v(\" \"),t(\"li\",[_._v(\"资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；\")]),_._v(\" \"),t(\"li\",[_._v(\"事务管理器：协调参与了全局事务中的各个事务。\")])]),_._v(\" \"),t(\"p\",[_._v(\"分布式事务采用两段式提交（two-phase commit）的方式：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"第一阶段所有的事务节点开始准备，告诉事务管理器ready。\")]),_._v(\" \"),t(\"li\",[_._v(\"第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"事务的-acid-分别是如何实现的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事务的-acid-分别是如何实现的\"}},[_._v(\"#\")]),_._v(\" 事务的 ACID 分别是如何实现的\")]),_._v(\" \"),t(\"p\",[_._v(\"从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。\")]),_._v(\" \"),t(\"p\",[_._v(\"原子性保证：\"),t(\"code\",[_._v(\"undo log\")]),_._v(\"名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。\")]),_._v(\" \"),t(\"p\",[_._v(\"持久性保证：\"),t(\"code\",[_._v(\"redo log\")]),_._v(\" mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。\")]),_._v(\" \"),t(\"p\",[t(\"em\",[_._v(\"怎么解决这个问题？\")])]),_._v(\" \"),t(\"p\",[_._v(\"简单啊，事务提交前直接把数据写入磁盘就行啊。\")]),_._v(\" \"),t(\"p\",[t(\"em\",[_._v(\"这么做有什么问题？\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。\")]),_._v(\" \"),t(\"li\",[_._v(\"毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。\")])]),_._v(\" \"),t(\"p\",[_._v(\"于是，决定采用\"),t(\"code\",[_._v(\"redo log\")]),_._v(\"解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在\"),t(\"code\",[_._v(\"redo log\")]),_._v(\"中记录这次操作。当事务提交的时候，会将\"),t(\"code\",[_._v(\"redo log\")]),_._v(\"日志进行刷盘(\"),t(\"code\",[_._v(\"redo log\")]),_._v(\"一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将\"),t(\"code\",[_._v(\"redo log\")]),_._v(\"中的内容恢复到数据库中，再根据\"),t(\"code\",[_._v(\"undo log\")]),_._v(\"和\"),t(\"code\",[_._v(\"binlog\")]),_._v(\"内容决定回滚数据还是提交数据。\")]),_._v(\" \"),t(\"p\",[t(\"em\",[_._v(\"采用redo log的好处？\")])]),_._v(\" \"),t(\"p\",[_._v(\"其实好处就是将\"),t(\"code\",[_._v(\"redo log\")]),_._v(\"进行刷盘比对数据页刷盘效率高，具体表现如下\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"code\",[_._v(\"redo log\")]),_._v(\"体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。\")]),_._v(\" \"),t(\"li\",[t(\"code\",[_._v(\"redo log\")]),_._v(\"是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"隔离性保证：利用的是锁和MVCC机制\")]),_._v(\" \"),t(\"p\",[_._v(\"一致性保证：一致性由其他三大特性保证、程序代码要保证业务上的一致性\")]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"七、mysql-锁机制\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#七、mysql-锁机制\"}},[_._v(\"#\")]),_._v(\" 七、MySQL 锁机制\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"数据库的乐观锁和悲观锁？\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 中有哪几种锁，列举一下？\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL中InnoDB引擎的行锁是怎么实现的？\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁\")])]),_._v(\" \"),t(\"p\",[_._v(\"锁是计算机协调多个进程或线程并发访问某一资源的机制。\")]),_._v(\" \"),t(\"p\",[_._v(\"在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。\")]),_._v(\" \"),t(\"p\",[_._v(\"打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"锁的分类\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#锁的分类\"}},[_._v(\"#\")]),_._v(\" 锁的分类\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"从对数据操作的类型分类\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"读锁\")]),_._v(\"（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"写锁\")]),_._v(\"（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁\")])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"从对数据操作的粒度分类\")]),_._v(\"：\")]),_._v(\" \"),t(\"p\",[_._v(\"为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"表级锁\")]),_._v(\"：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"行级锁\")]),_._v(\"：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"页面锁\")]),_._v(\"：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。\")]),_._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\"),_._v(\" \"),t(\"th\",[_._v(\"行锁\")]),_._v(\" \"),t(\"th\",[_._v(\"表锁\")]),_._v(\" \"),t(\"th\",[_._v(\"页锁\")])])]),_._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[_._v(\"MyISAM\")]),_._v(\" \"),t(\"td\"),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\")]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"BDB\")]),_._v(\" \"),t(\"td\"),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\",[_._v(\"√\")])]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"InnoDB\")]),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\")]),_._v(\" \"),t(\"tr\",[t(\"td\",[_._v(\"Memory\")]),_._v(\" \"),t(\"td\"),_._v(\" \"),t(\"td\",[_._v(\"√\")]),_._v(\" \"),t(\"td\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"myisam-表锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#myisam-表锁\"}},[_._v(\"#\")]),_._v(\" MyISAM 表锁\")]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM 的表锁有两种模式：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；\")]),_._v(\" \"),t(\"li\",[_._v(\"表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；\")])]),_._v(\" \"),t(\"p\",[_._v(\"MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。\")]),_._v(\" \"),t(\"p\",[_._v(\"默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"innodb-行锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#innodb-行锁\"}},[_._v(\"#\")]),_._v(\" InnoDB 行锁\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 实现了以下两种类型的\"),t(\"strong\",[_._v(\"行锁\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"共享锁又称为读锁，简称  S 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"排他锁又称为写锁，简称 X 锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是\"),t(\"strong\",[_._v(\"表锁\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。\")]),_._v(\" \"),t(\"li\",[_._v(\"意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"索引失效会导致行锁变表锁\")]),_._v(\"。比如 varchar 查询不写单引号的情况。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁\")]),_._v(\"。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"加锁机制\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#加锁机制\"}},[_._v(\"#\")]),_._v(\" 加锁机制\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题\")])]),_._v(\" \"),t(\"p\",[_._v(\"乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式\")]),_._v(\" \"),t(\"p\",[_._v(\"悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，\"),t(\"strong\",[_._v(\"悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"锁模式-innodb有三种行锁的算法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#锁模式-innodb有三种行锁的算法\"}},[_._v(\"#\")]),_._v(\" 锁模式(InnoDB有三种行锁的算法)\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"记录锁(Record Locks)\")]),_._v(\"： 单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM table WHERE id = 1 FOR UPDATE;\\n\")])])]),t(\"p\",[_._v(\"它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行\")]),_._v(\" \"),t(\"p\",[_._v(\"在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"-- id 列为主键列或唯一索引列\\nUPDATE SET age = 50 WHERE id = 1;\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"间隙锁（Gap Locks）\")]),_._v(\"： 当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"如下表，初始化插入了 6 个记录，这就产生了 7 个间隙。\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/e7/61/e7f7ca0d3dab2f48c588d714ee3ac861.png\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"这样，当你执行 select * from t where d=5 for update 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。\")])]),_._v(\" \"),t(\"p\",[_._v(\"对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。\")]),_._v(\" \"),t(\"p\",[_._v(\"间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的\"),t(\"code\",[_._v(\"Next-Key Locking\")]),_._v(\" 算法，请务必牢记：\"),t(\"strong\",[_._v(\"使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据\")]),_._v(\"。\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;\\n\")])])]),t(\"p\",[_._v(\"即所有在\"),t(\"code\",[_._v(\"（1，10）\")]),_._v(\"区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。\")]),_._v(\" \"),t(\"p\",[_._v(\"GAP 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"临键锁(Next-key Locks)\")]),_._v(\"： \"),t(\"strong\",[_._v(\"临键锁\")]),_._v(\"，是\"),t(\"strong\",[_._v(\"记录锁与间隙锁的组合\")]),_._v(\"，它的封锁范围，既包含索引记录，又包含索引区间。(临键锁的主要目的，也是为了避免\"),t(\"strong\",[_._v(\"幻读\")]),_._v(\"(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。)\")]),_._v(\" \"),t(\"p\",[_._v(\"Next-Key 可以理解为一种特殊的\"),t(\"strong\",[_._v(\"间隙锁\")]),_._v(\"，也可以理解为一种特殊的\"),t(\"strong\",[_._v(\"算法\")]),_._v(\"。通过\"),t(\"strong\",[_._v(\"临建锁\")]),_._v(\"可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，\"),t(\"mark\",[t(\"code\",[_._v(\"InnoDB\")]),_._v(\" 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"对于行的查询，都是采用该方法，主要目的是解决幻读的问题。\")])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"select for update有什么含义，会锁表还是锁行还是其他\")])]),_._v(\" \"),t(\"p\",[_._v(\"for update 仅适用于 InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL  会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！\")]),_._v(\" \"),t(\"p\",[_._v(\"假设有个表单 products ，里面有 id 跟 name 二个栏位，id 是主键。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"明确指定主键，并且有此笔资料，row lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE id='3' FOR UPDATE;\\nSELECT * FROM products WHERE id='3' and type=1 FOR UPDATE;\\n\")])])]),t(\"ul\",[t(\"li\",[_._v(\"明确指定主键，若查无此笔资料，无lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE id='-1' FOR UPDATE;\\n\")])])]),t(\"ul\",[t(\"li\",[_._v(\"无主键，table lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE name='Mouse' FOR UPDATE;\\n\")])])]),t(\"ul\",[t(\"li\",[_._v(\"主键不明确，table lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE id <>'3' FOR UPDATE;\\n\")])])]),t(\"ul\",[t(\"li\",[_._v(\"主键不明确，table lock\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;\\n\")])])]),t(\"p\",[t(\"strong\",[_._v(\"注1\")]),_._v(\": FOR UPDATE 仅适用于 InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。\\n\"),t(\"strong\",[_._v(\"注2\")]),_._v(\": 要测试锁定的状况，可以利用 MySQL 的 Command Mode ，开二个视窗来做测试。\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"MySQL 遇到过死锁问题吗，你是如何解决的？\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"死锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁\"}},[_._v(\"#\")]),_._v(\" 死锁\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"死锁产生\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环\")]),_._v(\" \"),t(\"li\",[_._v(\"当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁\")]),_._v(\" \"),t(\"li\",[_._v(\"锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"死锁产生的四个必要条件\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"互斥： 多个线程不能同时使用一个资源。比如线程 A 已经持有的资源，不能再同时被线程 B 持有。\")]),_._v(\" \"),t(\"li\",[_._v(\"持有并等待： 当线程 A 已经持有了资源 1，又提出申请资源 2，但是资源 2 已经被线程 C 占用，所以线程 A 就会处于等待状态，但它在等待资源 2 的同时并不会释放自己已经获取的资源 1。\")]),_._v(\" \"),t(\"li\",[_._v(\"不可剥夺： 线程 A 获取到资源 1 之后，在自己使用完之前不能被其他线程（比如线程 B）抢占使用。如果线程 B 也想使用资源 1，只能在线程 A 使用完后，主动释放后再获取\")]),_._v(\" \"),t(\"li\",[_._v(\"循环等待： 发生死锁时，必然会存在一个线程，也就是资源的环形链。比如线程 A 已经获取了资源 1，但同时又请求获取资源 2。线程 B 已经获取了资源 2，但同时又请求获取资源 1，这就会形成一个线程和资源请求等待的环形图。\")])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"检测死锁\")]),_._v(\"：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB 存储引擎能检测到死锁的循环依赖并立即返回一个错误。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"死锁恢复\")]),_._v(\"：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，\"),t(\"strong\",[_._v(\"InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚\")]),_._v(\"。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"外部锁的死锁检测\")]),_._v(\"：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"死锁影响性能\")]),_._v(\"：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖\"),t(\"code\",[_._v(\"innodb_lock_wait_timeout\")]),_._v(\"设置进行事务回滚。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"MyISAM 避免死锁\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"InnoDB 避免死锁\")]),_._v(\"：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"为了在单个 InnoDB 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用\"),t(\"code\",[_._v(\"SELECT ... FOR UPDATE\")]),_._v(\"语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。\")]),_._v(\" \"),t(\"li\",[_._v(\"在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁\")]),_._v(\" \"),t(\"li\",[_._v(\"如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会\")]),_._v(\" \"),t(\"li\",[_._v(\"通过\"),t(\"code\",[_._v(\"SELECT ... LOCK IN SHARE MODE\")]),_._v(\" 获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。\")]),_._v(\" \"),t(\"li\",[_._v(\"改变事务隔离级别\")])]),_._v(\" \"),t(\"p\",[_._v(\"如果出现死锁，可以用 \"),t(\"code\",[_._v(\"show engine innodb status;\")]),_._v(\"命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"如何尽可能避免死锁\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何尽可能避免死锁\"}},[_._v(\"#\")]),_._v(\" 如何尽可能避免死锁\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"合理的设计索引，区分度高的列放到组合索引前面，使业务 SQL 尽可能通过索引\"),t(\"code\",[_._v(\"定位更少的行，减少锁竞争\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[_._v(\"调整业务逻辑 SQL 执行顺序， 避免 update/delete 长时间持有锁的 SQL 在事务前面。\")]),_._v(\" \"),t(\"li\",[_._v(\"避免\"),t(\"code\",[_._v(\"大事务\")]),_._v(\"，尽量将大事务拆成多个小事务来处理，小事务发生锁冲突的几率也更小。\")]),_._v(\" \"),t(\"li\",[_._v(\"以\"),t(\"code\",[_._v(\"固定的顺序\")]),_._v(\"访问表和行。比如两个更新数据的事务，事务 A 更新数据的顺序为 1，2;事务 B 更新数据的顺序为 2，1。这样更可能会造成死锁。\")]),_._v(\" \"),t(\"li\",[_._v(\"在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select … for update 语句，如果是在事务里\"),t(\"code\",[_._v(\"（运行了 start transaction 或设置了autocommit 等于0）\")]),_._v(\",那么就会锁定所查找到的记录。\")]),_._v(\" \"),t(\"li\",[_._v(\"尽量按\"),t(\"code\",[_._v(\"主键/索引\")]),_._v(\"去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外额度计算工作。比如有的程序会用到 “select … where … order by rand();”这样的语句，由于类似这样的语句用不到索引，因此将导致整个表的数据都被锁住。\")]),_._v(\" \"),t(\"li\",[_._v(\"优化 SQL 和表设计，减少同时占用太多资源的情况。比如说，\"),t(\"code\",[_._v(\"减少连接的表\")]),_._v(\"，将复杂 SQL \"),t(\"code\",[_._v(\"分解\")]),_._v(\"为多个简单的 SQL。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"innodb-如何手动锁表\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#innodb-如何手动锁表\"}},[_._v(\"#\")]),_._v(\" InnoDB 如何手动锁表\")]),_._v(\" \"),t(\"p\",[_._v(\"LOCK TABLES table_name read local; 将当前表设置为只读，不能进行插入或更新操作。\")]),_._v(\" \"),t(\"p\",[_._v(\"UNLOCK TABLES;锁住表了，使用UNLOCK进行释放。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"innodb-引擎的行锁是通过加在什么上完成-或称实现-的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#innodb-引擎的行锁是通过加在什么上完成-或称实现-的\"}},[_._v(\"#\")]),_._v(\" InnoDB 引擎的行锁是通过加在什么上完成(或称实现) 的?\")]),_._v(\" \"),t(\"p\",[_._v(\"InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这 种行锁实现特点意味着:只有通过索引条件检索数据，InnoDB 才使用行级 锁，否则，InnoDB 将使用表锁!\")]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"八、mysql-调优\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#八、mysql-调优\"}},[_._v(\"#\")]),_._v(\" 八、MySQL 调优\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"日常工作中你是怎么优化SQL的？\")]),_._v(\" \"),t(\"p\",[_._v(\"SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？\")]),_._v(\" \"),t(\"p\",[_._v(\"如何写sql能够有效的使用到复合索引？\")]),_._v(\" \"),t(\"p\",[_._v(\"一条sql执行过长的时间，你如何优化，从哪些方面入手？\")]),_._v(\" \"),t(\"p\",[_._v(\"什么是最左前缀原则？什么是最左匹配原则？\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"影响-mysql-的性能因素\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#影响-mysql-的性能因素\"}},[_._v(\"#\")]),_._v(\" 影响  mysql 的性能因素\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"业务需求对MySQL的影响(合适合度)\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"存储定位对MySQL的影响\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"不适合放进MySQL的数据\\n\"),t(\"ul\",[t(\"li\",[_._v(\"二进制多媒体数据\")]),_._v(\" \"),t(\"li\",[_._v(\"流水队列数据\")]),_._v(\" \"),t(\"li\",[_._v(\"超大文本数据\")])])]),_._v(\" \"),t(\"li\",[_._v(\"需要放进缓存的数据\\n\"),t(\"ul\",[t(\"li\",[_._v(\"系统各种配置及规则数据\")]),_._v(\" \"),t(\"li\",[_._v(\"活跃用户的基本信息数据\")]),_._v(\" \"),t(\"li\",[_._v(\"活跃用户的个性化定制信息数据\")]),_._v(\" \"),t(\"li\",[_._v(\"准实时的统计信息数据\")]),_._v(\" \"),t(\"li\",[_._v(\"其他一些访问频繁但变更较少的数据\")])])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"Schema设计对系统的性能影响\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"尽量减少对数据库访问的请求\")]),_._v(\" \"),t(\"li\",[_._v(\"尽量减少无用数据的查询请求\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"硬件环境对系统性能的影响\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"性能分析\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#性能分析\"}},[_._v(\"#\")]),_._v(\" 性能分析\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"mysql-query-optimizer\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-query-optimizer\"}},[_._v(\"#\")]),_._v(\" MySQL Query Optimizer\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimizer 时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。\")])])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"mysql常见瓶颈\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql常见瓶颈\"}},[_._v(\"#\")]),_._v(\" MySQL常见瓶颈\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"CPU：CPU 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"IO：磁盘 I/O 瓶颈发生在装入数据远大于内存容量的时候\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"服务器硬件的性能瓶颈：top，free，iostat 和 vmstat 来查看系统的性能状态\")])])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"性能下降sql慢-执行时间长-等待时间长-原因分析\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#性能下降sql慢-执行时间长-等待时间长-原因分析\"}},[_._v(\"#\")]),_._v(\" 性能下降SQL慢 执行时间长 等待时间长 原因分析\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"查询语句写的烂\")]),_._v(\" \"),t(\"li\",[_._v(\"索引失效（单值、复合）\")]),_._v(\" \"),t(\"li\",[_._v(\"关联查询太多 join（设计缺陷或不得已的需求）\")]),_._v(\" \"),t(\"li\",[_._v(\"服务器调优及各个参数设置（缓冲、线程数等）\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"mysql常见性能分析手段\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql常见性能分析手段\"}},[_._v(\"#\")]),_._v(\" MySQL常见性能分析手段\")]),_._v(\" \"),t(\"p\",[_._v(\"在优化 MySQL 时，通常需要对数据库进行分析，常见的分析手段有\"),t(\"strong\",[_._v(\"慢查询日志\")]),_._v(\"，\"),t(\"strong\",[_._v(\"EXPLAIN 分析查询\")]),_._v(\"，\"),t(\"strong\",[_._v(\"profiling分析\")]),_._v(\"以及\"),t(\"strong\",[_._v(\"show命令查询系统状态及系统变量\")]),_._v(\"，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"性能瓶颈定位\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#性能瓶颈定位\"}},[_._v(\"#\")]),_._v(\" 性能瓶颈定位\")]),_._v(\" \"),t(\"p\",[_._v(\"我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"Mysql> show status ——显示状态信息（扩展show status like ‘XXX’）\\n\\nMysql> show variables ——显示系统变量（扩展show variables like ‘XXX’）\\n\\nMysql> show innodb status ——显示InnoDB存储引擎的状态\\n\\nMysql> show processlist ——查看当前SQL执行，包括执行状态、是否锁表等\\n\\nShell> mysqladmin variables -u username -p password——显示系统变量\\n\\nShell> mysqladmin extended-status -u username -p password——显示状态信息\\n\")])])]),t(\"h5\",{attrs:{id:\"explain-执行计划\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#explain-执行计划\"}},[_._v(\"#\")]),_._v(\" Explain(执行计划)\")]),_._v(\" \"),t(\"p\",[_._v(\"是什么：使用 \"),t(\"strong\",[_._v(\"Explain\")]),_._v(\" 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈\")]),_._v(\" \"),t(\"p\",[_._v(\"能干吗：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"表的读取顺序\")]),_._v(\" \"),t(\"li\",[_._v(\"数据读取操作的操作类型\")]),_._v(\" \"),t(\"li\",[_._v(\"哪些索引可以使用\")]),_._v(\" \"),t(\"li\",[_._v(\"哪些索引被实际使用\")]),_._v(\" \"),t(\"li\",[_._v(\"表之间的引用\")]),_._v(\" \"),t(\"li\",[_._v(\"每张表有多少行被优化器查询\")])]),_._v(\" \"),t(\"p\",[_._v(\"怎么玩：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"Explain + SQL语句\")]),_._v(\" \"),t(\"li\",[_._v(\"执行计划包含的信息（如果有分区表的话还会有\"),t(\"strong\",[_._v(\"partitions\")]),_._v(\"）\")])]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf2hsjk9zcj30kq01adfn.jpg\",alt:\"expalin\"}})]),_._v(\" \"),t(\"p\",[_._v(\"各字段解释\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"id\")])]),_._v(\"（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"id 相同，执行顺序从上往下\")]),_._v(\" \"),t(\"li\",[_._v(\"id 全不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行\")]),_._v(\" \"),t(\"li\",[_._v(\"id 部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"select_type\")])]),_._v(\"（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"SIMPLE\")]),_._v(\" ：简单的 select 查询，查询中不包含子查询或 UNION\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"PRIMARY\")]),_._v(\"：查询中若包含任何复杂的子部分，最外层查询被标记为 PRIMARY\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"SUBQUERY\")]),_._v(\"：在select或where列表中包含了子查询\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"DERIVED\")]),_._v(\"：在 from 列表中包含的子查询被标记为 DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"UNION\")]),_._v(\"：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"UNION RESULT\")]),_._v(\"：从UNION表获取结果的select\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"table\")])]),_._v(\"（显示这一行的数据是关于哪张表的）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"type\")])]),_._v(\"（显示查询使用了那种类型，从最好到最差依次排列\\t\"),t(\"strong\",[_._v(\"system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL\")]),_._v(\" ）\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现\")]),_._v(\" \"),t(\"li\",[_._v(\"const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量\")]),_._v(\" \"),t(\"li\",[_._v(\"eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描\")]),_._v(\" \"),t(\"li\",[_._v(\"ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体\")]),_._v(\" \"),t(\"li\",[_._v(\"range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引\")]),_._v(\" \"),t(\"li\",[_._v(\"index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（\"),t(\"strong\",[_._v(\"也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的\")]),_._v(\"）\")]),_._v(\" \"),t(\"li\",[_._v(\"ALL：Full Table Scan，将遍历全表找到匹配的行\")])]),_._v(\" \"),t(\"p\",[_._v(\"tip: 一般来说，得保证查询至少达到range级别，最好到达ref\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"possible_keys\")])]),_._v(\"（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"key\")])])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"实际使用的索引，如果为 NULL，则没有使用索引\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中\")])])])])])]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf2hsty7iaj30nt0373yb.jpg\",alt:\"explain-key\"}})]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"key_len\")])])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好\")]),_._v(\" \"),t(\"li\",[_._v(\"key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"ref\")])]),_._v(\" （显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"rows\")])]),_._v(\" （根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"mark\",[t(\"strong\",[_._v(\"Extra\")])]),_._v(\"（包含不适合在其他列中显示但十分重要的额外信息）\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[t(\"font\",{attrs:{color:\"red\"}},[_._v(\"using filesort\")]),_._v(\": 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中\")],1)]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"font\",{attrs:{color:\"red\"}},[_._v(\"Using temporary\")]),_._v(\"：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。\")],1)]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"font\",{attrs:{color:\"red\"}},[_._v(\"using index\")]),_._v(\"：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作\")],1)]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"using where：使用了where过滤\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"using join buffer：使用了连接缓存\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"impossible where：where子句的值总是false，不能用来获取任何元祖\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作\")])])])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"case\")]),_._v(\":\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1gf2hszmc0lj30lc05w75c.jpg\",alt:\"explain-demo\"}})]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为<derived3>，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name......】\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=''】\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的<union1,4>表示用第一个和第四个select的结果进行union操作。【两个结果union操作】\")])])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"慢查询日志\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#慢查询日志\"}},[_._v(\"#\")]),_._v(\" 慢查询日志\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 \"),t(\"code\",[_._v(\"long_query_time\")]),_._v(\" 值的 SQL，则会被记录到慢查询日志中。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"code\",[_._v(\"long_query_time\")]),_._v(\" 的默认值为10，意思是运行10秒以上的语句\")]),_._v(\" \"),t(\"li\",[_._v(\"默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"查看开启状态\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SHOW VARIABLES LIKE '%slow_query_log%'\\n\")])])]),t(\"p\",[t(\"strong\",[_._v(\"开启慢查询日志\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"临时配置：\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"mysql> set global slow_query_log='ON';\\nmysql> set global slow_query_log_file='/var/lib/mysql/hostname-slow.log';\\nmysql> set global long_query_time=2;\\n\")])])]),t(\"p\",[_._v(\"​\\t也可 set 文件位置，系统会默认给一个缺省文件 host_name-slow.log\")]),_._v(\" \"),t(\"p\",[_._v(\"​\\t使用 set 操作开启慢查询日志只对当前数据库生效，如果 MySQL 重启则会失效。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"永久配置\")]),_._v(\" \"),t(\"p\",[_._v(\"修改配置文件 my.cnf 或 my.ini，在[mysqld]一行下面加入两个配置参数\")])])]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"[mysqld]\\nslow_query_log = ON\\nslow_query_log_file = /var/lib/mysql/hostname-slow.log\\nlong_query_time = 3\\n\")])])]),t(\"p\",[_._v(\"注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。\")]),_._v(\" \"),t(\"p\",[_._v(\"可以用 \"),t(\"code\",[_._v(\"select sleep(4)\")]),_._v(\" 验证是否成功开启。\")]),_._v(\" \"),t(\"p\",[_._v(\"在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具\"),t(\"strong\",[_._v(\"mysqldumpslow\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"通过 mysqldumpslow --help 查看操作帮助信息\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"得到返回记录集最多的10个SQL\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"得到访问次数最多的10个SQL\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"得到按照时间排序的前10条里面含有左连接的查询语句\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v('mysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/hostname-slow.log')])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"也可以和管道配合使用\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more\")])])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"show-profile-分析查询\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#show-profile-分析查询\"}},[_._v(\"#\")]),_._v(\" Show Profile 分析查询\")]),_._v(\" \"),t(\"p\",[_._v(\"通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合\"),t(\"code\",[_._v(\"Show Profile\")]),_._v(\"命令查看执行状态。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于  SQL 的调优的测量\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"默认情况下，参数处于关闭状态，并保存最近15次的运行结果\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"分析步骤\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"是否支持，看看当前的mysql版本是否支持\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"mysql>Show  variables like 'profiling';  --默认是关闭，使用前需要开启\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"开启功能，默认是关闭，使用前需要开启\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"mysql>set profiling=1;  \\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"运行SQL\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"查看结果\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(' mysql> show profiles;\\n+----------+------------+---------------------------------+\\n | Query_ID | Duration   | Query                           |\\n+----------+------------+---------------------------------+\\n |        1 | 0.00385450 | show variables like \"profiling\" |\\n|        2 | 0.00170050 | show variables like \"profiling\" |\\n |        3 | 0.00038025 | select * from t_base_user       |\\n+----------+------------+---------------------------------+\\n')])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"诊断SQL，show profile cpu,block io for query  id(上一步前面的问题SQL数字号码)\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"日常开发需要注意的结论\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"create tmp table 创建临时表，这个要注意\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"Copying to tmp table on disk   把内存临时表复制到磁盘\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"locked\")])])])])])])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"查询中哪些情况不会使用索引？\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"性能优化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#性能优化\"}},[_._v(\"#\")]),_._v(\" 性能优化\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"索引优化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#索引优化\"}},[_._v(\"#\")]),_._v(\" 索引优化\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[_._v(\"全值匹配我最爱\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"最佳左前缀法则\")]),_._v(\"，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"存储引擎不能使用索引中范围条件右边的列\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"尽量使用\"),t(\"strong\",[_._v(\"覆盖索引\")]),_._v(\"(只访问索引的查询(索引列和查询列一致))，减少select\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"is null ,is not null 也无法使用索引\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v('like \"xxxx%\" 是可以用到索引的，like \"%xxxx\" 则不行(like \"%xxx%\" 同理)。like以通配符开头(\\'%abc...\\')索引失效会变成全表扫描的操作，')])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"字符串不加单引号索引失效\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"少用or，用它来连接时会索引失效\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"<，<=，=，>，>=，BETWEEN，IN 可用到索引，<>，not in ，!= 则不行，会导致全表扫描\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"前缀索引：前缀索引就是用某个字段中，字符串的前几个字符建立索引，比如我们可以在订单表上对商品名称字段的前 5 个字符建立索引。使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。\")]),_._v(\" \"),t(\"p\",[_._v(\"但是，前缀索引有一定的局限性，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。\")])])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"建索引的几大原则\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#建索引的几大原则\"}},[_._v(\"#\")]),_._v(\" 建索引的几大原则\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"最左前缀匹配原则，非常重要的原则，mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如 \"),t(\"code\",[_._v(\"a = 1 and b = 2 and c > 3 and d = 4\")]),_._v(\" 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\")]),_._v(\" \"),t(\"li\",[_._v(\"=和in可以乱序，比如 \"),t(\"code\",[_._v(\"a = 1 and b = 2 and c = 3\")]),_._v(\"  建立(a,b,c)索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。\")]),_._v(\" \"),t(\"li\",[_._v(\"尽量选择\"),t(\"strong\",[_._v(\"区分度高\")]),_._v(\"的列作为索引，区分度的公式是 \"),t(\"code\",[_._v(\"区分度 = distinct(col)/count(*)\")]),_._v(\"，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。\")]),_._v(\" \"),t(\"li\",[_._v(\"索引列不能参与计算，保持列“干净”，比如  \"),t(\"code\",[_._v(\"from_unixtime(create_time) = ’2014-05-29’\")]),_._v(\"  就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成 \"),t(\"code\",[_._v(\"create_time = unix_timestamp(’2014-05-29’)\")]),_._v(\"。\")]),_._v(\" \"),t(\"li\",[_._v(\"尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可。\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"一般性建议\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"对于单键索引，尽量选择针对当前 query 过滤性更好的索引\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"在选择组合索引的时候，当前 query 中过滤性最好的字段在索引字段顺序中，位置越靠前越好\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"在选择组合索引的时候，尽量选择可以能够包含当前 query 中的 where 字句中更多字段的索引\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"尽可能通过分析统计信息和调整 query 的写法来达到选择合适索引的目的\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"少用 Hint 强制索引\")])])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"查询优化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#查询优化\"}},[_._v(\"#\")]),_._v(\" 查询优化\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"为查询缓存优化你的查询\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为查询缓存优化你的查询\"}},[_._v(\"#\")]),_._v(\" 为查询缓存优化你的查询\")]),_._v(\" \"),t(\"p\",[_._v(\"大多数的 MySQL 服务器都开启了查询缓存。这是提高性最有效的方法之 一，而且这是被 MySQL 的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。\")]),_._v(\" \"),t(\"p\",[_._v(\"这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让 MySQL 不使用缓存。请看下面的示例:\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/e6c9d24ely1h3b1ms39aaj218605u75x.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[_._v(\"上面两条 SQL 语句的差别就是 CURDATE() ，MySQL 的查询缓存对这个函数不起作用。\")]),_._v(\" \"),t(\"p\",[_._v(\"所以，像 NOW() 和 RAND() 或是其它的诸如此类的 SQL 函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是 用一个变量来代替 MySQL 的函数，从而开启缓存。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"永远小标驱动大表-小的数据集驱动大的数据集\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#永远小标驱动大表-小的数据集驱动大的数据集\"}},[_._v(\"#\")]),_._v(\" 永远小标驱动大表（小的数据集驱动大的数据集）\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"slect * from A where id in (select id from B)`等价于\\n#等价于\\nselect id from B\\nselect * from A where A.id=B.id\\n\")])])]),t(\"p\",[_._v(\"当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"select * from A where exists (select 1 from B where B.id=A.id)\\n#等价于\\nselect * from A\\nselect * from B where B.id = A.id`\\n\")])])]),t(\"p\",[_._v(\"当 A 表的数据集小于 B 表的数据集时，用 exists 优于用 in\")]),_._v(\" \"),t(\"p\",[_._v(\"注意：A 表与 B 表的 ID 字段应建立索引。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"order-by-关键字优化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#order-by-关键字优化\"}},[_._v(\"#\")]),_._v(\" order by 关键字优化\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"order by 子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"https://blog.csdn.net/yangyu112654374/article/details/4251624  看个例子\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"ORDER BY 满足两种情况，会使用 Index 方式排序；\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"ORDER BY 语句使用索引最左前列\")]),_._v(\" \"),t(\"li\",[_._v(\"使用 where 子句与 ORDER BY 子句条件列组合满足索引最左前列\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"尽可能在索引列上完成排序操作，遵照建索引的最左前缀\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"如果不在索引列上，filesort 有两种算法，mysql 就要启动双路排序和单路排序\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"双路排序：MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据\")]),_._v(\" \"),t(\"li\",[_._v(\"单路排序：从磁盘读取查询需要的所有列，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"优化策略\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"增大 sort_buffer_size 参数的设置\")]),_._v(\" \"),t(\"li\",[_._v(\"增大 max_lencth_for_sort_data 参数的设置\")])])])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"group-by-关键字优化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#group-by-关键字优化\"}},[_._v(\"#\")]),_._v(\" GROUP BY 关键字优化\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"group by 实质是先排序后进行分组，遵照索引建的最佳左前缀\")]),_._v(\" \"),t(\"li\",[_._v(\"当无法使用索引列，增大 \"),t(\"code\",[_._v(\"max_length_for_sort_data\")]),_._v(\" 参数的设置，增大 \"),t(\"code\",[_._v(\"sort_buffer_size\")]),_._v(\" 参数的设置\")]),_._v(\" \"),t(\"li\",[_._v(\"where 高于 having，能写在 where 限定的条件就不要去 having 限定了\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"数据类型优化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据类型优化\"}},[_._v(\"#\")]),_._v(\" 数据类型优化\")]),_._v(\" \"),t(\"p\",[_._v(\"MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。\")]),_._v(\" \"),t(\"p\",[_._v(\"简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"尽量避免NULL：通常情况下最好指定列为NOT NULL\")])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说一下大表的优化方案\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说一下大表的优化方案\"}},[_._v(\"#\")]),_._v(\" 说一下大表的优化方案\")]),_._v(\" \"),t(\"p\",[_._v(\"https://blog.csdn.net/u011516972/article/details/89098732\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"一条sql执行过长的时间，你如何优化，从哪些方面？\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"1、查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）\")]),_._v(\" \"),t(\"p\",[_._v(\"2、涉及连表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合\")]),_._v(\" \"),t(\"p\",[_._v(\"3、如果以上两种都不能操作，非要连表查询，那么考虑对相对应的查询条件做索引。加快查询速度\")]),_._v(\" \"),t(\"p\",[_._v(\"4、针对数量大的表进行历史表分离（如交易流水表）\")]),_._v(\" \"),t(\"p\",[_._v(\"5、数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步\")]),_._v(\" \"),t(\"p\",[_._v(\"6、explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等\")]),_._v(\" \"),t(\"p\",[_._v(\"7、查看mysql执行日志，看看是否有其他方面的问题\")])]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"九、分区、分表、分库\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#九、分区、分表、分库\"}},[_._v(\"#\")]),_._v(\" 九、分区、分表、分库\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql分区\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql分区\"}},[_._v(\"#\")]),_._v(\" MySQL分区\")]),_._v(\" \"),t(\"p\",[_._v(\"一般情况下我们创建的表对应一组存储文件，使用\"),t(\"code\",[_._v(\"MyISAM\")]),_._v(\"存储引擎时是一个\"),t(\"code\",[_._v(\".MYI\")]),_._v(\"和\"),t(\"code\",[_._v(\".MYD\")]),_._v(\"文件，使用\"),t(\"code\",[_._v(\"Innodb\")]),_._v(\"存储引擎时是一个\"),t(\"code\",[_._v(\".ibd\")]),_._v(\"和\"),t(\"code\",[_._v(\".frm\")]),_._v(\"（表结构）文件。\")]),_._v(\" \"),t(\"p\",[_._v(\"当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"能干嘛\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"逻辑数据分割\")]),_._v(\" \"),t(\"li\",[_._v(\"提高单一的写和读应用速度\")]),_._v(\" \"),t(\"li\",[_._v(\"提高分区范围读查询的速度\")]),_._v(\" \"),t(\"li\",[_._v(\"分割数据能够有多个不同的物理文件路径\")]),_._v(\" \"),t(\"li\",[_._v(\"高效的保存历史数据\")])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"怎么玩\")])]),_._v(\" \"),t(\"p\",[_._v(\"首先查看当前数据库是否支持分区\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"MySQL5.6以及之前版本：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"SHOW VARIABLES LIKE '%partition%';\\n\")])])])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"MySQL5.6：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"show plugins;\\n\")])])])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"分区类型及操作\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"RANGE分区\")]),_._v(\"：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。\")]),_._v(\" \"),t(\"p\",[_._v(\"按照 range 来分，就是每个库一段连续的数据，这个一般是按比如\"),t(\"strong\",[_._v(\"时间范围\")]),_._v(\"来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。\")]),_._v(\" \"),t(\"p\",[_._v(\"range 来分，好处在于说，扩容的时候很简单。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"LIST分区\")]),_._v(\"：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"HASH分区\")]),_._v(\"：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。\")]),_._v(\" \"),t(\"p\",[_._v(\"hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"KEY分区\")]),_._v(\"：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。\")])])]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁\")]),_._v(\" \"),t(\"li\",[_._v(\"一旦数据并发量上来，如果在分区表实施关联，就是一个灾难\")]),_._v(\" \"),t(\"li\",[_._v(\"自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？\")])]),_._v(\" \"),t(\"p\",[_._v(\"这个时候就出现了\"),t(\"strong\",[_._v(\"数据分片\")]),_._v(\"，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。\")]),_._v(\" \"),t(\"p\",[_._v(\"区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"如何确定分库还是分表\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何确定分库还是分表\"}},[_._v(\"#\")]),_._v(\" 如何确定分库还是分表？\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"针对“如何确定分库还是分表？”的问题，你要结合具体的场景。\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"何时分表\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#何时分表\"}},[_._v(\"#\")]),_._v(\" 何时分表\")]),_._v(\" \"),t(\"p\",[_._v(\"当数据量过大造成事务执行缓慢时，就要考虑分表，因为减少每次查询数据总量是解决数据查询缓慢的主要原因。你可能会问：“查询可以通过主从分离或缓存来解决，为什么还要分表？”但这里的查询是指事务中的查询和更新操作。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"何时分库\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#何时分库\"}},[_._v(\"#\")]),_._v(\" 何时分库\")]),_._v(\" \"),t(\"p\",[_._v(\"为了应对高并发，一个数据库实例撑不住，即单库的性能无法满足高并发的要求，就把并发请求分散到多个实例中去（这种应对高并发的思路我之前也说过）。\")]),_._v(\" \"),t(\"p\",[_._v(\"总的来说，分库分表使用的场景不一样：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"分表是因为数据量比较大，导致事务执行缓慢；\")])])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"分库是因为单库的性能无法满足要求。\")])])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql分库\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql分库\"}},[_._v(\"#\")]),_._v(\" MySQL分库\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"为什么要分库\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么要分库\"}},[_._v(\"#\")]),_._v(\" 为什么要分库?\")]),_._v(\" \"),t(\"p\",[_._v(\"数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说大数据、频繁的写入操作对 master 性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"分库是什么\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分库是什么\"}},[_._v(\"#\")]),_._v(\" 分库是什么？\")]),_._v(\" \"),t(\"p\",[_._v(\"一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"分库的优点\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分库的优点\"}},[_._v(\"#\")]),_._v(\" 分库的优点：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"减少增量数据写入时的锁对查询的影响\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短\")])])]),_._v(\" \"),t(\"p\",[_._v(\"但是它无法解决单表数据量太大的问题\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql分表\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql分表\"}},[_._v(\"#\")]),_._v(\" MySQL分表\")]),_._v(\" \"),t(\"p\",[_._v(\"分表有两种分割方式，一种垂直拆分，另一种水平拆分。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"垂直拆分\")])]),_._v(\" \"),t(\"p\",[_._v(\"垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[t(\"strong\",[_._v(\"水平拆分(数据分片)\")])]),_._v(\" \"),t(\"p\",[_._v(\"单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。\")]),_._v(\" \"),t(\"p\",[_._v(\"水平分割的几种方法：\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。\")]),_._v(\" \"),t(\"li\",[_._v(\"还可根据时间放入不同的表，比如：article_201601，article_201602。\")]),_._v(\" \"),t(\"li\",[_._v(\"按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。\")]),_._v(\" \"),t(\"li\",[_._v(\"根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。\")])])])]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1geuibkd9mjj31ns0u0aj1.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"分库分表后的难题\")])]),_._v(\" \"),t(\"p\",[_._v(\"分布式事务的问题，数据的完整性和一致性问题。\")]),_._v(\" \"),t(\"p\",[_._v(\"数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。 跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"分布式id生成方案\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分布式id生成方案\"}},[_._v(\"#\")]),_._v(\" 分布式ID生成方案\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"分库分表之后，id主键如何处理？\")]),_._v(\" \"),t(\"p\",[_._v(\"推荐：https://zhuanlan.zhihu.com/p/107939861\")])]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"UUID：\"),t(\"code\",[_._v(\"UUID\")]),_._v(\"的生成简单到只有一行代码，输出结果 \"),t(\"code\",[_._v(\"c2b8c2b9e46c47e3b30dca3b0d447718\")]),_._v(\"，但UUID却并不适用于实际的业务需求。像用作订单号\"),t(\"code\",[_._v(\"UUID\")]),_._v(\"这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务\"),t(\"code\",[_._v(\"主键ID\")]),_._v(\"，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作\"),t(\"code\",[_._v(\"分布式ID\")]),_._v(\"。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"数据库自增ID：需要一个单独的MySQL实例用来生成ID（DB单点存在宕机风险，无法扛住高并发场景）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"数据库多主模式\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"号段模式\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"Redis：利用\"),t(\"code\",[_._v(\"redis\")]),_._v(\"的 \"),t(\"code\",[_._v(\"incr\")]),_._v(\"命令实现ID的原子性自增。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"雪花算法（SnowFlake）：\"),t(\"code\",[_._v(\"Snowflake\")]),_._v(\"生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特\")]),_._v(\" \"),t(\"p\",[_._v(\"Snowflake ID组成结构：\"),t(\"code\",[_._v(\"正数位\")]),_._v(\"（占1比特）+ \"),t(\"code\",[_._v(\"时间戳\")]),_._v(\"（占41比特）+ \"),t(\"code\",[_._v(\"机器ID\")]),_._v(\"（占5比特）+ \"),t(\"code\",[_._v(\"数据中心\")]),_._v(\"（占5比特）+ \"),t(\"code\",[_._v(\"自增值\")]),_._v(\"（占12比特），总共64比特组成的一个Long类型。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"滴滴出品（TinyID）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"百度 （Uidgenerator）\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"美团（Leaf）\")])])]),_._v(\" \"),t(\"h2\",{attrs:{id:\"十、主从复制\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#十、主从复制\"}},[_._v(\"#\")]),_._v(\" 十、主从复制\")]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"复制的基本原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制的基本原理\"}},[_._v(\"#\")]),_._v(\" 复制的基本原理\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"slave 会从 master 读取 binlog 来进行数据同步\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"三个步骤\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；\")]),_._v(\" \"),t(\"li\",[_._v(\"salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;\")]),_._v(\" \"),t(\"li\",[_._v(\"slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。\")])]),_._v(\" \"),t(\"blockquote\",[t(\"p\",[_._v(\"这么记忆\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"回放 Binlog：回放 binlog，并更新存储数据\")])])])]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://picbed-1302638964.cos.ap-beijing.myqcloud.com/mysql/94aec4abf353527cbbe2bef5a484471d.jpeg\",alt:\"\"}})])])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"mysql-一主多从\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-一主多从\"}},[_._v(\"#\")]),_._v(\" MySQL 一主多从\")]),_._v(\" \"),t(\"p\",[_._v(\"一旦你提及“一主多从”，面试官很容易设陷阱问你：那大促流量大时，是不是只要多增加几台从库，就可以抗住大促的并发读请求了？\")]),_._v(\" \"),t(\"p\",[_._v(\"当然不是。\")]),_._v(\" \"),t(\"p\",[_._v(\"因为从库数量增加，从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。\")]),_._v(\" \"),t(\"p\",[_._v(\"其实，你从 MySQL 主从复制过程也能发现，MySQL 默认是异步模式：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。\")]),_._v(\" \"),t(\"p\",[_._v(\"而这时，面试官一般会追问你“**MySQL 主从复制还有哪些模型？”**主要有三种。\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[_._v(\"同步复制：事务线程要等待所有从库的复制成功响应。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"异步复制：事务线程完全不等待从库的复制成功响应。\")])]),_._v(\" \"),t(\"li\",[t(\"p\",[_._v(\"半同步复制：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。\")])])]),_._v(\" \"),t(\"p\",[_._v(\"这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"复制的基本原则\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制的基本原则\"}},[_._v(\"#\")]),_._v(\" 复制的基本原则\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"每个 slave只有一个 master\")]),_._v(\" \"),t(\"li\",[_._v(\"每个 salve只能有一个唯一的服务器 ID\")]),_._v(\" \"),t(\"li\",[_._v(\"每个master可以有多个salve\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"复制的最大问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制的最大问题\"}},[_._v(\"#\")]),_._v(\" 复制的最大问题\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"延时\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"从架构上解决主从复制延迟\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#从架构上解决主从复制延迟\"}},[_._v(\"#\")]),_._v(\" 从架构上解决主从复制延迟\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"使用数据冗余\")]),_._v(\" \"),t(\"li\",[_._v(\"使用缓存解决\")])]),_._v(\" \"),t(\"hr\"),_._v(\" \"),t(\"h2\",{attrs:{id:\"十一、其他问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#十一、其他问题\"}},[_._v(\"#\")]),_._v(\" 十一、其他问题\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"说一说三个范式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说一说三个范式\"}},[_._v(\"#\")]),_._v(\" 说一说三个范式\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。\")]),_._v(\" \"),t(\"li\",[_._v(\"第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖，也即所有非关键字段都完全依赖于任意一组候选关键字。(数据库表中的非主属性只依赖于主键)\")]),_._v(\" \"),t(\"li\",[_._v('第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在\"A → B → C\"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y')])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"百万级别或以上的数据如何删除\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#百万级别或以上的数据如何删除\"}},[_._v(\"#\")]),_._v(\" 百万级别或以上的数据如何删除\")]),_._v(\" \"),t(\"p\",[_._v(\"关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件，所以当我们对数据的增加、修改、删除，都会产生额外的对索引文件的操作，这些操作需要消耗额外的IO，会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）\")]),_._v(\" \"),t(\"li\",[_._v(\"然后删除其中无用数据（此过程需要不到两分钟）\")]),_._v(\" \"),t(\"li\",[_._v(\"删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。\")]),_._v(\" \"),t(\"li\",[_._v(\"与之前的直接删除绝对是要快速很多，更别说万一删除中断，一切删除会回滚。那更是坑了。\")])]),_._v(\" \"),t(\"h3\",{attrs:{id:\"limit-100000-加载很慢的话-你是怎么解决的呢\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#limit-100000-加载很慢的话-你是怎么解决的呢\"}},[_._v(\"#\")]),_._v(\" limit 100000 加载很慢的话，你是怎么解决的呢？\")]),_._v(\" \"),t(\"p\",[_._v(\"在 mysql 中 limit 可以实现快速分页，但是如果数据到了几百万时我们的 limit 必须优化才能有效的合理的实现分页了，否则可能卡死你的服务器\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"当一个表数据有几百万的数据的时候成了问题！\")])]),_._v(\" \"),t(\"p\",[_._v(\"日常分页SQL语句\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"select id,name,content from users order by id asc limit 100000,20\\n\")])])]),t(\"p\",[_._v(\"扫描100020行\")]),_._v(\" \"),t(\"p\",[_._v(\"如果记录了上次的最大ID\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\" select id,name,content from users where id>100073 order by id asc limit 20\\n\")])])]),t(\"p\",[_._v(\"扫描 20 行。\")]),_._v(\" \"),t(\"p\",[_._v(\"总数据有500万左右，以下例子\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"select * from wl_tagindex where byname='f' order by id limit 300000,10 \\n\")])])]),t(\"p\",[_._v(\"执行时间是 3.21s\")]),_._v(\" \"),t(\"p\",[_._v(\"优化后：\")]),_._v(\" \"),t(\"div\",{staticClass:\"language-mysql extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"select * from (\\n  select id from wl_tagindex\\nwhere byname='f' order by id limit 300000,10\\n) a\\nleft join wl_tagindex b on a.id=b.id\\n\")])])]),t(\"p\",[_._v(\"执行时间为 0.11s 速度明显提升\")]),_._v(\" \"),t(\"p\",[_._v(\"这里需要说明的是 我这里用到的字段是 byname ,id 需要把这两个字段做复合索引，否则的话效果提升不明显\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"在高并发情况下-如何做到安全的修改同一行数据\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在高并发情况下-如何做到安全的修改同一行数据\"}},[_._v(\"#\")]),_._v(\" 在高并发情况下，如何做到安全的修改同一行数据？\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"1、使用悲观锁\")])]),_._v(\" \"),t(\"p\",[_._v(\"悲观锁本质是当前只有一个线程执行操作，排斥外部请求的修改。遇到加锁的状态，就必须等待。结束了唤醒其他线程进行处理。虽然此方案的确解决了数据安全的问题，但是，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"2、FIFO（First Input First Output，先进先出）缓存队列思路\")])]),_._v(\" \"),t(\"p\",[_._v(\"直接将请求放入队列中，就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/20190508231654761.\",alt:\"在这里插入图片描述\"}})]),_._v(\" \"),t(\"p\",[_._v(\"然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时间还是会大幅下降，系统还是陷入异常。\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"3、使用乐观锁\")])]),_._v(\" \"),t(\"p\",[_._v(\"这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"表中有大字段-x-例如-text-类型-且字段-x-不会经常更新-以读为-为主-将该字段拆成子表好处是什么\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#表中有大字段-x-例如-text-类型-且字段-x-不会经常更新-以读为-为主-将该字段拆成子表好处是什么\"}},[_._v(\"#\")]),_._v(\" 表中有大字段 \"),t(\"strong\",[_._v(\"X\")]),_._v(\"(例如:\"),t(\"strong\",[_._v(\"text\")]),_._v(\" 类型)，且字段 \"),t(\"strong\",[_._v(\"X\")]),_._v(\" 不会经常更新，以读为 为主，将该字段拆成子表好处是什么?\")]),_._v(\" \"),t(\"p\",[_._v(\"如果字段里面有大字段(text,blob)类型的，而且这些字段的访问并不多，这 时候放在一起就变成缺点了。 MYSQL 数据库的记录存储是按行存储的，数据 块大小又是固定的(16K)，每条记录越小，相同的块存储的记录就越多。此 时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需 要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后， 对字段的 UPDAE 就要 UPDATE 多个表了\")]),_._v(\" \"),t(\"h2\",{attrs:{id:\"参考与感谢\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考与感谢\"}},[_._v(\"#\")]),_._v(\" 参考与感谢：\")]),_._v(\" \"),t(\"p\",[_._v(\"https://zhuanlan.zhihu.com/p/29150809\")]),_._v(\" \"),t(\"p\",[_._v(\"https://juejin.im/post/5e3eb616f265da570d734dcb#heading-105\")]),_._v(\" \"),t(\"p\",[_._v(\"https://blog.csdn.net/yin767833376/article/details/81511377\")])])}),[],!1,null,null,null);v.default=a.exports}}]);","extractedComments":[]}