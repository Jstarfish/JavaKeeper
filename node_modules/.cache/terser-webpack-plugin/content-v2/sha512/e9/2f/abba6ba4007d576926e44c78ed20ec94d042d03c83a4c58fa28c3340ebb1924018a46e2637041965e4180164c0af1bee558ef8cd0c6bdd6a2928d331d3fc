{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{607:function(e,v,_){\"use strict\";_.r(v);var l=_(6),t=Object(l.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[_(\"h2\",{attrs:{id:\"索引结构\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#索引结构\"}},[e._v(\"#\")]),e._v(\" 索引结构\")]),e._v(\" \"),_(\"p\",[e._v(\"聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？\")]),e._v(\" \"),_(\"p\",[e._v(\"使用索引查询一定能提高查询的性能吗？为什么?\")]),e._v(\" \"),_(\"h3\",{attrs:{id:\"优化要注意的一些事\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优化要注意的一些事\"}},[e._v(\"#\")]),e._v(\" \"),_(\"a\",{attrs:{href:\"https://www.cnblogs.com/frankdeng/p/8990181.html\",title:\"优化要注意的一些事\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"优化要注意的一些事\"),_(\"OutboundLink\")],1)]),e._v(\" \"),_(\"ol\",[_(\"li\",[_(\"p\",[e._v(\"索引其实就是一种归类方式，当某一个字段属性都不能归类，建立索引后是没什么效果的，或归类就二种（0和1），且各自都数据对半分，建立索引后的效果也不怎么强。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"主键的索引是不一样的，要区别理解。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"当时间存储为时间戳保存的可以建立前缀索引。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"在什么字段上建立索引，需要根据查询条件而定，不要一上来就建立索引，浪费内存还有可能用不到。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"大字段（blob）不要建立索引，查询也不会走索引。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"常用建立索引的地方：\")]),e._v(\" \"),_(\"ul\",[_(\"li\",[e._v(\"主键的聚集索引\")]),e._v(\" \"),_(\"li\",[e._v(\"外键索引\")]),e._v(\" \"),_(\"li\",[e._v(\"类别只有0和1就不要建索引了，没有意义，对性能没有提升，还影响写入性能\")]),e._v(\" \"),_(\"li\",[e._v(\"用模糊其实是可以走前缀索引\")])])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"唯一索引一定要小心使用，它带有唯一约束，由于前期需求不明等情况下，可能造成我们对于唯一列的误判。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"由于我们建立索引并想让索引能达到最高性能，这个时候我们应当充分考虑该列是否适合建立索引，可以根据列的区分度来判断，区分度太低的情况下可以不考虑建立索引，区分度越高效率越高。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"写入比较频繁的时候，不能开启MySQL的查询缓存，因为在每一次写入的时候不光要写入磁盘还的更新缓存中的数据。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"二次SQL查询区别不大的时候，不能按照二次执行的时间来判断优化结果，没准第一次查询后又保存缓存数据，导致第二次查询速度比第二次快，很多时候我们看到的都是假象。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"Explain 执行计划只能解释SELECT操作。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"使用UNION ALL 替换OR多条件查询并集。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\"),_(\"code\",[e._v(\"select id from t where num is null\")]),e._v(\" 可以在 num上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：\"),_(\"code\",[e._v(\"select id from t where num=0\")])])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：\"),_(\"code\",[e._v(\"select id from t where num=10 or num=20\")]),e._v(\" 可以这样查询：\"),_(\"code\",[e._v(\"select id from t where num=10 union all select id from t where num=20\")])])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"in 和 not in 也要慎用，否则会导致全表扫描，如：\"),_(\"code\",[e._v(\"select id from t where num in(1,2,3)\")]),e._v(\"  对于连续的数值，能用 between 就不要用 in 了：\"),_(\"code\",[e._v(\"select id from t where num between 1 and 3\")])])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"下面的查询也将导致全表扫描：\"),_(\"code\",[e._v(\"select id from t where name like '李%'\")]),e._v(\" 若要提高效率，可以考虑全文检索。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：\"),_(\"code\",[e._v(\"select id from t where num=@num\")]),e._v(\" 可以改为强制查询使用索引：\"),_(\"code\",[e._v(\"select id from t with(index(索引名)) where num=@num\")])])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：\"),_(\"code\",[e._v(\"select id from t where num/2=100\")]),e._v(\" 应改为: \"),_(\"code\",[e._v(\"select id from t where num=100*2\")])])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：\"),_(\"code\",[e._v(\"select id from t where substring(name,1,3)='abc'\")]),e._v(\"，name 以 abc 开头的 id 应改为: \"),_(\"code\",[e._v(\"select id from t where name like 'abc%'\")])])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"不要写一些没有意义的查询，如需要生成一个空表结构：\"),_(\"code\",[e._v(\"select col1,col2 into #t from t where 1=0\")]),e._v(\" 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(...)\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"很多时候用 exists 代替 in 是一个好的选择：\"),_(\"code\",[e._v(\"select num from a where num in(select num from b)\")]),e._v(\" 用下面的语句替换：\"),_(\"code\",[e._v(\"select num from a where exists(select 1 from b where num=a.num)\")])])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\")])]),e._v(\" \"),_(\"li\",[_(\"p\",[e._v(\"任何地方都不要使用 \"),_(\"code\",[e._v(\"select * from t\")]),e._v(\" ，用具体的字段列表代替“*”，不要返回用不到的任何字段。\")])])]),e._v(\" \"),_(\"h3\",{attrs:{id:\"聚簇索引优缺点\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#聚簇索引优缺点\"}},[e._v(\"#\")]),e._v(\" 聚簇索引优缺点\")]),e._v(\" \"),_(\"p\",[e._v(\"聚族索引的优点\")]),e._v(\" \"),_(\"ol\",[_(\"li\",[e._v(\"可以把相关数据保存在一起。例如实现电子邮件时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚族索引，则每封邮件都可能导致一次磁盘I/O；\")]),e._v(\" \"),_(\"li\",[e._v(\"数据访问更快。聚族索引将索引和数据保存在同一个B-Tree中，因此从聚族索引中获取数据通常比在非聚族索引中查找更快。\")]),e._v(\" \"),_(\"li\",[e._v(\"使用覆盖索引扫描的查询可以直接使用节点中的主键值。\")])]),e._v(\" \"),_(\"p\",[e._v(\"聚族索引的缺点\")]),e._v(\" \"),_(\"ol\",[_(\"li\",[e._v(\"聚簇数据最大限度的提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有那么优势了；\")]),e._v(\" \"),_(\"li\",[e._v(\"插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。\")]),e._v(\" \"),_(\"li\",[e._v(\"更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。\")]),e._v(\" \"),_(\"li\",[e._v(\"基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次分裂操作。页分裂会导致表占用更多的磁盘空间。\")]),e._v(\" \"),_(\"li\",[e._v(\"聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。\")]),e._v(\" \"),_(\"li\",[e._v(\"二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。\")]),e._v(\" \"),_(\"li\",[e._v(\"二级索引访问需要两次索引查找，而不是一次。\")])])])}),[],!1,null,null,null);v.default=t.exports}}]);","extractedComments":[]}