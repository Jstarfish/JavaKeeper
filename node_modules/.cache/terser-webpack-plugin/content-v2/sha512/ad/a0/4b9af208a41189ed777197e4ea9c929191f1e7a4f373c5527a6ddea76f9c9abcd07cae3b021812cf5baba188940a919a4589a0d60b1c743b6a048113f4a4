{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{765:function(s,e,t){\"use strict\";t.r(e);var i=t(6),r=Object(i.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[t(\"h2\",{attrs:{id:\"为什么单线程的-redis-能那么快\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么单线程的-redis-能那么快\"}},[s._v(\"#\")]),s._v(\" 为什么单线程的 Redis 能那么快？\")]),s._v(\" \"),t(\"p\",[s._v(\"首先，我们要知道一个事实，我们通常说，Redis 是单线程，主要是指 \"),t(\"strong\",[s._v(\"Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程\")]),s._v(\"。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"redis-为什么用单线程\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis-为什么用单线程\"}},[s._v(\"#\")]),s._v(\" Redis 为什么用单线程？\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。\")]),s._v(\" \"),t(\"li\",[s._v(\"不需要各种锁的性能消耗：多线程编程模式面临的共享资源的并发访问控制问题。并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"单线程-redis-为什么那么快\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#单线程-redis-为什么那么快\"}},[s._v(\"#\")]),s._v(\" 单线程 Redis 为什么那么快？\")]),s._v(\" \"),t(\"p\",[s._v(\"通常来说，单线程的处理能力要比多线程差很多，但是 Redis 却能使用单线程模型达到每秒数十万级别的处理能力，这是为什么呢？其实，这是 Redis 多方面设计选择的一个综合结果。\")]),s._v(\" \"),t(\"p\",[s._v(\"一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。\")]),s._v(\" \"),t(\"p\",[s._v(\"另一方面，采用单线程，避免了不必要的上下文切换和竞争条件\")]),s._v(\" \"),t(\"p\",[s._v(\"最后一个，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。\")])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}