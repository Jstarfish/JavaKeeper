{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{514:function(t,_,v){t.exports=v.p+\"assets/img/tablespace-segment-extent-page-row.c87324ea.jpg\"},515:function(t,_,v){t.exports=v.p+\"assets/img/frm-file-hex.97bd8557.png\"},516:function(t,_,v){t.exports=v.p+\"assets/img/Antelope-Barracuda-Row-Format.99352e9c.jpg\"},517:function(t,_,v){t.exports=v.p+\"assets/img/COMPACT-And-REDUNDANT-Row-Format.d36c1e80.jpg\"},518:function(t,_,v){t.exports=v.p+\"assets/img/Row-Overflow.1a9270b0.jpg\"},519:function(t,_,v){t.exports=v.p+\"assets/img/Row-Overflow-in-Barracuda.2f4ffcec.jpg\"},520:function(t,_,v){t.exports=v.p+\"assets/img/InnoDB-B-Tree-Node.ba47f3f8.jpg\"},521:function(t,_,v){t.exports=v.p+\"assets/img/Infimum-Rows-Supremum.fbc427ee.jpg\"},616:function(t,_,v){\"use strict\";v.r(_);var e=v(6),s=Object(e.a)({},(function(){var t=this,_=t.$createElement,e=t._self._c||_;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"mysql-storage-engines\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-storage-engines\"}},[t._v(\"#\")]),t._v(\" Mysql Storage Engines\")]),t._v(\" \"),e(\"p\",[t._v(\"存储引擎是 MySQL 的组件，用于处理不同表类型的 SQL 操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。\")]),t._v(\" \"),e(\"p\",[t._v(\"使用哪一种引擎可以灵活选择，\"),e(\"strong\",[e(\"font\",{attrs:{color:\"red\"}},[t._v(\"一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求\")])],1),t._v(\"，使用合适的存储引擎，将会提高整个数据库的性能 。\")]),t._v(\" \"),e(\"p\",[t._v(\"MySQL服务器使用可插拔的存储引擎体系结构，可以从运行中的MySQL服务器加载或卸载存储引擎 。\")]),t._v(\" \"),e(\"blockquote\",[e(\"p\",[e(\"a\",{attrs:{href:\"https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"MySQL 5.7 可供选择的存储引擎\"),e(\"OutboundLink\")],1)])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"查看存储引擎\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#查看存储引擎\"}},[t._v(\"#\")]),t._v(\" 查看存储引擎\")]),t._v(\" \"),e(\"div\",{staticClass:\"language-mysql extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"-- 查看支持的存储引擎\\nSHOW ENGINES\\n\\n-- 查看默认存储引擎\\nSHOW VARIABLES LIKE 'storage_engine'\\n\\n--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！\\nshow create table tablename\\n\\n--准确查看某个数据库中的某一表所使用的存储引擎\\nshow table status like 'tablename'\\nshow table status from database where name=\\\"tablename\\\"\\n\")])])]),e(\"p\",[e(\"img\",{attrs:{src:\"https://img.starfish.ink/mysql/mysql-engines.png\",alt:\"mysql-engines\"}})]),t._v(\" \"),e(\"h3\",{attrs:{id:\"设置存储引擎\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#设置存储引擎\"}},[t._v(\"#\")]),t._v(\" 设置存储引擎\")]),t._v(\" \"),e(\"div\",{staticClass:\"language-mysql extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"-- 建表时指定存储引擎。默认的就是INNODB，不需要设置\\nCREATE TABLE t1 (i INT) ENGINE = INNODB;\\nCREATE TABLE t2 (i INT) ENGINE = CSV;\\nCREATE TABLE t3 (i INT) ENGINE = MEMORY;\\n\\n-- 修改存储引擎\\nALTER TABLE t ENGINE = InnoDB;\\n\\n-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎\\nSET default_storage_engine=NDBCLUSTER;\\n\")])])]),e(\"p\",[t._v(\"默认情况下，每当CREATE TABLE或ALTER TABLE不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用\"),e(\"code\",[t._v(\"NO_ENGINE_SUBSTITUTION SQL\")]),t._v(\"模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"常用存储引擎\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常用存储引擎\"}},[t._v(\"#\")]),t._v(\" 常用存储引擎\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"innodb\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#innodb\"}},[t._v(\"#\")]),t._v(\" InnoDB\")]),t._v(\" \"),e(\"p\",[e(\"strong\",[t._v(\"InnoDB 是 MySQL5.7 默认的存储引擎，主要特性有\")])]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"InnoDB存储引擎维护自己的缓冲池，在访问数据时将表和索引数据缓存在主内存中\")]),t._v(\" \"),e(\"li\",[t._v(\"支持事务\")]),t._v(\" \"),e(\"li\",[t._v(\"支持外键\")]),t._v(\" \"),e(\"li\",[t._v(\"B-Tree索引\")]),t._v(\" \"),e(\"li\",[t._v(\"不支持集群\")]),t._v(\" \"),e(\"li\",[t._v(\"聚簇索引\")]),t._v(\" \"),e(\"li\",[t._v(\"行锁\")]),t._v(\" \"),e(\"li\",[t._v(\"支持地理位置的数据类型和索引\")])]),t._v(\" \"),e(\"h5\",{attrs:{id:\"mysql之innodb引擎的4大特性\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql之innodb引擎的4大特性\"}},[t._v(\"#\")]),t._v(\" MySQL之Innodb引擎的4大特性\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[t._v(\"插入缓冲 （Insert Buffer/Change Buffer）\")]),t._v(\" \"),e(\"li\",[t._v(\"双写机制（Double Write）\")]),t._v(\" \"),e(\"li\",[t._v(\"自适应哈希索引（Adaptive Hash Index，AHI）\")]),t._v(\" \"),e(\"li\",[t._v(\"预读 （Read Ahead）\")])]),t._v(\" \"),e(\"h4\",{attrs:{id:\"myisam\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#myisam\"}},[t._v(\"#\")]),t._v(\" MyISAM\")]),t._v(\" \"),e(\"p\",[t._v(\"在 5.1 版本之前，MyISAM 是 MySQL 的默认存储引擎，MyISAM 并发性比较差，使用的场景比较少，主要特点是\")]),t._v(\" \"),e(\"p\",[t._v(\"每个MyISAM表存储在磁盘上的三个文件中 。这些文件的名称以表名开头，并有一个扩展名来指示文件类型 。\")]),t._v(\" \"),e(\"p\",[e(\"code\",[t._v(\".frm\")]),t._v(\"文件存储表的格式。 \"),e(\"code\",[t._v(\".MYD\")]),t._v(\" (\"),e(\"code\",[t._v(\"MYData\")]),t._v(\") 文件存储表的数据。 \"),e(\"code\",[t._v(\".MYI\")]),t._v(\" (\"),e(\"code\",[t._v(\"MYIndex\")]),t._v(\") 文件存储索引。\")]),t._v(\" \"),e(\"p\",[e(\"strong\",[t._v(\"MyISAM表具有以下特征\")])]),t._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[t._v(\"每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"每个MyISAM表都支持一个\"),e(\"code\",[t._v(\"AUTO_INCREMENT\")]),t._v(\"的内部列。当执行\"),e(\"code\",[t._v(\"INSERT\")]),t._v(\"或者\"),e(\"code\",[t._v(\"UPDATE\")]),t._v(\"操作的时候，MyISAM自动更新这个列，这使得\"),e(\"code\",[t._v(\"AUTO_INCREMENT\")]),t._v(\"列更快。\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"MyISAM支持\"),e(\"strong\",[t._v(\"并发插入\")])])]),t._v(\" \"),e(\"li\",[e(\"p\",[e(\"strong\",[t._v(\"可以将数据文件和索引文件放在不同物理设备上的不同目录中\")]),t._v(\"，以更快地使用数据目录和索引目录表选项来创建表\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"BLOB和TEXT列可以被索引\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[e(\"strong\",[t._v(\"NULL被允许在索引的列中\")]),t._v(\"，这个值占每个键的0~1个字节\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"每个字符列可以有不同的字符集\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[e(\"strong\",[e(\"code\",[t._v(\"MyISAM\")]),t._v(\" 表使用 B-tree 索引\")])])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"MyISAM表的行最大限制为  (2^32)^2 (1.844E+19)\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"键的最大长度为1000字节，这也可以通过重新编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"VARCHAR支持固定或动态记录长度\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"表中VARCHAR和CHAR列的长度总和有可能达到64KB\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"任意长度的唯一约束\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[e(\"small\",[t._v(\"All data values are stored with the low byte first. This makes the data machine and operating system independent. \")])])]),t._v(\" \"),e(\"li\",[e(\"p\",[e(\"small\",[t._v(\" All numeric key values are stored with the high byte first to permit better index compression\")])]),t._v(\" \"),e(\"p\",[t._v(\"todo：最后两条没搞懂啥意思\")])])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"存储引擎对比\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#存储引擎对比\"}},[t._v(\"#\")]),t._v(\" 存储引擎对比\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"对比项\")]),t._v(\" \"),e(\"th\",[t._v(\"MyISAM\")]),t._v(\" \"),e(\"th\",[t._v(\"InnoDB\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[t._v(\"主外键\")]),t._v(\" \"),e(\"td\",[t._v(\"不支持\")]),t._v(\" \"),e(\"td\",[t._v(\"支持\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"事务\")]),t._v(\" \"),e(\"td\",[t._v(\"不支持\")]),t._v(\" \"),e(\"td\",[t._v(\"支持\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"行表锁\")]),t._v(\" \"),e(\"td\",[t._v(\"表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作\")]),t._v(\" \"),e(\"td\",[t._v(\"行锁,操作时只锁某一行，不对其它行有影响，\"),e(\"br\"),t._v(\"适合高并发的操作\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"缓存\")]),t._v(\" \"),e(\"td\",[t._v(\"只缓存索引，不缓存真实数据\")]),t._v(\" \"),e(\"td\",[t._v(\"不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"表空间\")]),t._v(\" \"),e(\"td\",[t._v(\"小\")]),t._v(\" \"),e(\"td\",[t._v(\"大\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"关注点\")]),t._v(\" \"),e(\"td\",[t._v(\"性能\")]),t._v(\" \"),e(\"td\",[t._v(\"事务\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"默认安装\")]),t._v(\" \"),e(\"td\",[t._v(\"是\")]),t._v(\" \"),e(\"td\",[t._v(\"是\")])])])]),t._v(\" \"),e(\"p\",[t._v(\"官方提供的多种引擎对比\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"Feature\")]),t._v(\" \"),e(\"th\",[t._v(\"MyISAM\")]),t._v(\" \"),e(\"th\",[t._v(\"Memory\")]),t._v(\" \"),e(\"th\",[t._v(\"InnoDB\")]),t._v(\" \"),e(\"th\",[t._v(\"Archive\")]),t._v(\" \"),e(\"th\",[t._v(\"NDB\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"B-tree indexes\")])]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Backup/point-in-time recovery\")]),t._v(\" (note 1)\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Cluster database support\")])]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Clustered indexes\")])]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Compressed data\")])]),t._v(\" \"),e(\"td\",[t._v(\"Yes (note 2)\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Data caches\")])]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"N/A\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Encrypted data\")])]),t._v(\" \"),e(\"td\",[t._v(\"Yes (note 3)\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes (note 3)\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes (note 4)\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes (note 3)\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes (note 3)\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Foreign key support\")])]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes (note 5)\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Full-text search indexes\")])]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes (note 6)\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Geospatial data type support\")])]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Geospatial indexing support\")])]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes (note 7)\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Hash indexes\")])]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No (note 8)\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Index caches\")])]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"N/A\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Locking granularity\")])]),t._v(\" \"),e(\"td\",[t._v(\"Table\")]),t._v(\" \"),e(\"td\",[t._v(\"Table\")]),t._v(\" \"),e(\"td\",[t._v(\"Row\")]),t._v(\" \"),e(\"td\",[t._v(\"Row\")]),t._v(\" \"),e(\"td\",[t._v(\"Row\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"MVCC\")])]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Replication support\")]),t._v(\" (note 1)\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Limited (note 9)\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Storage limits\")])]),t._v(\" \"),e(\"td\",[t._v(\"256TB\")]),t._v(\" \"),e(\"td\",[t._v(\"RAM\")]),t._v(\" \"),e(\"td\",[t._v(\"64TB\")]),t._v(\" \"),e(\"td\",[t._v(\"None\")]),t._v(\" \"),e(\"td\",[t._v(\"384EB\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"T-tree indexes\")])]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Transactions\")])]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"No\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"Update statistics for data dictionary\")])]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")]),t._v(\" \"),e(\"td\",[t._v(\"Yes\")])])])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"数据的存储\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据的存储\"}},[t._v(\"#\")]),t._v(\" 数据的存储\")]),t._v(\" \"),e(\"p\",[t._v(\"在整个数据库体系结构中，我们可以使用不同的存储引擎来存储数据，而绝大多数存储引擎都以二进制的形式存储数据；这一节会介绍 InnoDB 中对数据是如何存储的。\")]),t._v(\" \"),e(\"p\",[t._v(\"在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:v(514),alt:\"tablespace-segment-extent-page-row\"}})]),t._v(\" \"),e(\"p\",[t._v(\"同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 \"),e(\"code\",[t._v(\"innodb_page_size\")]),t._v(\" 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20210809_11aefc96-f8bc-11eb-b9b6-00163e068ecd.png\",alt:\"img\"}})]),t._v(\" \"),e(\"p\",[t._v(\"从图中可以看出，在 InnoDB 存储引擎中，一个区的大小最小为 1MB，页的数量最少为 64 个。\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"如何存储表\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何存储表\"}},[t._v(\"#\")]),t._v(\" 如何存储表\")]),t._v(\" \"),e(\"p\",[t._v(\"MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 \"),e(\"code\",[t._v(\".frm\")]),t._v(\" 文件中，后者存储在 \"),e(\"code\",[t._v(\".ibd\")]),t._v(\" 文件中，这一节就会对这两种不同的文件分别进行介绍。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://raw.githubusercontent.com/Draveness/Analyze/master/contents/Database/images/mysql/frm-and-ibd-file.jpg\",alt:\"frm-and-ibd-file\"}})]),t._v(\" \"),e(\"h4\",{attrs:{id:\"frm-文件\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#frm-文件\"}},[t._v(\"#\")]),t._v(\" .frm 文件\")]),t._v(\" \"),e(\"p\",[t._v(\"无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 \"),e(\"code\",[t._v(\".frm\")]),t._v(\" 文件用来描述表的格式或者说定义；\"),e(\"code\",[t._v(\".frm\")]),t._v(\" 文件的格式在不同的平台上都是相同的。\")]),t._v(\" \"),e(\"div\",{staticClass:\"language-mysql extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"`CREATE TABLE test_frm(``  ``column1 CHAR(5),``  ``column2 INTEGER``);`\\n\")])])]),e(\"p\",[t._v(\"当我们使用上面的代码创建表时，会在磁盘上的 \"),e(\"code\",[t._v(\"datadir\")]),t._v(\" 文件夹中生成一个 \"),e(\"code\",[t._v(\"test_frm.frm\")]),t._v(\" 的文件，这个文件中就包含了表结构相关的信息：\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:v(515),alt:\"frm-file-hex\"}})]),t._v(\" \"),e(\"blockquote\",[e(\"p\",[t._v(\"MySQL 官方文档中的 \"),e(\"a\",{attrs:{href:\"https://dev.mysql.com/doc/internals/en/frm-file-format.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"11.1 MySQL .frm File Format\"),e(\"OutboundLink\")],1),t._v(\" 一文对于 \"),e(\"code\",[t._v(\".frm\")]),t._v(\" 文件格式中的二进制的内容有着非常详细的表述。\")])]),t._v(\" \"),e(\"h4\",{attrs:{id:\"ibd-文件\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ibd-文件\"}},[t._v(\"#\")]),t._v(\" .ibd 文件\")]),t._v(\" \"),e(\"p\",[t._v(\"InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 \"),e(\"code\",[t._v(\"ibdata1\")]),t._v(\"、\"),e(\"code\",[t._v(\"ibdata2\")]),t._v(\" 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。\")]),t._v(\" \"),e(\"p\",[t._v(\"当打开 \"),e(\"code\",[t._v(\"innodb_file_per_table\")]),t._v(\" 选项时，\"),e(\"code\",[t._v(\".ibd\")]),t._v(\" 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"如何存储记录\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何存储记录\"}},[t._v(\"#\")]),t._v(\" 如何存储记录\")]),t._v(\" \"),e(\"p\",[t._v(\"与现有的大多数存储引擎一样，InnoDB 使用页作为磁盘管理的最小单位；数据在 InnoDB 存储引擎中都是按行存储的，每个 16KB 大小的页中可以存放 2-7992 行的记录。（至少是2条记录，最多是7992条记录）\")]),t._v(\" \"),e(\"p\",[t._v(\"当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:v(516),alt:\"Antelope-Barracuda-Row-Format\"}})]),t._v(\" \"),e(\"p\",[t._v(\"Antelope 是 InnoDB 最开始支持的文件格式，它包含两种行格式 Compact 和 Redundant，它最开始并没有名字；Antelope 的名字是在新的文件格式 Barracuda 出现后才起的，Barracuda 的出现引入了两种新的行格式 Compressed 和 Dynamic；InnoDB 对于文件格式都会向前兼容，而官方文档中也对之后会出现的新文件格式预先定义好了名字：Cheetah、Dragon、Elk 等等。\")]),t._v(\" \"),e(\"p\",[t._v(\"两种行记录格式 Compact 和 Redundant 在磁盘上按照以下方式存储：\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:v(517),alt:\"COMPACT-And-REDUNDANT-Row-Format\"}})]),t._v(\" \"),e(\"p\",[t._v(\"Compact 和 Redundant 格式最大的不同就是记录格式的第一个部分；在 Compact 中，行记录的第一部分倒序存放了一行数据中列的长度（Length），而 Redundant 中存的是每一列的偏移量（Offset），从总体上看，Compact 行记录格式相比 Redundant 格式能够减少 20% 的存储空间。\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"行溢出数据\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#行溢出数据\"}},[t._v(\"#\")]),t._v(\" 行溢出数据\")]),t._v(\" \"),e(\"p\",[t._v(\"当 InnoDB 使用 Compact 或者 Redundant 格式存储极长的 VARCHAR 或者 BLOB 这类大对象时，我们并不会直接将所有的内容都存放在数据页节点中，而是将行数据中的前 768 个字节存储在数据页中，后面会通过偏移量指向溢出页。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:v(518),alt:\"Row-Overflo\"}})]),t._v(\" \"),e(\"p\",[t._v(\"但是当我们使用新的行记录格式 Compressed 或者 Dynamic 时都只会在行记录中保存 20 个字节的指针，实际的数据都会存放在溢出页面中。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:v(519),alt:\"Row-Overflow-in-Barracuda\"}})]),t._v(\" \"),e(\"p\",[t._v(\"当然在实际存储中，可能会对不同长度的 TEXT 和 BLOB 列进行优化，不过这就不是本文关注的重点了。\")]),t._v(\" \"),e(\"blockquote\",[e(\"p\",[t._v(\"想要了解更多与 InnoDB 存储引擎中记录的数据格式的相关信息，可以阅读 \"),e(\"a\",{attrs:{href:\"https://dev.mysql.com/doc/internals/en/innodb-record-structure.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"InnoDB Record Structure\"),e(\"OutboundLink\")],1)])]),t._v(\" \"),e(\"h4\",{attrs:{id:\"数据页结构\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据页结构\"}},[t._v(\"#\")]),t._v(\" 数据页结构\")]),t._v(\" \"),e(\"p\",[t._v(\"页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面，我们在这里将要介绍页是如何组织和存储记录的；首先，一个 InnoDB 页有以下七个部分：\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:v(520),alt:\"InnoDB-B-Tree-Node\"}})]),t._v(\" \"),e(\"p\",[t._v(\"每一个页中包含了两对 header/trailer：内部的 Page Header/Page Directory 关心的是页的状态信息，而 Fil Header/Fil Trailer 关心的是记录页的头信息。\")]),t._v(\" \"),e(\"p\",[t._v(\"在页的头部和尾部之间就是用户记录和空闲空间了，每一个数据页中都包含 Infimum 和 Supremum 这两个虚拟的记录（可以理解为占位符），Infimum 记录是比该页中任何主键值都要小的值，Supremum 是该页中的最大值：\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:v(521),alt:\"Infimum-Rows-Supremum\"}})]),t._v(\" \"),e(\"p\",[t._v(\"User Records 就是整个页面中真正用于存放行记录的部分，而 Free Space 就是空余空间了，它是一个链表的数据结构，为了保证插入和删除的效率，整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入，行记录在物理存储上并不是按照顺序的，它们之间的顺序是由 \"),e(\"code\",[t._v(\"next_record\")]),t._v(\" 这一指针控制的。\")]),t._v(\" \"),e(\"p\",[t._v(\"B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 \"),e(\"code\",[t._v(\"n_owned\")]),t._v(\"、\"),e(\"code\",[t._v(\"next_record\")]),t._v(\" 属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。\")]),t._v(\" \"),e(\"p\",[t._v(\"InnoDB 存储引擎中对数据的存储是一个非常复杂的话题，这一节中也只是对表、行记录以及页面的存储进行一定的分析和介绍，虽然作者相信这部分知识对于大部分开发者已经足够了，但是想要真正消化这部分内容还需要很多的努力和实践。\")]),t._v(\" \"),e(\"blockquote\",[e(\"p\",[e(\"a\",{attrs:{href:\"https://www.cnblogs.com/chenpingzhao/p/9177324.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"踏雪无痕-InnoDB存储引擎\"),e(\"OutboundLink\")],1)])])])}),[],!1,null,null,null);_.default=s.exports}}]);","extractedComments":[]}