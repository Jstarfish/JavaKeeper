{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{635:function(e,s,a){\"use strict\";a.r(s);var t=a(6),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h2\",{attrs:{id:\"info-指令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#info-指令\"}},[e._v(\"#\")]),e._v(\" Info 指令\")]),e._v(\" \"),a(\"p\",[e._v(\"在使用 Redis 时，时常会遇到很多问题需要诊断，在诊断之前需要了解 Redis 的运行状态，通过强大的 Info 指令，你可以清晰地知道 Redis 内部一系列运行参数。\")]),e._v(\" \"),a(\"p\",[e._v(\"Info 指令显示的信息非常繁多，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是:\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"Server 服务器运行的环境参数\")]),e._v(\" \"),a(\"li\",[e._v(\"Clients 客户端相关信息\")]),e._v(\" \"),a(\"li\",[e._v(\"Memory 服务器运行内存统计数据\")]),e._v(\" \"),a(\"li\",[e._v(\"Persistence 持久化信息\")]),e._v(\" \"),a(\"li\",[e._v(\"Stats 通用统计数据\")]),e._v(\" \"),a(\"li\",[e._v(\"Replication 主从复制相关信息\")]),e._v(\" \"),a(\"li\",[e._v(\"CPU CPU 使用情况\")]),e._v(\" \"),a(\"li\",[e._v(\"Cluster 集群信息\")]),e._v(\" \"),a(\"li\",[e._v(\"KeySpace 键值对统计数量信息\")])]),e._v(\" \"),a(\"p\",[e._v(\"Info 可以一次性获取所有的信息，也可以按块取信息。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"# 获取所有信息\\n> info\\n# 获取内存相关信息\\n> info memory\\n# 获取复制相关信息\\n> info replication\\n\\n#Redis 连接了多少客户端？\\n> info clients\\n\\n#Redis 内存占用多大 ?\\n> redis-cli info memory | grep used | grep human\\nused_memory_human:827.46K # 内存分配器 (jemalloc) 从操作系统分配的内存总量\\nused_memory_rss_human:3.61M  # 操作系统看到的内存占用 ,top 命令看到的内存\\nused_memory_peak_human:829.41K  # Redis 内存消耗的峰值\\nused_memory_lua_human:37.00K # lua 脚本引擎占用的内存大小\\n\\n#复制积压缓冲区多大？\\n> redis-cli info replication |grep backlog\\nrepl_backlog_active:0\\nrepl_backlog_size:1048576  # 这个就是积压缓冲区大小\\nrepl_backlog_first_byte_offset:0\\nrepl_backlog_histlen:0\\n\")])])]),a(\"p\",[e._v(\"考虑到参数非常繁多，一一说明工作量巨大，下面我只挑一些关键性的、非常实用和最常用的参数进行详细讲解。如果读者想要了解所有的参数细节，请参考阅读 \"),a(\"a\",{attrs:{href:\"https://link.juejin.cn/?target=https%3A%2F%2Fredis.io%2Fcommands%2Finfo\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Redis 官网文档\"),a(\"OutboundLink\")],1),e._v(\"。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"redis-每秒执行多少次指令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis-每秒执行多少次指令\"}},[e._v(\"#\")]),e._v(\" Redis 每秒执行多少次指令？\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/16/164a14ce6633c24a~tplv-t2oaga2asx-watermark.awebp\",alt:\"img\"}})]),e._v(\" \"),a(\"p\",[e._v(\"这个信息在 Stats 块里，可以通过 \"),a(\"code\",[e._v(\"info stats\")]),e._v(\" 看到。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"# ops_per_sec: operations per second，也就是每秒操作数\\n> redis-cli info stats |grep ops\\ninstantaneous_ops_per_sec:789\\n\")])])]),a(\"p\",[a(\"img\",{attrs:{src:\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/13/1649181bd00bed33~tplv-t2oaga2asx-watermark.awebp\",alt:\"img\"}})]),e._v(\" \"),a(\"p\",[e._v(\"以上，表示 ops 是 789，也就是所有客户端每秒会发送 789 条指令到服务器执行。极限情况下，Redis 可以每秒执行 10w 次指令，CPU 几乎完全榨干。如果 qps 过高，可以考虑通过 \"),a(\"code\",[e._v(\"monitor\")]),e._v(\" 指令快速观察一下究竟是哪些 key 访问比较频繁，从而在相应的业务上进行优化，以减少 IO 次数。\"),a(\"code\",[e._v(\"monitor\")]),e._v(\" 指令会瞬间吐出来巨量的指令文本，所以一般在执行 \"),a(\"code\",[e._v(\"monitor\")]),e._v(\" 后立即 \"),a(\"code\",[e._v(\"ctrl+c\")]),e._v(\"中断输出。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"> redis-cli monitor\\n\")])])]),a(\"h2\",{attrs:{id:\"redis-连接了多少客户端\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis-连接了多少客户端\"}},[e._v(\"#\")]),e._v(\" Redis 连接了多少客户端？\")]),e._v(\" \"),a(\"p\",[e._v(\"这个信息在 Clients 块里，可以通过 \"),a(\"code\",[e._v(\"info clients\")]),e._v(\" 看到。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"> redis-cli info clients\\n# Clients\\nconnected_clients:124  # 这个就是正在连接的客户端数量\\nclient_longest_output_list:0\\nclient_biggest_input_buf:0\\nblocked_clients:0\\n\")])])]),a(\"p\",[e._v(\"这个信息也是比较有用的，通过观察这个数量可以确定是否存在意料之外的连接。如果发现这个数量不对劲，接着就可以使用\"),a(\"code\",[e._v(\"client list\")]),e._v(\"指令列出所有的客户端链接地址来确定源头。\")]),e._v(\" \"),a(\"p\",[e._v(\"关于客户端的数量还有个重要的参数需要观察，那就是\"),a(\"code\",[e._v(\"rejected_connections\")]),e._v(\"，它表示因为超出最大连接数限制而被拒绝的客户端连接次数，如果这个数字很大，意味着服务器的最大连接数设置的过低需要调整 \"),a(\"code\",[e._v(\"maxclients\")]),e._v(\" 参数。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"> redis-cli info stats |grep reject\\nrejected_connections:0\\n\")])])]),a(\"h2\",{attrs:{id:\"redis-内存占用多大\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis-内存占用多大\"}},[e._v(\"#\")]),e._v(\" Redis 内存占用多大 ?\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/16/164a14efc8e3e44b~tplv-t2oaga2asx-watermark.awebp\",alt:\"img\"}})]),e._v(\" \"),a(\"p\",[e._v(\"这个信息在 Memory 块里，可以通过 \"),a(\"code\",[e._v(\"info memory\")]),e._v(\" 看到。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"> redis-cli info memory | grep used | grep human\\nused_memory_human:827.46K # 内存分配器 (jemalloc) 从操作系统分配的内存总量\\nused_memory_rss_human:3.61M  # 操作系统看到的内存占用 ,top 命令看到的内存\\nused_memory_peak_human:829.41K  # Redis 内存消耗的峰值\\nused_memory_lua_human:37.00K # lua 脚本引擎占用的内存大小\\n\")])])]),a(\"p\",[e._v(\"如果单个 Redis 内存占用过大，并且在业务上没有太多压缩的空间的话，可以考虑集群化了。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"复制积压缓冲区多大\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制积压缓冲区多大\"}},[e._v(\"#\")]),e._v(\" 复制积压缓冲区多大？\")]),e._v(\" \"),a(\"p\",[e._v(\"这个信息在 Replication 块里，可以通过 \"),a(\"code\",[e._v(\"info replication\")]),e._v(\" 看到。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"> redis-cli info replication |grep backlog\\nrepl_backlog_active:0\\nrepl_backlog_size:1048576  # 这个就是积压缓冲区大小\\nrepl_backlog_first_byte_offset:0\\nrepl_backlog_histlen:0\\n\")])])]),a(\"p\",[e._v(\"复制积压缓冲区大小非常重要，它严重影响到主从复制的效率。当从库因为网络原因临时断开了主库的复制，然后网络恢复了，又重新连上的时候，这段断开的时间内发生在 master 上的修改操作指令都会放在积压缓冲区中，这样从库可以通过积压缓冲区恢复中断的主从同步过程。\")]),e._v(\" \"),a(\"p\",[e._v(\"积压缓冲区是环形的，后来的指令会覆盖掉前面的内容。如果从库断开的时间过长，或者缓冲区的大小设置的太小，都会导致从库无法快速恢复中断的主从同步过程，因为中间的修改指令被覆盖掉了。这时候从库就会进行全量同步模式，非常耗费 CPU 和网络资源。\")]),e._v(\" \"),a(\"p\",[e._v(\"如果有多个从库复制，积压缓冲区是共享的，它不会因为从库过多而线性增长。如果实例的修改指令请求很频繁，那就把积压缓冲区调大一些，几十个 M 大小差不多了，如果很闲，那就设置为几个 M。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"> redis-cli info stats | grep sync\\nsync_full:0\\nsync_partial_ok:0\\nsync_partial_err:0  # 半同步失败次数\\n\")])])]),a(\"p\",[e._v(\"通过查看\"),a(\"code\",[e._v(\"sync_partial_err\")]),e._v(\"变量的次数来决定是否需要扩大积压缓冲区，它表示主从半同步复制失败的次数。\")])])}),[],!1,null,null,null);s.default=n.exports}}]);","extractedComments":[]}