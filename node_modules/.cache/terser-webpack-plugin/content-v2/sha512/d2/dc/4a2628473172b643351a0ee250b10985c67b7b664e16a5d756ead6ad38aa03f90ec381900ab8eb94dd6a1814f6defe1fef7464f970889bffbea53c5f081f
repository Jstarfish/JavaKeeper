{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{715:function(t,a,v){\"use strict\";v.r(a);var e=v(6),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[v(\"p\",[t._v(\"MyBatis是一个支持\"),v(\"strong\",[t._v(\"普通SQL查询\")]),t._v(\"，\"),v(\"strong\",[t._v(\"存储过程\")]),t._v(\"和\"),v(\"strong\",[t._v(\"高级映射\")]),t._v(\"的优秀\"),v(\"strong\",[t._v(\"持久层框架\")]),t._v(\"。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的\"),v(\"strong\",[t._v(\"XML或注解\")]),t._v(\"用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。\")]),t._v(\" \"),v(\"p\",[t._v(\"很多人会将 Hibernate 和 MyBatis 做比较，认为 Hibernate 是全自动 ORM 框架，而 MyBatis 只是半自动的 ORM 框架或是一个 SQL 模板引擎。其实，这些比较都无法完全说明一个框架比另一个框架先进，关键还是看应用场景。\")]),t._v(\" \"),v(\"p\",[t._v(\"映射文件或是注解定义 Java 语言中的类与数据库中的表之间的各种映射关系，这里使用到的映射文件后缀为“.hbm.xml”。\")]),t._v(\" \"),v(\"p\",[t._v(\"但需要注意的是，Hibernate 并不是一颗“银弹”，我们无法在面向对象模型中找到数据库中所有概念的映射，例如，索引、函数、存储过程等。\")]),t._v(\" \"),v(\"p\",[t._v(\"Hibernate 通过其简洁的 API 以及统一的 HQL 语句，帮助上层程序屏蔽掉底层数据库的差异，增强了程序的可移植性。\")]),t._v(\" \"),v(\"p\",[t._v(\"在一些大数据量、高并发、低延迟的场景中，Hibernate 在性能方面带来的损失就会逐渐显现出来。\")]),t._v(\" \"),v(\"p\",[t._v(\"MyBatis 中一个重要的功能就是可以帮助 Java 开发封装重复性的 JDBC 代码，这与前文分析的 Spring Data JPA 、Hibernate 等 ORM 框架一样。MyBatis 封装重复性代码的方式是通过 Mapper 映射配置文件以及相关注解，将 ResultSet 结果映射为 Java 对象，在具体的映射规则中可以嵌套其他映射规则和必要的子查询，这样就可以轻松实现复杂映射的逻辑，当然，也能够实现一对一、一对多、多对多关系映射以及相应的双向关系映射。\")]),t._v(\" \"),v(\"p\",[t._v(\"MyBatis 相较于 Hibernate 和各类 JPA 实现框架更加灵活、更加轻量级、更加可控。\")]),t._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[t._v(\"我们可以在 MyBatis 的 Mapper 映射文件中，直接编写原生的 SQL 语句，应用底层数据库产品的方言，这就给了我们直接优化 SQL 语句的机会；\")])]),t._v(\" \"),v(\"li\",[v(\"p\",[t._v(\"我们还可以按照数据库的使用规则，让原生 SQL 语句选择我们期望的索引，从而保证服务的性能，这就特别适合大数据量、高并发等需要将 SQL 优化到极致的场景；\")])]),t._v(\" \"),v(\"li\",[v(\"p\",[t._v(\"在编写原生 SQL 语句时，我们也能够更加方便地控制结果集中的列，而不是查询所有列并映射对象后返回，这在列比较多的时候也能起到一定的优化效果。（当然，Hibernate 也能实现这种效果，需要在实体类添加对应的构造方法。）\")])])])])}),[],!1,null,null,null);a.default=_.exports}}]);","extractedComments":[]}