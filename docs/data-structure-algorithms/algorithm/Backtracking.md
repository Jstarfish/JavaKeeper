---
title: 回溯算法
date: 2023-05-09
tags: 
 - back tracking
categories: Algorithm
---

![](https://img.starfish.ink/leetcode/backtracking-banner.png)

> 「回溯算法」是解决很多算法问题的常见思想，它也是传统的人工智能的方法，其本质是 **在树形问题中寻找解** 。
>
> 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。所以也可以叫做**回溯搜索法**。
>
> 回溯是递归的副产品，只要有递归就会有回溯。

# 回溯算法





## 基本思想

**回溯法** 采用试错的思想，它尝试分步的去解决一个问题。

回溯算法（Backtracking）是一种系统地搜索解问题空间的算法，主要用于解决组合问题。

其基本思想是通过构建一个问题的解空间树（Solution Space Tree），逐步构造候选解，并在构造过程中判断候选解是否满足约束条件。如果满足，则继续向下构造；如果不满足，则回溯（Backtrack）到上一步，尝试其他候选解。

回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

- 找到一个可能存在的正确的答案；
- 在尝试了所有可能的分步方法后宣告该问题没有答案。



我刚开始学习「回溯算法」的时候觉得很抽象，一直不能理解为什么 **递归之后需要做和递归之前相同的逆向操作**，在做了很多相关的问题以后，我发现其实「回溯算法」与「 **深度优先遍历** 」有着千丝万缕的联系。

> **深度优先搜索** 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 **尽可能深** 的搜索树的分支。当结点 `v` 的所在边都己被探寻过，搜索将 **回溯** 到发现结点 `v` 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等



## 回溯算法的基本框架

回溯算法的基本框架可以用递归来实现，通常包含以下几个步骤：

1. **选择和扩展**：选择一个可行的扩展步骤，扩展当前的解。
2. **约束检查**：检查当前扩展后的解是否满足问题的约束条件。
3. **递归调用**：如果当前解满足约束条件，则递归地尝试扩展该解。
4. **回溯**：如果当前解不满足约束条件，或所有扩展步骤都已经尝试，则回溯到上一步，尝试其他可能的扩展步骤。

以下是回溯算法的一般伪代码：

```java
function backtrack(solution, candidates):  //入参可以理解为 路径, 选择列表
    if solution 是一个完整解:  //满足结束条件
        process(solution)  # 处理当前完整解
        return
    for candidate in candidates:
        if candidate 满足约束条件:
            solution.add(candidate)  # 扩展解
            backtrack(solution, new_candidates)  # 递归调用
            solution.remove(candidate)  # 回溯

result = []
function backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表) // 递归调用
        撤销选择
```





## 热门面试题

### [电话号码的字母组合_17](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)
>
> ```
> 输入：digits = "23"
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```

思路：

![17. 电话号码的字母组合](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png)

图中可以看出遍历的深度，就是输入"23"的长度，而叶子节点就是我们要收集的结果，输出["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]。



![](https://pic.leetcode-cn.com/02b0ec926e3da5f12a0a118293b8ac10dc236741ccb04414ded44a30f7fc70af-1573829897(1).jpg)





### [括号生成_22](https://leetcode.cn/problems/generate-parentheses/)

> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
> ```
> 输入：n = 3
> 输出：["((()))","(()())","(())()","()(())","()()()"]
> ```



### [全排列_46](https://leetcode.cn/problems/permutations/description/)

> 给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```