---
title: 动态规划——刷题有套路
date: 2024-03-09
tags: 
 - Algorithm
categories: Algorithm
---

> 动态规划，简直就是刷题模板、套路届的典范

## 一、前言

为了面试，不，不，为了提高技术能力，我重拾算法有一段时间了，但是每次都把动态规划放在了后边，因为这个大名鼎鼎的名字，听着就感觉很牛逼，很难学的样子。

> **动态规划**（英语：Dynamic programming，简称DP）是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20 世纪 50 年代初美国数学家 R.E.Bellman 等人在研究多阶段决策过程(multistep decision process) 的优化问题时，提出了著名的最优化原理 (principle of optimality)，把多阶段过程转化为一系列单阶段问题，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957 年出版了他的名著 Dynamic Programming，这是该领域的第一本著作。
>
> 动态规划问世以来，在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便。
>
> 虽然动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。
>

看完之后，我说了一句脏话，然后就开始找相关文章了。



## 二、写在前面

计算机归根结底只会做一件事：穷举。

所有的算法都是在让计算机【如何聪明地穷举】而已，动态规划也是如此。

> A ： "1+1+1+1+1+1+1+1 =？等式的值是多少"
>
> B ： 计算 "8"
>
> A : 在上面等式的左边写上 "1+" 呢？ "此时等式的值为多少"
>
> B : 很快得出答案 "9"
>
> A : "你怎么这么快就知道答案了"
>
> B : "只要在8的基础上加1就行了"
>
> A : "所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"

本文将会从以下角度来讲解动态规划：

- 什么是动态规划
- 动态规划从入门到进阶
- 再谈动态规划



## 三、动态规划是什么

动态规划(dynamic programming)是运筹学的一个分支，是解决<mark>**「多阶段决策」**</mark>过程最优化的一种数学方法。

**一般用来求最值问题**，多数情况下它可以采用<mark>**「自下而上」**</mark>的递推方式来得出每个子问题的最优解（即<mark>**「最优子结构」**</mark>），进而自然而然地得出依赖子问题的原问题的最优解。

有几个比较眼生的概念，我们看下：

- **多阶段决策**：比如说我们有一个复杂的问题要处理，我们可以按问题的时间或从空间关系分解成几个互相联系的阶段，使每个阶段的决策问题都是一个比较容易求解的“**子问题**”，这样依次做完每个阶段的最优决策后，他们就构成了整个问题的最优决策。简单地说，就是每做一次决策就可以得到解的一部分，当所有决策做完之后，完整的解就“浮出水面”了。有一种**大事化小，小事化了**的感觉。

- **最优子结构**：在我们拆成一个个子问题的时候，每个子问题一定都有一个最优解，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。

- **自下而上**：或者叫自底向上，对应的肯定有**自上而下**（自顶向下）

  - 啥叫**自顶向下**，比如我们求解递归问题，画递归树的时候，是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」，比如我们用递归法计算斐波那契数列的时候

    ![](https://img.starfish.ink/leetcode/up2down.png)

    

  - 反过来，自底向上，肯定就是从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

    ![](https://img.starfish.ink/leetcode/down2up.png)



从递归树中我们可以看到，自顶向下的递归算法，我们会求两次 f(18)，三次 f(17)，，，这就存在了大量的**「重复子问题」**，这样暴力穷举的话效率会极其低下，为了解决重复子问题，我们可以通过「**备忘录**」或者「**DP table**」来优化穷举过程（记忆化递归法），避免不必要的计算。

怎样才能自下而上的求出每个子问题的最优解呢，可以肯定子问题之间是有一定联系的，即**迭代递推公式**，也叫<mark>「**状态转移方程**」</mark>，实际上就是描述问题结构的数学形式。（把 `f(n)` 想做一个状态 `n`，这个状态 `n` 是由状态 `n - 1` 和状态 `n - 2` 相加转移而来，这就叫状态转移，仅此而已）

> 动态规划中当前的状态往往依赖于前一阶段的状态和前一阶段的决策结果。例如我们知道了第 i 个阶段的状态 Si 以及决策 Ui，那么第 i+1 阶段的状态 Si+1 也就确定了。所以解决动态规划问题的关键就是确定状态转移方程，一旦状态转移方程确定了，那么我们就可以根据方程式进行编码。

> 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。
>
> 动态规划在查找有很多**重叠子问题**的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，而不会在解决同样问题时再花费时间。
>
> 动态规划只能应用于有**最优子结构**的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。

以上提到的**重叠(复)子问题、最优子结构、状态转移方程就是动态规划三要素**。

> 解决动态规划问题的核心：找出子问题及其子问题与原问题的关系



### 斐波那契数列

PS：我们先从一个简单的斐波那契数列来进一步理解下重叠子问题与状态转移方程（斐波那契数列并不是严格意义上的动态规划，因为它没有求最值，所以也没涉及到最优子结构的问题）

**1、暴力递归**

斐波那契数列的数学形式就是递归的，写成代码就是这样：

```java
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

这个不用多说了，我们在 **自顶向下** 那部分画出的就是它的递归树，他有大量的重复计算问题，比如 `f(18)` 被计算了两次，而且你可以看到，以 `f(18)` 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 `f(18)` 这一个节点被重复计算，所以这个算法及其低效。

这就是动态规划问题的第一个性质：**重叠子问题**。下面，我们想办法解决这个问题。

**2、带备忘录的递归解法**

明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题就先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。相当于我们业务开发中的缓存。

一般使用一个数组充当这个「备忘录」，当然也可以使用哈希表（字典），思想都是一样的，也有人叫 **记忆化递归法**。

```java
public static int fib(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    //用一个数组充当备忘录，保存记录
    int[] dp = new int[n + 1];
    //初始值
    dp[0] = 0;
    dp[1] = 1;
    for(int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
// 用 hash 表当备忘录
public int fib(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    if (hashMap.containsKey(n)) {
        return hashMap.get(n);
    } else {
        int result = fib(n - 1) + fib(n - 2);
        hashMap.put(n,result);
        return result;
    }
}
```

带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过<mark>「**剪枝」**</mark>，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

**3、动态规划解法**

有了上一步「备忘录」的启发，**自顶向下**的递推，每次“缓存”之前的结果，那**自底向上**的推算不也可以吗？而且推算的时候，我们只需要存储之前的两个状态就行，还省了很多空间，我靠，真是个天才，这就是，**动态规划**的做法。

![](https://img.starfish.ink/leetcode/down2up.png)

画个图就很好理解了，我们一层一层的往上计算，得到最后的结果。

斐波那契数列的定义其实就是个**状态转移方程**：$f(n) = f(n-1) + f(n-2)$，$f(n)$ 就是子问题的状态，这个状态是由  $f(n-1)$ 和  $f(n-2)$ 这两个状态相加转移过来的，这就是状态转移。是不又有点理解了？

最难的状态转移方程有了，看下代码，定义三个变量循环迭代完成计算，搞定

```java
public int fib(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    int result = 0, pre = 1, next = 2;
    for (int i = 3; i < n + 1; i++) {
        result = pre + next;
        pre = next;
        next = result;
    }
    return result;
}
```

有没有发现，这个状态转移方程的写法，和暴力破解有着千丝万缕的联系。其实状态转移方程直接代表着暴力解法。



## 四、什么样的题目适合用动态规划

求最值的核心问题，无非就是穷举，就是把所有可能的结果都穷举出来，然后找到最值。但穷举从来不是一个好方法。

可以使用动态规划的问题一般都有一些特点可以遵循。如题目的问法一般是三种方式：

1. 求最大值/最小值（除了类似找出数组中最大值这种）

   乘积最大子数组、最长回文子串、最长上升子序列等等

2. 求可行性（True 或 False）

   凑领钱、字符串交错组成问题

3. 求方案总数

   路径规划问题

如果你碰到一个问题，是问你这三个问题之一的，那么有 90% 的概率是可以使用动态规划来求解。



一个问题是否能够用动态规划算法来解决，需要看这个问题是否能被分解为更小的问题（子问题）。而子问题往下细分为更小的子问题的时候往往会遇到重复的子问题，我们只处理同一个子问题一次，将它的结果保存起来，这就是动态规划最大的特点。

接下来就要去理解动态规划的思路了，通常情况下，DP 题可从下面 4 个要素去逐步剖析：

**1. 状态是什么**

**2. 状态转移方程是什么**

**3. 状态的初始值是什么**

**4. 问题要求的最后答案是什么**



## 五、套路解题

动态规划是用大白话说就是一个算法范例（或者理解为一个方法论，模板），**通过将其分解为子问题来解决给定的复杂问题，并存储子问题的结果，以避免再次计算相同的结果**。

我们知道了动态规划三要素：重叠子问题、最优子结构、状态转移方程。

那要解决一个动态规划问题的大概步骤，就围绕这三要素展开：

1. **划分阶段：**分析题目可以用动态规划解决，那就先看这个问题如何划分成各个子问题

2. **状态定义**：也有叫选择状态的，其实就是定义子问题，我理解其实就是看求解的结果，我们一般用数组来存储子问题结果，所以状态我们一般定义为 $dp[i]$，表示规模为 i 的问题的解，$dp[i-1]$ 就是规模为 i-1 的子问题的解

3. **确定决策并写出状态转移方程：**听名字就觉得牛逼的一步，肯定也是最难的一步，其实就是我们从 f(1)、f(2)、f(3) ...  f(n-1) 一步步递推出 f(n) 的表达式，也就是说，dp[n] 一定会和 dp[n-1], dp[n-2]....存在某种关系的，这一步就是找出数组元素的关系式，比如斐波那契数列的关系式 $dp[n] = dp[n-1] + dp[n-2]$

   > 一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的

4. **找出初始值（包括边界条件）：**既然状态转移方程式写好了，但是还需要一个**支点**来撬动它进行不断的计算下去，比如斐波那契数列中的 f(1)=1，f(2)=1，就是初始值

5. **优化**：思考有没有可以优化的点



**写出状态转移方程是最困难的**，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

按上面的套路走，最后的结果就可以套这个框架：

```java
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

下面通过几道经典、且极其常见的面试题来看下动态规划解题套路



## 六、找感觉（刷题）

斐波那契数列上手后，我们用解题套路看下 leetcode_70，据说是道正宗的动态规划问题。

### 1、[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)（leetcode_70）

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。
>
> ```
>输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶
> 2.  2 阶
> ```

这是一道 easy 题，又想说脏话了，当时我拿到这么一道题后，一点想法都没有。

#### 分析题目

不管了，“穷举思想”

假设 n = 5，有 5 级楼梯要爬。每次都有 2 种选择：爬 1 级或爬 2 级。

如果爬 1 级，则剩下 4 级要爬。

如果爬 2 级，则剩下 3 级要爬。

这分出了 2 个子问题：爬 4 级楼梯有几种方式？爬 3 级楼梯有几种方式？

爬 5 级楼梯的方式数 = 爬 4 级楼梯的方式数 + 爬 3 级楼梯的方式数，这样往下递归分析

爬 4 级楼梯的方式数 = 爬 3 级楼梯的方式数 + 爬 2 级楼梯的方式数

> 第二次做的时候，我没有用 『自底向上』，而是用『自上向下』的举例，陷入了一种错误
>
> 我想的是 f(n) = f(n-1) + 1，从上往下的算，留出一级，肯定只能是爬 1 级这一种，所以
>
> f(5) = f(4) + 1 .......

这不是上一节的斐波那契数列吗？？？？？ 

用 $f(x)$ 表示爬到第 x 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：

$f(x) = f(x - 1) + f(x - 2)$

它意味着爬到第 $x$ 级台阶的方案数是爬到第 $x - 1$ 级台阶的方案数和爬到第 $x - 2$ 级台阶的方案数的和。

我们看下这道题的思路：

“穷举”之后，发现可以拆分成各个子问题（或者一看问题是多少种方案），推断可以用动态规划

1. **定义状态**：用 $dp[n]$ 表示最后的的结果
2. **初始状态**：只有 1 级台阶的话 dp[0] =0，dp[1] = 1
3. **状态转移方程**：dp[i] = dp[i - 1] + dp[i - 2]
4. **返回结果**： dp[n] 即我们要的结果

```java
public int climbStairs(int n) {
    // 创建一个数组来保存历史数据
    int[] dp = new int[n + 1];
    // 给出初始值, 爬楼梯的初始值
    dp[0] = 0;
    dp[1] = 1;
    for(int i = 2; i <= n; i++) {
        //写出状态转移方程
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

优化方案就是按斐波那契，只保存前两个状态值，优化空间的方案，这里就不多说了。



### 2、[最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)（leetcode_53）

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> ```
>输入: [-2,1,-3,4,-1,2,1,-5,4]
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
> ```
> 

#### 小技巧——涨知识

拿到这类题目，避免不了的是要遍历，假设我们给定数组 [a,b,c,d,e] ，通常我们遍历子串或者子序列有如下三种遍历方式：

- 以某个元素开头的所有子序列，比如以 a 开头的子序列  [a]，[a, b]，[ a, b, c] ... 接着是以  b 开头的子序列 [b]，[b, c]，[b,c,d] ... 接着是 c 开头、d 开头...
- 以子序列的长度为基准，比如先遍历出子序列长度为 1 的子序列，再遍历出长度为 2 的 ...
- 以某个元素结尾的所有子序列，比如以 a 结束的子序列只有 [a]，以 b 结束的子序列 [a,b]，[b]，以 c 结束的子序列 [a,b,c]，[b,c]，[c]，以 d 结束的 ...

想想这道题，用哪种遍历方式合适一些呢？

用哪种遍历方式，可以逐个分析嘛。第一种遍历方式通常用于暴力解法，第二种后边我们也会用到（最长回文子串），第三种由于可以产生递推关系，动态规划问题用的挺多的。

#### 分析题目

拿到这个题目先理解了意思，我们要求的是连续子数组的和最大那一个，所以我们肯定要遍历出所有子数组，并把每个子数组的和保存起来，然后去比较找到最大的那个就是我们要的结果了。

用暴力法从头遍历所有子序列，用两个变量，一个记录最大和，一个记录当前和，双层循环也可以解决。

最值问题，我们分析用动态规划解题：

1. **定义状态**：$dp[i]$ 表示索引从 0 到 i 的元素组成的数组中最大子序和；

2. **初始状态**：如果数组只有 1 个元素，那 dp 数组的第一个元素也就是数组的第一个元素本身，**`dp[0] = nums[0]`**;

3. **状态转移方程**：因为我们的数组中可能有负数的情况，从头遍历的话，如有下一个元素是负数的话，和反而更小了，所以我们遍历以元素结尾的子序列，若前一个元素大于 0（$nums[i-1] > 0$），则将它加到当前元素上 $nums[i] = nums[i-1]+nums[i]$。最终 $nums[i]$ 保存的是以原先数组中 $nums[i]$ 结尾的最大子序列和。最后整体遍历一遍 $nums[i]$ 就能找到整个数组最大的子序列和啦。所以状态转移方程：

   $dp[i]=\max \{nums[i],dp[i−1]+nums[i]\}$

4. **输出结果**：转移方程只是保存了当前元素的最大和，我们要求的是最终的那个最大值，所以需要从 dp[i] 中找到最大值返回

```java
public int maxSubArray(int[] nums) {
    //特判
    if (nums == null || nums.length == 0) {
        return 0;
    }
    //初始化
    int length = nums.length;
    int[] dp = new int[length];
    // 初始值,只有一个元素的时候最大和即它本身
    dp[0] = nums[0];
    int ans = nums[0];
    // 状态转移
    for (int i = 1; i < length; i++) {
        // 取当前元素的值 和 当前元素的值加上一次结果的值 中最大数
        dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
        // 输出结果：和最大数对比 取大
        ans = Math.max(ans, dp[i]);
    }
    return ans;
}
```

#### 优化

同样的套路，考虑到 $f(i)$ 只和 $f(i - 1)$ 相关，于是我们可以只用一个变量 pre 来维护对于当前 $f(i)$ 的 $f(i - 1)$ 的值是多少，从而让空间复杂度降低到 $O(1)$，这有点类似「滚动数组」的思想

```java
public int maxSubArray(int[] nums) {
    int pre = 0, maxAns = nums[0];
    for (int x : nums) {
        pre = Math.max(pre + x, x);
        maxAns = Math.max(maxAns, pre);
    }
    return maxAns;
}
```



### 3、[ 打家劫舍](https://leetcode-cn.com/problems/house-robber/)（leetcode_198）

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>
> ```
>输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> ```
> 
> 
>提示：
> 
>0 <= nums.length <= 100
> 0 <= nums[i] <= 400

#### 分析题目

拿到这个题目，看到这道题是 easy，我飘了，心想，这不就两种情况吧，奇数列求和，偶数列求和，比较后得出结果，太简单了吧吧吧吧~（个人感觉官网给的这两个例子误导了聪明的我）

但是回头一想，这一道动态规划标签下的题，不能被我这么容易的解决，反过来想，小偷也不可能非得从第一家或者第二家隔一间偷一偷，可能是从中间随便一间开始的，比如 [4,3,2,5,1] ，我就会去偷第一家和第四家。

1. **定义状态**：用 $dp[i]$ 存储前 i 间房屋能偷窃到的最高总金额

2. **初始状态**：如果只有一间房子，只能偷一间了，最大金额 dp[0]，如果有两间房子，偷钱最多的那一件，最大金额 $\max \{dp[0],dp[1]\}$，即

   $$ f(n)= \begin{cases} 	dp[0]=nums[0], & \text{只有一间房屋，则偷窃该房屋}\\ 	dp[1]=\max \{dp[0],dp[1]\},& \text{只有两间房屋，选择其中金额较高的房屋进行偷窃} \end{cases} $$

3. **状态转移方程**：由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值，即 $dp[i]=\max \{dp[i-1],dp[i−2]+nums[i]\}$

4. **输出结果**：$dp[n−1]$

```java
public int rob(int[] nums) {
    //特判
    if (nums == null || nums.length == 0) return 0;
    //创建动态数组
    int length = nums.length;
    int[] dp = new int[length];
    //初始状态
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    //转移方程
    for (int i = 2; i < length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    //取值：当前下标，即length-1
    return dp[length - 1];
}
```

#### 优化

同样的优化套路，上述方法使用了数组存储结果。但是每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。和斐波那契数列优化同理。

```java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int length = nums.length;
    if (length == 1) {
        return nums[0];
    }
    int first = nums[0], second = Math.max(nums[0], nums[1]);
    for (int i = 2; i < length; i++) {
        int temp = second;
        second = Math.max(first + nums[i], second);
        first = temp;
    }
    return second;
}
```



### 4、[不同路径](https://leetcode-cn.com/problems/unique-paths/)（leetcode_62）

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
> 问总共有多少条不同的路径？
>
> ![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)
>
> 例如，上图是一个7 x 3 的网格。有多少可能的路径？
>
> ```
>输入: m = 3, n = 2
> 输出: 3
> 解释:
> 从左上角开始，总共有 3 条路径可以到达右下角。
> 
> 1. 向右 -> 向右 -> 向下
> 2. 向右 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向右
> ```
> 
> ```
>输入: m = 7, n = 3
>输出: 28
> ```
>
> **提示：**
> 
> - `1 <= m, n <= 100`
> - 题目数据保证答案小于等于 `2 * 10 ^ 9`

#### 分析题目

1. **定义状态**：这是个求方案总数的问题，大概率可以用动态规划，由于是个表格，像地图一样，有坐标，我们用二维数组来存储结果 $dp[m][n]$，代表到达位置 (m, n) 的所有路径的总数

2. **初始状态**：$dp[m][n]$ 表示到坐标 (m,n) 的路径条数。由于机器人从 m=0,n=0 出发，每次只能向下或者向右移动，因此，在所有坐标为（0，m) 的位置机器人要到达的话只有一条路径（一直向下）；在所有坐标为（n,0) 的位置，机器人要到达也只有一条路径（一直向右）在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法。因此初始值是：

   ```java
   dp[0] [0….n-1] = 1;  // 机器人一直向右走，第 0 列统统为 1
   dp[0…m-1] [0] = 1;  // 机器人一直向下走，第 0 列统统为 1
   ```

3. **状态转移方程**：要到达任一位置 (m,n) 的总路径条数，总是等于位置 (m-1,n) 的路径条数加上位置（m,n-1) 的路径条数。即 $dp[m][n] = dp[m-1][n] + dp[m][n-1]$

4. **输出结果**：由于数组是从下标 0 开始算起的，所以 $dp[m - 1][n - 1]$ 才是我们要的结果

![](https://img.starfish.ink/algorithm/uniquePaths.png)

```java
public int uniquePaths(int m, int n) {

    //定义二维数组保存路径
    int dp[][] = new int[m][n];

    //定义初始值
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }

    for (int j = 0; j < n; j++) {
        dp[0][j] = 1;
    }

    // 排除初始值的情况，都从 1 开始循环
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    // 由于数组是从下标 0 开始算起的，所以dp[m - 1][n - 1] 是我们要的结果
    return dp[m - 1][n - 1];
}
```

#### 优化

我们的状态转移方程： $dp[m][n] = dp[m - 1][n] + dp[m][n - 1]$，可以看到我们其实只需要 $dp[m - 1][n]$ 和 $dp[m][n - 1]$，只需要记录这两个数就可以了，这其实相当于转换为一维数组，dp[i] = dp[1] + dp[0]

```java
public int uniquePaths(int m, int n) {
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j - 1] + dp[j];
        }
    }
    return dp[n - 1];
}
```



### 5、[零钱兑换](https://leetcode-cn.com/problems/coin-change/)（leetcode_322）

> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 (你可以认为每种硬币的数量是无限的。)
>
> ```
>输入: coins = [1, 2, 5], amount = 11
> 输出: 3 
> 解释: 11 = 5 + 5 + 1
> ```
> 
> ```
>输入: coins = [2], amount = 3
>输出: -1
> ```
>

#### 分析题目

题目问最少的硬币个数，一般可用 DP 来解，看看可以拆分子问题不

以 coins = [1, 2, 5]，amount = 11 为例。我们要求组成 11 的最少硬币数，可以考虑组合中的最后一个硬币分别是1，2，5 的情况，比如：

- 最后一个硬币是 1 的话，最少硬币数应该为【组成 10 的最少硬币数】+ 1枚（1块硬币）
- 最后一个硬币是 2 的话，最少硬币数应该为【组成 9 的最少硬币数】+ 1枚（2块硬币）
- 最后一个硬币是 5 的话，最少硬币数应该为【组成 6 的最少硬币数】+ 1枚（5块硬币）

在这 3 种情况中硬币数最少的那个就是结果

按同样的道理，我们也可以分别再求出组成 10 的最少硬币数，组成 9 的最少硬币数，组成 6 的最少硬币数。。。DP 的套路无疑了。

1. **定义状态**：凑齐总金额 i 需要最少硬币个数 $dp[i]$

2. **初始状态**：假设金额是 0 ，那就不需要硬币了，即 $dp[0] = 0$

3. **状态转移方程**：从例子中我们可以看出结果可以这么表示 $dp[11]=\min \{dp[10]+1,dp[9]+2,dp[6]+5\}$，但我们不知道最后一枚硬币的面值是多少，所以我们需要枚举每个硬币面额值，从中选出最小值

   ```java
   for(int coin : coins){
       result = Math.min(result,1+dp[amout-coin])
   }
   ```

4. **输出结果**： $dp[amout]$ 

```java
public int coinChange(int[] coins, int amount) {
    //定义数组
    int[] dp = new int[amount + 1];

    int max = amount + 1;
    // 初始化每个值为 amount+1，这样当最终求得的 dp[amount] 为 amount+1 时，说明问题无解, 或者初始化一个特殊值
    Arrays.fill(dp, max);

    //初始值
    dp[0] = 0;
    // 外层 for 循环在遍历所有可能得金额，（从1到amount）
    //dp[i]上的值不断选择已含有硬币值当前位置的数组值 + 1，min保证每一次保存的是最小值
    for (int i = 1; i < amount + 1; i++) {
        //内层循环所有硬币面额
        for (int coin : coins) {
            //如果i<coin，当前硬币coin面额太大，无法凑成金额i
            if (i >= coin) {
                //分两种情况，使用硬币coin和不使用，取最小值
                dp[i] = Math.min(dp[i - coin] + 1, dp[i]);
            }
        }
    }
    return dp[amount] == amount + 1 ? -1 : dp[amount];
}
```

> 为啥 `dp` 数组初始化为 `amount + 1` 呢，因为凑成 `amount` 金额的硬币数最多只可能等于 `amount`（全用 1 元面值的硬币），所以初始化为 `amount + 1` 就相当于初始化为正无穷，便于后续取最小值。为啥不直接初始化为 int 型的最大值 `Integer.MAX_VALUE` 呢？因为后面有 `dp[i - coin] + 1`，这就会导致整型溢出。
>
> 最终，dp[amout] 就是凑成总金额所需的最少硬币数，如果dp[amount] 仍是初始化的较大值，说明无法凑出，返回 -1。



### 6、[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)（leetocode_121）

> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
> 
>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
> 
>注意：你不能在买入股票前卖出股票。
> 
>```
> 输入: [7,1,5,3,6,4]
>输出: 5
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
> 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> ```
> 
>   ```
> 输入: [7,6,4,3,1]
>输出: 0
> 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
>```

#### 分析题目

我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）

```java
public int dp(int[] prices) {
  int length = prices.length;
  if (length == 0) {
    return 0;
  }
  int dp[] = new int[length];
  //保存一个最小值
  int minPrice = prices[0];
  for (int i = 1; i < length; i++) {
    minPrice = Math.min(minPrice, prices[i]);
    dp[i] = Math.max(dp[i - 1], prices[i] - minPrice);
  }
  return dp[length - 1];
}
```



### 7、最长回文子串（leetcode_5）

> 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
>
> ```
>输入: "babad"
> 输出: "bab"
> 注意: "aba" 也是一个有效答案。
> ```

#### 分析题目

回文的意思是正着念和倒着念一样，如：大波美人鱼人美波大

建立二维数组 `dp` ，找出所有的回文子串。

回文串两边加上两个相同字符，会形成一个新的回文串 。

![](https://writings.sh/assets/images/posts/algorithm-longest-palindromic-substring/longest-palindromic-substring-dp-2-1.jpeg)



我们用`dp[i][j]` 记录子串 `i..j` 是否为回文串 。

![img](https://writings.sh/assets/images/posts/algorithm-longest-palindromic-substring/longest-palindromic-substring-dp-2-2.jpeg)

首先，单个字符就形成一个回文串，所以，所有 `dp[i][i] = true` 。

![img](https://writings.sh/assets/images/posts/algorithm-longest-palindromic-substring/longest-palindromic-substring-dp-2-3.jpeg)

然后，容易得到递推关系：

如果字符 `s[i]` 和 `s[j]` 相等，并且子串 `i+1..j-1` 是回文串的话，子串 `i..j` 也是回文串。

也就是，如果 `s[i] == s[j]` 且 `dp[i+1][j-1] = true` 时，`dp[i][j] = true` 。

![img](https://writings.sh/assets/images/posts/algorithm-longest-palindromic-substring/longest-palindromic-substring-dp-2-4.jpeg)

这是本方法中主要的递推关系。

不过仍要注意边界情况，即 子串 `i+1..j-1` 的有效性 ，当 `i+1 <= j-1` 时，它才有效。

反之，如果不满足，此时 `j <= i+1` ，也就是子串 `i..j` 最多有两个字符， 如果两个字符 `s[i]` 和 `s[j]` 相等，那么是回文串。

```java
public String longestPalindrome_1(String s) {
  int length = s.length();
  if (length < 2) {
    return s;
  }
  boolean dp[][] = new boolean[length][length];
  for (int i = 0; i < length; i++) {
    dp[i][i] = true;
  }

  char[] chars = s.toCharArray();

  //通过最大长度定位回文串位置，或者也可以用个数组记录int[] res = new int[2];
  int maxLen = 1;
  int begin = 0;
  for (int r = 1; r < length; r++) {
    for (int l = 0; l < r; l++) {
      if (chars[l] != chars[r]) {
        dp[l][r] = false;
      } else {
        // 特例，如果 是 abaa 这种，需要最后一个和第一个也相等，但是他们距离大于等于了3，所以还需要往里判断
        if (r - l < 3) {
          dp[l][r] = true;
        } else {
          dp[l][r] = dp[l + 1][r - 1];
        }
      }

      //只要 dp[l][r] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置
      if (dp[l][r] && r - l + 1 > maxLen) {
        maxLen = r - l + 1;
        begin = l;
      }
    }
  }
  return s.substring(begin, begin + maxLen);
}
```



### 8、数字三角形问题

```
7
3 8
8 1 0
2 7 4 4 
4 5 2 6 5
```

从上到下选择一条路，使得经过的数字之和最大。

路径上的每一步只能往左下或者右下走。

#### 分析题目

递归解法

可以看出每走第n行第m列时有两种后续:向下或者向右下。由于最后一行可以确定,当做边界条件,所以我们自然而然想到递归求解

```java
class Solution{

	public int getMax(){
		int MAX = 101;
		int[][] D = new int[MAX][MAX];   //存储数字三角形
		int n;              //n表示层数
		int i = 0; int j = 0;
		int maxSum = getMaxSum(D,n,i,j);
		return maxSum;
	}

	public int getMaxSum(int[][] D,int n,int i,int j){
		if(i == n){
			return D[i][j];
		}
		int x = getMaxSum(D,n,i+1,j);
		int y = getMaxSum(D,n,i+1,j+1);
		return Math.max(x,y)+D[i][j];
	}
}
```





## 总结

![](https://pic2.zhimg.com/80/v2-4e3a7d5ae4bb76ce96bc3393013f13f8_720w.jpg?source=1940ef5c)



## 番外篇

### 动态规划与其它算法的关系

#### 分治

解决分治问题的时候，思路就是想办法把问题的规模减小，有时候减小一个，有时候减小一半，然后将每个小问题的解以及当前的情况组合起来得出最终的结果。例如归并排序和快速排序，归并排序将要排序的数组平均地分成两半，快速排序将数组随机地分成两半。然后不断地对它们递归地进行处理。

这里存在有最优的子结构，即原数组的排序结果是在子数组排序的结果上组合出来的，但是不存在重复子问题，因为不断地对待排序的数组进行对半分的时候，两半边的数据并不重叠，分别解决左半边和右半边的两个子问题的时候，没有子问题重复出现，这是动态规划和分治的区别。

#### 贪心

关于最优子结构

- 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录
- 动态规划：全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解

关于子问题最优解组合成原问题最优解的组合方式

- 贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树
- 动态规划：动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案

结果正确性

- 贪心不能保证求得的最后解是最佳的，复杂度低
- 动态规划本质是穷举法，可以保证结果是最佳的，复杂度高





#### 线性动态规划

单串
单串 dp[i] 线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 dp[i] := 考虑[0..i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：

第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0..i]上，且取 i，原问题的解；
第二种是 i 位置可以取可以不取
大部分的问题，对 i 位置的处理是第一种方式，例如力扣：

70 爬楼梯问题
801 使序列递增的最小交换次数
790 多米诺和托米诺平铺
746 使用最小花费爬楼梯
线性动态规划中单串 dp[i] 的问题，状态的推导方向以及推导公式如下



1. 依赖比 i 小的 O(1) 个子问题
dp[n] 只与常数个小规模子问题有关，状态的推导过程 dp[i] = f(dp[i - 1], dp[i - 2], ...)。时间复杂度 O(n)O(n)，空间复杂度 O(n)O(n) 可以优化为 O(1)O(1)，例如上面提到的 70, 801, 790, 746 都属于这类。

如图所示，虽然紫色部分的 dp[i-1], dp[i-2], ..., dp[0] 均已经计算过，但计算橙色的当前状态时，仅用到 dp[i-1]，这属于比 i 小的 O(1)O(1) 个子问题。

例如，当 f(dp[i-1], ...) = dp[i-1] + nums[i] 时，当前状态 dp[i] 仅与 dp[i-1] 有关。这个例子是一种数据结构前缀和的状态计算方式，关于前缀和的详细内容请参考下一章。

2. 依赖比 i 小的 O(n) 个子问题
dp[n] 与此前的更小规模的所有子问题 dp[n - 1], dp[n - 2], ..., dp[1] 都可能有关系。

状态推导过程如下：


dp[i] = f(dp[i - 1], dp[i - 2], ..., dp[0])
依然如图所示，计算橙色的当前状态 dp[i] 时，紫色的此前计算过的状态 dp[i-1], ..., dp[0] 均有可能用到，在计算 dp[i] 时需要将它们遍历一遍完成计算。

其中 f 常见的有 max/min，可能还会对 i-1,i-2,...,0 有一些筛选条件，但推导 dp[n] 时依然是 O(n)O(n) 级的子问题数量。

例如：

139 单词拆分
818 赛车
以 min 函数为例，这种形式的问题的代码常见写法如下


for i = 1, ..., n
    for j = 1, ..., i-1
        dp[i] = min(dp[i], f(dp[j])
时间复杂度 O(n^{2})O(n 
2
 )，空间复杂度 O(n)O(n)



**单串 dp[i] 经典问题**

#### 1. 依赖比 i 小的 O(1) 个子问题

- [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

  状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 dp[i]，时，dp[i - 1], ..., dp[0] 已经计算完。因为子数组是连续的，所以子问题 dp[i] 其实只与子问题 dp[i - 1] 有关。如果 [0..i-1] 上以 nums[i-1] 结尾的最大子数组和(缓存在 dp[i-1] )为非负数，则以 nums[i] 结尾的最大子数组和就在 dp[i-1] 的基础上加上 nums[i] 就是 dp[i] 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。

  按照以上的分析，状态的转移可以写出来，如下


  dp[i] = nums[i] + max(dp[i - 1], 0)
  这个是单串 dp[i] 的问题，状态的推导方向，以及推导公式如下




#### 2. 依赖比 i 小的 O(n) 个子问题

- [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

  输入是一个单串，首先思考单串问题中设计状态 dp[i] 时拆分子问题的方式：枚举子串或子序列的结尾元素来拆分子问题，设计状态 dp[i] := 在子数组 [0..i] 上，且选了 nums[i] 时，的最长上升子序列。

  因为子序列需要上升，因此以 i 结尾的子序列中，nums[i] 之前的数字一定要比 nums[i] 小才行，因此目标就是先找到以此前比 nums[i] 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 nums[i] 小的数字，则当前问题的结果就是 1 。

  按照以上的分析，状态的转移方程可以写出来，如下

  dp[i] = max_{j}(dp[j]) + 1
  dp[i]=max 
  j

   (dp[j])+1

  其中 0 \leq j < i, nums[j] < nums[i]0≤j<i,nums[j]<nums[i]。

- 单串相关练习题
  最经典单串 LIS 系列
  最大子数组和系列
  打家劫舍系列
  变形：需要两个位置的情况
  与其它算法配合
  其它单串 dp[i] 问题
  带维度单串 dp[i][k]
  股票系列

  



## Reference

- http://netedu.xauat.edu.cn/jpkc/netedu/jpkc/ycx/kcjy/kejian/pdf/05.pdf

- https://leetcode-cn.com/circle/article/lxC3ZB/

- https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie

- https://www.zhihu.com/question/39948290

- https://zhuanlan.zhihu.com/p/26743197

- https://writings.sh/post/algorithm-longest-palindromic-substrings

